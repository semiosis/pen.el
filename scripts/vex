#!/bin/bash
export TTY

. $SCRIPTS/lib/hs

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -f) {
        ex_script_file="$2"
        shift
        shift
    }
    ;;

    *) break;
esac; done

# ex -s +%s/127/128/g +%p +q! /etc/hosts

# v "$input_fp"

stdin_exists() {
    {
    ! [ -t 0 ] && \
    ! test "$NO_STDIN" = y ` # for notty. e.g. notty xt vim ` && \
    ! test "$(readlink /proc/$$/fd/0)" = /dev/null  && \
    ! test "$(readlink /proc/$$/fd/0)" = "$(readlink /proc/$$/fd/1)"
    # stdin may be redirected to the tty, but  will continue to say false (due to a bash bug)
    # So test to make sure 0 does not point to 1
    } &>/dev/null
}

if stdin_exists; then
    input_fp="$(cat | tf txt)"
    exec <&2
else
    echo "Need stdin. Exiting"
    exit 1
fi

test "$#" -gt 0 && last_arg="${@: -1}"
: "${ex_script_file:="$last_arg"}"

test -f "$ex_script_file" || exit 1

if test -f "$input_fp"; then
    # cat "$input_fp"
    # cat "$ex_fp" | tv &>/dev/null
    # cmd ex -s -S "$ex_fp" "$@"
    # /usr/bin/vim -s -S "$ex_fp" "$@"
    # cmd /usr/bin/vim -S "$ex_script_file" "$@"

    exec <&1
    # /usr/bin/vim -S "$ex_script_file" -c "wq!" "$input_fp"
    # ex -s -S "$ex_script_file" -c "wq!" "$input_fp"

    # It seems that ex doesn't respect the SplitBufIntoBuffers function I made
    # /usr/bin/vim -S "$ex_script_file" -c "wq! $input_fp" "$input_fp"
    ex -s -S "$ex_script_file" -c "wq! $input_fp" "$input_fp"
fi

cat "$input_fp" | pavs

# you can use up to 10 -c commands
# ex -s -c "%s/127/128/g" -c "%p" -c "q!" /etc/hosts
