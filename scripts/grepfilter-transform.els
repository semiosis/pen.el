#!/usr/bin/env -S emacs --quick --script

;; https://gist.github.com/Kreyren/a12e3618525477c3dd5fb16c3de45bf3

(require 'cl-macs)
(require 'pp)
(load "/root/.emacs.d/elpa/s-20210616.619/s.el")
(load "/root/.emacs.d/elpa/dash-20230714.723/dash.el")

;; grepfilter-transform "$bytepos_fp" "$input_fp"

;; Run the transform once per match
;; Run the transform ON the byteps_fp
;; Generate a sed replacement script?

(defun str (thing)
  "Converts object or string to an unformatted string."

  (if thing
      (if (stringp thing)
          (substring-no-properties thing)
        (progn
          (setq thing (format "%s" thing))
          (set-text-properties 0 (length thing) nil thing)
          thing))
    ""))

(defalias 'umn 'identity)
(defalias 'pen-umn 'identity)

(defun test-f (filename)
  (file-exists-p (umn filename)))

(defun tv-basic (s)
  (let ((output-file
         (make-temp-file "tv-basic-output" nil ".txt")))
    (write-to-file s output-file)
    (call-process-shell-command
     "tv" output-file "*pen-sn-stderr*")
    (delete-file output-file))
  s)
(defalias 'tv 'tv-basic)

(defalias 'pps 'pp-to-string)

(defun e/cat (&optional path input no_unminimise)
  "cat out a file, or write to one"
  (if (not no_unminimise)
      (setq path (pen-umn path)))
  (cond
   ((and (test-f path) input) (write-to-file input path))
   ((test-f path) (with-temp-buffer
                    (insert-file-contents path)
                    (buffer-string)))
   (t (error "Bad path"))))

(defmacro comment (&rest body) nil)

(defun cat-to-file (stdin file_path)
  ;; The ignore-errors is needed for babel for some reason
  (ignore-errors (with-temp-buffer
                   (insert stdin)
                   (delete-file file_path)
                   (write-file file_path))))
(defalias 'write-string-to-file 'cat-to-file)
(defalias 'write-to-file 'cat-to-file)

(defvar fds nil)

(defun string-empty-or-nil-p (s)
  (or (not s)
      (string-empty-p s)))

(defun string-not-empty-nor-nil-p (s)
  (not (string-empty-or-nil-p s)))

(defun -filter-not-empty-string (lst)
  (-filter 'string-not-empty-nor-nil-p lst))

(defun grepfilter-transform (input-fp matches-fp bytepos-fp transformed-fp)
  (interactive (list (read-string "Input fp: ")
                     (read-string "Matches fp: ")
                     (read-string "Bytepos fp: ")
                     (read-string "Transformed fp: ")))

  (let* ((input (e/cat input-fp))
         (matches-list (s-lines (e/cat matches-fp)))
         (bytepos-list
          (mapcar
           (lambda (s)
             (let* ((bytepos (s-replace-regexp "^[^:]+:[0-9]+:\\([0-9]+\\).*" "\\1" s))
                    (matchstr (s-replace-regexp "^[^:]+:[0-9]+:[0-9]+:\\(.*\\).*" "\\1" s))
                    (len (length matchstr)))

               (list (string-to-number bytepos) len matchstr)
               ))
           (-filter-not-empty-string
            (s-lines (e/cat bytepos-fp)))))
         (blanked-input
          (with-temp-buffer
            (insert input)
            (buffer-string)))
         (transformed-list (s-lines (e/cat transformed-fp)))
         (output
          (pps
           (list
            blanked-input
            matches-list
            bytepos-list
            transformed-list))))

    (comment
     (with-temp-buffer
       (ignore-errors (insert-file-contents input-fp))
       (search-forward-regexp (concat "^" book))
       (search-forward-regexp (concat "\\b" (str chapter) "[,.]"))
       (beginning-of-line)
       (search-forward-regexp "\\. ")
       (let ((start (point))
             (end (progn
                    (end-of-line)
                    (point))))
         (buffer-substring start end))))
    output))

(defun caddddr (x)
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (cdr (cdr (cdr x))))))

(defun print-output (s)
  ;; Can I speed up pen-sn with call-process-shell-command ?
  (let ((stdin-fd (cdr (assoc "0" fds)))
        (stdout-fd (cdr (assoc "1" fds)))
        (stderr-fd (cdr (assoc "2" fds)))
        (output-file
         (make-temp-file "grepfilter-transform-output" nil ".txt")))

    (write-to-file s output-file)
    (call-process-shell-command
     ;; Sadly, this still doesn't make it to stdout / stderr
     ;; Emacs has completely taken stderr / stdout
     (concat "cat >> " stdout-fd) output-file "*pen-sn-stderr*"))
  ;; Do not do this!
  ;; (write-to-file s "/dev/stdout")
  )

(let ((fdstring (car argv))
      (input-fp (cadr argv))
      (matches-fp (caddr argv))
      (bytepos-fp (cadddr argv))
      (transformed-fp (caddddr argv)))

  (setq fds
        (cl-loop
         for l in (s-lines fdstring)
         collect
         (let ((tp (s-split " " l)))
           (cons (car tp) (cadr tp)))))

  (let ((output
         (grepfilter-transform
          input-fp
          matches-fp
          bytepos-fp
          transformed-fp)))
    ;; Output

    (print-output
     output)))
