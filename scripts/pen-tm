#!/bin/bash

export PS4='+	"$(basename $0)"	${LINENO}	 '

if test "$DEBUG_MODE" = "y"; then
    set -v
    export DEBUG_MODE=y
fi

displayedname() {
    # ðŸ“
    sed -e 's/^.*_//' -e "s/^localhost$/$(hostname | sed 's/[^ _-]*/\u&/g')/"
}

mkdir -p $HOME/notes

# : "${server:="$(pen-tm-get-server)"}"

extra_exports=
while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    -f) {
        FAST=y
        shift
    }
    ;;

    -export) {
        extra_exports+=" $2 "
        shift
        shift
    }
    ;;

    -debug) {
        set -v
        export DEBUG_MODE=y
        shift
    }
    ;;

    *) break;
esac; done

editor() {
    if e running; then
        e c "$1"
    else
        pen-v "$1"
    fi
}

# I still need to know what terminal it is that I am in, if I am in one
export PEN_TMUX="$TMUX"
# This must be unset so terminal open in the correct places
unset TMUX

init-tm() {
    # Unique ID -- prompt for a random thing such as a pokemon, if pen server is running
    uid="$(date +%s)"

    # Ensure the localhost session is up
    #pen-tm ns $(test "$FORCE" = "y" && printf -- "%s\n" "-f") -np -r -l -d -c "$HOME/notes" -n localhost "$SHELL"
    #pen-tm ns $(test "$FORCE" = "y" && printf -- "%s\n" "-f") -np -r -l -d -c "$HOME/notes" -n "${uid}" "$SHELL"

    cd "$HOME/notes"
    tmux start-server
    tmux new-session -d -s localhost -c "$HOME/notes" bash
    tmux set-option -t localhost: lock-after-time 36000

    tmux new-session -d -s "${uid}" -c "$HOME/notes" bash
    tmux set-option -t "${uid}": lock-after-time 36000

    if test "$#" -gt 0; then
        # I want multiple views on the same emacs
        # Therefore, I want multiple sessions
        # pen-tm -S nw -t "${uid}:" -args "$@"

        slug="$(printf -- "%s\n" "$@" | tr '\n' ' ' | sed 's/ $//' | slugify | cut -c -20)"

        tmux neww -t "${uid}": -t "${uid}": -c "$HOME/notes" -n "$slug" "$@"
        tmux kill-window -t "${uid}":1.
    fi

    TMUX= tmux attach -t "${uid}":
    echo init
    exit 0
}

for arg in "$@"; do case "$arg" in
    cat|cat-pane|\
        mfz|fzf|\
        pipe-pane|\
        get-pane|get-session|\
    goto-fzf|\
    filter|\
    man|\
    tw|w|h|pen-v|\
    avy|easymotion|search|nv-wrap|capture-stdout|capture-stdout-wrap|\
    xp|type|typeclip|\
    cap|capp|cap-pane|capture|\
    copy-current-line|\
    copy-pane-command|\
    editsession|\
    send-keys|\
    click|em-click|regex-find|regex-find-coord|regex-click|click-wrap|\
    ep|edit-paste|vp|vipe-paste|\
    edit-file|\
    scrape-filter|\
    scrape-things|\
    scrapep|\
    vipe|eipe|ised|wrto|pipe|tv|ntv|tvs|\
    lw|previous-window|next-window|\
    open-dirs|\
    find-window-from-session|\
    open-files|\
    open-list-of-files-in-emacs|\
    open-list-of-files-in-windows|\
    rsp|n|notify|\
        copy-pane-name|copy-pane-id|\
        recent-isues|sel|select|\
        dv|display-var|mru|most-recently-used|\
        session-exists|target-exists|\
        shpvs|shpv|show-pane-variable|\
        op|shortcuts|d|dir|directories|\
        s|src|source-files|ranger|\
        calc|saykeyunbound|edit-x-clipboard|\
        tnf|new-file|new-script|config) {

        FAST=y
        break
    }
    ;;

    nwf)
        tmux neww bash
        exit 0
    ;;

    init|init-or-attach) {
        shift
        init-tm "$@"
        exit 0
    }
    ;;

    -*) continue
    ;;

    *) break
    ;;
esac; done

pl() {
    printf -- "%s\n" "$@"
    return 0
}

shell="bash; pen-pak ."
shell="zsh"
shell="bash"

if ! test "$FAST" = y && ! tmux info &> /dev/null; then # it's important to have the tmux info check here to prevent infinite init loop

    export FORCE
    CWD="$NOTES" tmux new -d
fi

invocation="$0 $@"

export EDITOR=pen-v

: ${DISPLAY:="0"}

if ! test "$FAST" = "y"; then
    test -f $HOME/.shellrc && . $HOME/.shellrc
    . `which pen-bash-library.sh`
# else
#     PATH="$HOME/scripts:$PATH"
#     PATH="$MYGIT/semiosis/pen.el/scripts:$PATH"
#     PATH="$HOME/scripts-early:$PATH"
fi

is_tty() { [ -t 1 ]; }
stdout_capture_exists() { ! is_tty; }
pager() { if is_tty; then pen-v; else cat; fi; }
stdin_exists() {
    ! [ -t 0 ] && ! test "$(readlink /proc/$$/fd/0)" = /dev/null
}
is_stdout_pipe() {
    [[ -p /dev/stdout ]]
}

if ! test "$FAST" = y; then

    while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
        -p) { # session that called the tmux script
            CALLER_TARGET="$2"
            shift
            shift
        }
        ;;

        *) break;
    esac; done
fi

if [ -n "$CALLER_TARGET" ]; then
    CALLER_TARGET="$CALLER_TARGET"
else
    CALLER_TARGET="$(tmux display -p "#{session_name}")"
fi

if [ -n "$CALLER_PANE" ]; then
    CALLER_PANE="$CALLER_PANE"
else
    CALLER_PANE="$(tmux display -p "#{pane_id}")"
fi

if ! test "$FAST" = y; then

    envstring=

    for e in TMUX PEN_TMUX PATH PAGER EDITOR DISPLAY PYTHONSTARTUP PYTHONPATH CALLER_TARGET PARENT_SESSION_ID PARENT_WINDOW_ID PARENT_SESSION_NAME CURRENT_SESSION_NAME ORIGINAL_DIR $extra_exports; do
        eval val=\${$e}
        envstring+=" $e=\"$val\" "
    done
    envstring="export $envstring; "

fi

: ${CWD:="$(pwd)"};
if [ -d "$CWD" ]; then
    cd "$CWD"
fi
dir="$CWD"

stdin_exists && {
    HAS_STDIN=y
}
stdout_capture_exists && HAS_STDOUT=y

. `which tmux-lib.sh`

tpv() {

    TARGET=
    while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
        -t) {
            TARGET="$2"

            shift
            shift
        }
        ;;

        *) break;
    esac; done

    if [ -z "$TARGET" ]; then
        TARGET="$CALLER_TARGET"
    fi

    varname="$1"
    tmux display -t "$TARGET" -p "#{$varname}"
    return 0
}

DETACHMENT_SENTINEL=y
PRESS_ANY_KEY_ON_ERROR=n

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    -d) {
        DETACHMENT_SENTINEL=n

        (  exec <`pen-tm-tty`  ) &>/dev/null # I should really check this output
        HAS_STDIN=
        HAS_STDOUT=n

        shift
    }
    ;;

    -w|-s)
        DETACHMENT_SENTINEL=y; shift
    ;;

    -S) # no detachment sentinel This is different from detaching immediately. The new window is still created and switched to. But the pen-tm command will not wait for the process to end.
        DETACHMENT_SENTINEL=n; shift
    ;;

    -te) # Use tty from piped command if possible
        {
        HAS_STDIN=
        HAS_STDOUT=

        if test "$mytty" = "not a tty" && ! [ -z ${TTY+x} ]; then
            printf -- "%s\n" "Attaching tty"
            exec 0<"$TTY"
            exec 1>"$TTY"
        else
            exec <`pen-tm-tty`
        fi
        shift
    }
    ;;

    -t)
        {
        ( exec <`pen-tm-tty` ) &>/dev/null # I should really check this output
        HAS_STDIN=
        HAS_STDOUT=
        shift
    }
    ;;

    -tout) { # tty out, not stdout
        HAS_STDOUT=; shift
    }
    ;;

    -fout) { # Force stdout (echo hi | pen-tm -sout nw fzf)
        HAS_STDOUT=y; shift
    }
    ;;

    -tt) {

        invocation="$(printf -- "%s\n" "$invocation" | sed 's/ -tt\b//')"

        exec script -q --return -c "$invocation" /dev/null

        exit 0
    }
    ;;

    -u)
        UNBUFFER_IN=y
        UNBUFFER_OUT=y
        shift
    ;;

    -uin) # cat | unbuffer -p [tm nw]
        UNBUFFER_IN=y; shift
    ;;

    -uout) # unbuffer [tm nw]
        UNBUFFER_OUT=y; shift
    ;;

    -b)
        BUFFER_IN=y;
        BUFFER_OUT=y;
        shift
    ;;

    -bin)
        BUFFER_IN=y; shift
    ;;

    -bout)
        BUFFER_OUT=y; shift
    ;;

    -s)
        SPONGE_IN=y
        SPONGE_OUT=y
        shift
    ;;

    -sin) { # Maybe use -i|-stdin instead
        SPONGE_IN=y; shift
    }
    ;;

    -I|-i|-stdin|-soak|-soak-input) {

        IFS= read -rd '' input < <(cat /dev/stdin)

        exec < <(chomp <<< "$input")
        shift
    }
    ;;

    -sout)
        SPONGE_OUT=y; shift
    ;;

    -vipe)
        VIPE_MODE_FORCE=y; shift
    ;;

    -v)
        set -xv
        shift
    ;;

    *)
        break
    ;;
esac; done

debug_mode_enabled() {
    case "$-" in
        *x*) true;;
        *v*) true;;
        *) false;;
    esac
}

exec 4>&2

second_last_arg() {
    if [ "$#" -gt "1" ]; then
        n=$(($#-1))
        eval ARG=\${$n}
        pl "$ARG"
    fi
}

last_arg() {
    if [ "$#" -gt "0" ]; then
        n=$(($#-0))
        eval ARG=\${$n}
        pl "$ARG"
    fi
}

session_list() {
    tmux list-sessions | sed '/^[^:]\+:/ s/^\([^:]\+\).*/\1/'
    return 0
}

copy-line() {
    y="$1"

    if printf -- "%s\n" "$y" | grep -q -P '^[-+]'; then
        offset="$y"
        y=
    fi
    : ${y:="$(tmux display -p "#{cursor_y}")"}

    if test -n "$offset"; then
        y="$(( y + offset ))"
    fi

    : ${y:="$(tmux display -p "#{cursor_y}")"}

    pen-tm -f cat | sed -n "$((y + 1))p" | {
        if test "$DO_FROM" = "y"; then
            : ${x:="$(tmux display -p "#{cursor_x}")"}
            cut -c $(( x + 1 ))-
        else
            clean-repl
        fi
    } | pen-xc -i -n
}

f="$1"
shift

case "$f" in
    config|fzf-config) {
        exec 2>&4

        selection="$(tm-list-config | pen-mnm | pen-str uniq | pen-soak | mfz -p)"

        ! [ -n "$selection" ] && exit 0

        open -e "$selection"

        exit 0

        ge "$selection"
    }
    ;;

    findrun) {
        exec 2>&4
        selection="$(list-executables | mfz)"
        wp="$(which "$selection")"

        pen-tm run "$wp"

    }
    ;;

    em-click-bg) {
        set -m
        pen-tm em-click &
        disown
    }
    ;;

    em-click) { # easymotion click

        cap_file="$(pen-tm cap | pen-tf txt; sleep 0.5)"
        if [ -s "$cap_file" ]; then
            pen-tm -te nw -n em-click "pen-v -c 'set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q!' \"$cap_file\""

            x="$(cat /tmp/em-click.txt | cut -d ' ' -f 2)"
            y="$(cat /tmp/em-click.txt | cut -d ' ' -f 1)"

            if [ -n "$x" ] && [ -n "$y" ]; then
                x=$((x - 1))
                y=$((y - 1))

                sleep 1

                pen-tm click-wrap $x $y
            fi
        fi

        exit 0
    }
    ;;

    regex-find-coord) {

        last_arg="${@: -1}"
        regex="$last_arg"

        set -- "${@:1:$(($#-1))}"

        : ${LITERAL:="n"}
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -t) {
                TARGET="$2"
                shift
                shift
            }
            ;;

            -l) {
                LITERAL=y
                shift
            }
            ;;

            *) break;
        esac; done

        : ${TARGET:="$TMUX_PANE"}

        if test "$LITERAL" = "y"; then
            pen-tm cap-pane "$@" -clean -nohist | pcre-pos.pl "$regex"
        else
            pen-tm cap-pane "$@" -clean -nohist | exact-pos.pl "$regex"
        fi

        exit 0
    }
    ;;

    regex-click) {

        ALL=n # click everything that matches
        LITERAL=n
        x_offset=0
        y_offset=0
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -t) {
                TARGET="$2"
                shift
                shift
            }
            ;;

            -a) {
                ALL=y
                shift
            }
            ;;

            -l) {
                export LITERAL=y # for "pen-tm regex-find-coord"
                shift
            }
            ;;

            -x) {
                x_offset="$2"
                shift
                shift
            }
            ;;

            -y) {
                y_offset="$2"
                shift
                shift
            }
            ;;

            *) break;
        esac; done

        re="$1"
        shift

        results="$(pen-tm regex-find-coord -nohist -t "$TARGET" "$re")"

        if test "$ALL" = "y"; then
            printf -- "%s\n" "$results" | awk1 | while IFS=$'\n' read -r line; do
                printf -- "%s\n" "$line" | xargs pen-tm click -t "$TARGET"
                sleep 0.1
            done
        else
            printf -- "%s\n" "$results" | head -n 1 | xargs pen-tm click -t "$TARGET"
        fi

        exit 0
    }
    ;;

    click-wrap) { # start wrapper and then click on it
        swidth="$(tmux display -t "$CALLER_TARGET" -p "#{session_width}")"
        sheight="$(tmux display -t "$CALLER_TARGET" -p "#{session_height}")"
        sheight="$(( sheight + 2 ))"

        tmux \
            new-session -d \
                -x "$swidth" \
                -y "$sheight" \
                -A \
                -s wrap \
                \; \
            respawnp -k \
                -t "wrap:1" \
                "TMUX= tmux attach -t \"$CALLER_TARGET\""

        [ -n "$1" ] && x="$1" && shift
        [ -n "$1" ] && y="$1" && shift

        while tmux has-session -t ":em-click"; do
            sleep 0.1
        done

        pen-tm click -t "wrap:1" "$x" "$y"

        tmux kill-pane -t "wrap:1.0"
    }
    ;;

    ttyrec-auto|recterm|ttystudio-gif|ascl|asciinema-local) {
        swidth="$(tmux display -t "$CALLER_TARGET" -p "#{session_width}")"
        sheight="$(tmux display -t "$CALLER_TARGET" -p "#{session_height}")"
        sheight="$(( sheight + 2 ))"

        caller_slug="$(printf -- "%s" "$CALLER_TARGET" | slugify)"

        tmsessionname="${f}-$caller_slug-$(date-ts)"

        cmd="unset TTY; pen-x -s \"${f}\" -c m -e \"\$\" -s \"TMUX= tmux attach -t $(cmd-nice-posix \"$CALLER_TARGET\":)\" -c m -i"

        TMUX= tmux new-session -d -c "$CWD" -x "$swidth" -y "$sheight" -A -s "$tmsessionname"

        xt -b -E "tmux setenv -t $(cmd-nice-posix "$tmsessionname") WINDOWID $(cmd-nice-posix "\$WINDOWID") \\; respawnp -k -t $(cmd-nice-posix "$tmsessionname:1") $(cmd-nice-posix "$cmd") \\; attach -t $(cmd-nice-posix "$tmsessionname")"
    }
    ;;

    ac|asciinema) {

        swidth="$(tmux display -t "$CALLER_TARGET" -p "#{session_width}")"
        sheight="$(tmux display -t "$CALLER_TARGET" -p "#{session_height}")"
        sheight="$(( sheight + 2 ))"

        caller_slug="$(printf -- "%s" "$CALLER_TARGET" | slugify)"


        cmd="unset TTY; pen-x -s \"asciinema rec\" -c m -e \"Â»\" -s \"TMUX= tmux attach -t $(cmd-nice-posix \"$CALLER_TARGET\":)\" -c m -i"

        tmux new-session -d -c "$CWD" -x "$swidth" -y "$sheight" -A -s "cinema-$caller_slug" \; respawnp -k -t "cinema-$caller_slug:1" "$cmd"

        xt -b tmux attach -t "cinema-$caller_slug"
    }
    ;;

    click|mousedown|mouseup|mouseclick) {
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -t) {
                TMUX_PANE="$2"
                shift
                shift
            }
            ;;

            -x) {
                export EXTENDED_MODE=y
                shift
            }
            ;;

            -r) {
                export RIGHT=y
                shift
            }
            ;;

            *) break;
        esac; done

        [ -n "$1" ] && x="$1" && shift
        [ -n "$1" ] && y="$1" && shift

        : ${TMUX_PANE:="$CALLER_PANE"}

        if test -z "$x"; then
            x="$(tmux display -t "$TMUX_PANE" -p "#{cursor_x}")"
        fi
        if test -z "$y"; then
            y="$(tmux display -t "$TMUX_PANE" -p "#{cursor_y}")"
        fi

        if [ -n "$TMUX_PANE" ] && [ -n "$x" ] && [ -n "$y" ]; then
            case "$f" in
                mousedown) {
                    tmux send-keys -t "$TMUX_PANE" -l "$(xterm-click -d $x $y)"
                }
                ;;

                mouseup) {
                    tmux send-keys -t "$TMUX_PANE" -l "$(xterm-click -u $x $y)"
                }
                ;;

                click|mouseclick) {
                    tmux send-keys -t "$TMUX_PANE" -l "$(xterm-click -d $x $y)"
                    sleep 0.2
                    tmux send-keys -t "$TMUX_PANE" -l "$(xterm-click -u $x $y)"
                }
                ;;

                *)
            esac
        fi
        exit 0
    }
    ;;

    goto-fzf) {
        eval "tmux run -b $(cmd-nice-posix "pen-tm find-window-from-session -no-activate")"
    }
    ;;

    start) {
        attach=n
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -a) {
                attach=y
                shift
                shift
            }
            ;;

            *) break;
        esac; done

        notify-send "Starting emacs"
        unbuffer e -startall
        unbuffer bash -xv e -startall

        if ! pen-tm session-exists localhost; then
            pen-tm ns -np -r -l -d -c "$HOME/notes" -n localhost "$shell"

        fi
        pen-tm attach localhost
    }
    ;;

    target-exists) {
        pen-tm n "$f :: NOT FULLY IMPLEMENTED"

        tmux has-session -t "$1:"
        exit $?
    }
    ;;

    session-exists) {
        sessions="$(session_list)"
        printf -- "%s" "$sessions" | pen-str one-of "$1"
        exit $?
    }
    ;;

    bp-other|bpo) { # breakp -other
        pen-tm n "$f :: Use 'bp -o'"
    }
    ;;

    bp|breakp) {
        while :; do opt="$1"; case "$opt" in
            -s|-save) {
                SAVE=y
                shift

            }
            ;;

            -r|-reserve) {
                RESERVE=y
                shift

            }
            ;;

            -o|-other) { # other panes
                OTHER=y
                shift

            }
            ;;

            -E) { # other panes
                CMD="$2"
                shift
                shift
            }
            ;;

            *) break;

        esac; done

        if test "$OTHER" = "y"; then
            notify-send "$CALLER_PANE"
            win_name="$(tmux display -p "#W")"
            new_window="$(tmux neww -F "#{window_id}" -P "echo originally: $CALLER_PANE | rosie match all.things | less -r")"
            tmux swap-window -s "$CALLER_PANE" -t "$new_window" \; \
                 rename-window -t "$new_window" "$win_name" \; \
                 rename-window -t "$CALLER_PANE" "[broke$CALLER_PANE]" \; \
                 swap-pane -s "${new_window}.0" -t "$CALLER_PANE"

            exit 0

        elif test "$RESERVE" = "y" || test "$SAVE" = "y"; then

            CALLER_PANE="$(tmux display -p "#{pane_id}")"
            window_name="$(tmux display -p "#{window_name}")"

            if printf -- "%s" "$window_name" | grep -q -P '^%'; then
                tmux swap-pane -s "$window_name" -t "$CALLER_PANE" && \
                    tmux kill-pane -t "$window_name"
                tmux select-window -t "CALLER_PANE"
                exit 0
            fi

            new_pane="$(tmux neww -d -F "#{pane_id}" -P "echo | rosie match all.things | less -r; tmux swap-pane -s $(cmd-nice-posix "$new_pane") -t $(cmd-nice-posix "$CALLER_PANE")")"

            if test -z "$CMD"; then
                if test "$#" -gt 0; then
                    CMD="$(cmd "$@")"
                    : ${CMD:="$(cmd "$@")"}
                else
                    CMD="echo placeholder: $new_pane | rosie match all.things | less -r"
                fi
            fi

            tmux swap-pane -s "$new_pane" -t "$CALLER_PANE"
            tmux rename-window -t "$CALLER_PANE" "$new_pane"

            tmux respawn-pane -k -t "$new_pane" "$CMD; tmux swap-pane -s $(cmd-nice-posix "$new_pane") -t $(cmd-nice-posix "$CALLER_PANE")" > /tmp/utehont.txt

            if test "$RESERVE" = "y"; then
                tmux select-window -t "$CALLER_PANE"
            fi

            exit 0

        else
            CALLER_PANE="$(tmux display -p "#{pane_id}")"
            new_window="$(tmux break-pane -F "#{pane_id}" -P -s "$CALLER_PANE")"
            tmux select-window -t "$new_window"
            tmux rename-window -t "$new_window" "[broke$new_window]"
        fi
    }
    ;;

    xc|pen-xc) {
        exec 2>/dev/null
        exec 1>/dev/null
        zsh --no-rcs -c "tmux load-buffer =(unbuffer pen-xc "$@")"
    }
    ;;

    xv) {
        zsh --no-rcs -c "tmux save-buffer - | pen-xc "$@""
    }
    ;;

    ask) {
        :

    }
    ;;

    man) {
        program="$1"
        PROGRAM="$1"; : ${PROGRAM:="runit"}

        tmux command-prompt -p man "splitw \"sh-man %1\""
    }
    ;;

    xp) {
        zsh --no-rcs -c "tmux load-buffer -b myclipboard =(unbuffer pen-xc "$@")"
        tmux paste-buffer -pr -b myclipboard
    }
    ;;

    ep|edit-paste|vp|vipe-paste) {
        zsh --no-rcs -c "tmux load-buffer -b myclipboard =(pen-tm -sout sph \"echo -n '' | vipe\" | cat | chomp)"

        tmux paste-buffer -r -b myclipboard
    }
    ;;

    ta) {
        name=$(last_arg "$@")

        if [ -n "$name" ]; then
            . ~/.shellrc
            tmux attach -t "$name"
        else
            . ~/.shellrc
            tmux attach
        fi
    }
    ;;

    ta-local) {
        ta localhost
        exit 0
    }
    ;;

    shpv|show-pane-variable) {
        pen-shpv "$1"
    }
    ;;

    cursor) {
        tmux display -t "$CALLER_TARGET" -p "#{cursor_x}"
        tmux display -t "$CALLER_TARGET" -p "#{cursor_y}"
    }
    ;;

    shpvs|show-pane-variables) {
        pen-shpvs
    }
    ;;

    pns|pane-status) {

        if test "$(hostname)" = "morgan"; then
            : ${FAST:="y"}
        fi

        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -f) {
                FAST=y
                shift
            }
            ;;

            -nw) {
                makenewpane=nw
                shift
            }
            ;;

            *) break;
        esac; done

        if test -n "$1"; then
            export TMUX_PANE="$1"
        fi

        {
            pen-shpvs -t "$TMUX_PANE"

            pl

            pid="$(tpv -t "$TMUX_PANE" pane_pid)"

            pl "pid: $pid"

            pl

            pl "pwd: $(pwd)"
            echo

            cmd="pstree -lAsp \"$pid\""
            printf -- "%s" "$cmd: "
            eval "$cmd"
            echo

            cmd="pstree -alAsp \"$pid\""
            pl "$cmd"
            eval "$cmd"
            echo

            if ! test "$FAST" = "y"; then
                pl "Open files"
                pstree -lAp "$pid" | \
                    sed 's/\(([0-9]\+)\)/(\n\1\n/g' | \
                    sed -n '/([0-9]\+)/ s/[^0-9]//pg' | \
                    while read pid; do
                        lsof -p $pid 2>/dev/null | sed 's/ \+/ /g' | cut -d ' ' -f9- | sed '1d';
                    done | pen-str uniq | grep -v /lib/
            else
                echo Fast mode enabled. Not showing open files.
            fi

        } | pen-mnm | {
            if is_tty || test "$makenewpane" = "nw"; then
                pen-tm -tout -i -S nw pen-v
            else
                cat
            fi
        }
    }
    ;;

    xta) {
        xt_opt=

        opt="$1" # it might not be opt though. it might be target
        case "$opt" in
            -b|-h) { xt_opt=$opt; shift; } ;;
        esac

        last_arg="${@: -1}"
        name="$last_arg"
        : ${name:="localhost:"}

        if test "$name" = "localhost:"; then
            cd "$NOTES"
            export CWD="$NOTES"
        fi

        if [ -n "$name" ]; then
            xt $xt_opt pen-tm ta "$name"
        else
            tm-attach-localhost
        fi
    }
    ;;

    ts) {
        pen-tm start

        pen-tm ta localhost
    }
    ;;

    nds|nbgs) {
        unset TMUX

        if [ -n "$3" ]; then
            tmux new-session -d -s "$1" -c "$2" "$3"
        elif [ -n "$2" ]; then
            tmux new-session -d -s "$1" -c "$2"
        elif [ -n "$1" ]; then
            tmux new-session -d -s "$1"
        else
            tmux new-session -d
        fi
    }
    ;;

    ns|new-s|new-session) {
        unset TMUX

        HIGHLIGHT=
        HAS_PARENT=y # Default action is to create a subsession (but a subsession in the new-window sense)
        RECURSIVE=n
        ATTACH=n
        SELECT=n
        force_create_session=n
        session_name=
        session_title=
        : ${REPEAT_COMMAND:="n"}
        : ${AUTO_RETRY:="n"}
        PRESS_ANY_KEY_FINISH=y
        REMAIN_ON_EXIT=n
        RETRY_SLEEP=0
        : ${G_AUTOFILES:="y"} # global autofiles
        : ${L_AUTOFILES:="y"} # local autofiles
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -a) { # Attach to the parent session
                ATTACH="y"
                shift
            }
            ;;

            -f) { # if the session name already exists, use this
                force_create_session="y"
                shift
            }
            ;;

            -A) {
                G_AUTOFILES="y"
                L_AUTOFILES="y"
                shift
            }
            ;;

            -w) {
                HIGHLIGHT=warn
                shift
            }
            ;;

            -hlgreen) {
                HIGHLIGHT=green
                shift
            }
            ;;

            -hlblue) {
                HIGHLIGHT=blue
                shift
            }
            ;;

            -hldblue) {
                HIGHLIGHT=dblue
                shift
            }
            ;;

            -hlred) {
                HIGHLIGHT=red
                shift
            }
            ;;

            -paks|-pakstart) {
                PRESS_ANY_KEY_START=y
                shift
            }
            ;;

            -na) {
                G_AUTOFILES=n
                L_AUTOFILES=n
                shift
            }
            ;;

            -s) {
                ATTACH="y"
                SELECT="y"
                shift
            }
            ;;

            -R|-repeat) {
                REPEAT_COMMAND=y
                PRESS_ANY_KEY_FINISH=y
                shift
            }
            ;;

            -A|-autoretry) {
                REPEAT_COMMAND=y
                PRESS_ANY_KEY_FINISH=n
                RETRY_SLEEP=2
                shift
            }
            ;;

            -r|-roe) {
                :
                shift
            }
            ;;

            -l) {
                RECURSIVE="y"
                shift
            }
            ;;

            -d) {
                SELECT="n"
                shift
            }
            ;;

            -np) {
                HAS_PARENT="n"
                shift
            }
            ;;

            -t|-p) { # parent session
                TARGET="$2"
                shift
                shift
            }
            ;;

            -c) {
                dir="$(eval echo -e "$2")" # expand
                dir="$(realpath "$dir")"
                CWD="$dir"
                mkdir -p "$CWD"
                cd "$CWD"
                export CWD

                envstring+="export CWD=\"$CWD\"; "

                shift
                shift
            }
            ;;

            -n) {
                session_name="$2"
                shift
                shift
            }
            ;;

            -T|-title) {
                session_title="$2"
                shift
                shift
            }
            ;;

            *) break;
        esac; done

        CMD="$(cmd-nice-posix "$@")"

        if [ -z "$CWD" ]; then
            : ${CWD:="$(pwd)"}; cd "$CWD"
        fi

        d_bn="$(basename "$CWD")"
        if test "$d_bn" = /; then
            d_bn=rootdir
        fi

        if [ -z "$session_name" ]; then
            if [ $# -gt 0 ]; then
                session_name="${d_bn}/$1"
            else
                session_name="${d_bn}"
            fi
        fi

        session_name="$(p "$session_name" | slugify)"

        if [ -z "$TARGET" ] && test "$HAS_PARENT" = "y"; then
            TARGET="$CALLER_TARGET"

            TARGET="$(tmux display-message -p -t "$TARGET" '#{session_name}')"
        fi

        : "${CURRENT_SESSION_NAME:="$(tmux display-message -p -t "$TARGET" '#{session_name}')"}"
        : "${PARENT_SESSION_NAME:="$CURRENT_SESSION_NAME"}"

        if test "$HAS_PARENT" = "y"; then
            session_name="${PARENT_SESSION_NAME}_${session_name}"
        fi

        : "${session_title:="$session_name"}"

        pen-tm -f session-exists "$session_name" && session_exists=y
        if ! test "$session_exists" = "y" || test "$force_create_session" = "y"; then
            mkdir -p "$CWD"
            displayed_name="$(printf -- "%s" "$session_title" | displayedname)"

            CWD="$CWD" tmux new-session -d -s "$session_name" -c "$CWD" "zsh" \; \
                setenv -t "$session_name" "TM_SESSION_NAME" "$session_name" \; \
                setenv -t "$session_name" "PARENT_SESSION_ID" "$PARENT_SESSION_ID" \; \
                setenv -t "$session_name" "PARENT_SESSION_NAME" "$PARENT_SESSION_NAME" \; \
                setenv -t "$session_name" "PARENT_WINDOW_ID" "$PARENT_WINDOW_ID" \; \
                setenv -t "$session_name" "CWD" "$CWD" \; \
                set -t "$session_name" status-left "[ $displayed_name ]  "

            if test "$HAS_PARENT" = "y"; then
                :
            fi
            export CURRENT_SESSION_NAME="$session_name"
            export PARENT_SESSION_NAME="$session_name"

            if [ -n "$PARENT_SESSION_NAME" ]; then
                PARENT_SESSION_ID="$(tmux display-message -p -t "$session_name:" '#{session_id}')"
            fi
            export PARENT_SESSION_ID

            if test "$RECURSIVE" = "y"; then
                (
                    export TARGET="$session_name"
                    cd "$CWD"

                    test -f ".tmux-pre.sh" && source ".tmux-pre.sh"
                    test -f ".tmux.sh" && source ".tmux.sh"
                )
            fi

            if [ $# -gt 0 ]; then
                tmux respawnp -k -t "$session_name:1.0" "$CMD"
            fi
        fi

        tmux setenv -t "$session_name" "CWD" "$CWD"

        if test "$ATTACH" = "y"; then
            cd "$CWD"

            if test "$HAS_PARENT" = "y"; then
                export HIGHLIGHT
                roe_para="$(test "$REMAIN_ON_EXIT" = "y" && printf -- "%s" "-r")"
                full_id="$(pen-tm -d nw -P $roe_para -d -t "$TARGET" -n "$displayed_name" -c "$CWD" "pen-tm attach $(cmd-nice-posix "$session_name"); sleep 0.1")"

                tmux setenv -t "$session_name:" "PARENT_WINDOW_ID" "$full_id"
            else
                pen-tm attach "$session_name"
            fi

            if test "$SELECT" = "y" && test "$HAS_PARENT" = "y"; then
                tmux selectw -t "$TARGET:$displayed_name"
            fi
        fi

        if test "$HAS_PARENT" = "y"; then
            :
        fi

        exit 0
    }
    ;;

    vt100) {
        session_name="$1"

        export TERM=screen-2color

        if [ -z "$CWD" ]; then
            : ${CWD:="$(pwd)"}; cd "$CWD"
        fi

        pen-tm attach "$session_name" || {
            true
        }
        exit $?
    }
    ;;

    attach) {
        session_name="$1"

        if [ -z "$session_name" ]; then
            session_name=localhost
        fi

        if pen-tm session-exists $session_name; then
            TMUX= tmux attach -t "$session_name:" || {
                true
            }
        elif test "$session_name" = "localhost"; then
            pen-tm ns -r -l -d -c "$HOME/notes" -n localhost "$shell"
            TMUX= tmux attach -t "$session_name:" || {
            true
        }
    else
            printf -- "%s\n" "session: $session_name does not exist"
            pen-pak c
        fi
        exit $?
    }
    ;;

    ssa|source-session-attach) {
        session_name="$1"

        if [ -z "$CWD" ]; then
            : ${CWD:="$(pwd)"}; cd "$CWD"
        fi

        pen-tm attach "$session_name" || {
            true
        }
        exit $?
    }
    ;;

    kp) {
        if [ -n "$CALLER_PANE" ]; then
            tmux kill-pane -t "$CALLER_PANE"
        else
            tmux kill-pane
        fi
    }
    ;;

    editsession) {
        {
            test -f .tmux.sh && echo .tmux.sh
            test -f .tmux-minimal.sh && echo .tmux-minimal.sh
            test -f autofiles.txt && echo autofiles.txt
            test -f $NOTES/programs/tm/autofiles.txt && echo $NOTES/programs/tm/autofiles.txt
        } | pen-str join ' ' | xargs -l1 pen-tm -f -d -te nw -args pen-v
    }
    ;;

    type) {
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -s) {
                delay="$2"
                shift
                shift
            }
            ;;

            *) break;
        esac; done

        printf -- "%s" "$1" |
        while IFS= read -N 1 char; do
            tmux send-keys -l "$char"

            if test -n "$delay"; then
                sleep "$delay"
            fi
        done
    }
    ;;

    typeclip) {
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -u) {
                window_name="$2"
                shift
            }
            ;;

            -j) {
                :

                shift
            }
            ;;

            *) break;
        esac; done

        unbuffer pen-xc | while IFS= read -N 1 char; do
                tmux send-keys -l "$char"

        done
        exit 0

    }
    ;;

    getpane) {
        :

    }
    ;;

    runreturn) { # Am I going to delete this?
        tf_returncode="$(mktemp -t tf_returncodeXXXXXX || echo /dev/null)"
        trap "rm $(cmd-nice-posix "$tf_returncode") 2>/dev/null" 0

        cmd="$1; echo \$? > $tf_returncode"

        tmux neww -t "$CALLER_TARGET" "$cmd"
        printf -- "%s\n" "$message"

    }
    ;;

    nextlayout) {
        tmux next-layout -t "$CALLER_TARGET"
    }
    ;;

    op|option) {
        TMUX_OPTION="$1"
        : ${TMUX_OPTION:="default-shell"}

        OPTION_VALUE="$2"

        if [ -n "$OPTION_VALUE" ]; then
            tmux set -t "$CALLER_TARGET" $TMUX_OPTION "$OPTION_VALUE"
        else
            tpv "$TMUX_OPTION"
        fi
    }
    ;;

    pastekeys) {
        :

    }
    ;;

    editbuffer) {
        bufdata="$(tmux save-buffer -)"
        newdata="$(p -- "%s\n" "$bufdata" | EDITOR=pen-v vipe)"

        tmux delete-buffer
        p -- "%s\n" "$newdata" | tmux load-buffer -
    }
    ;;

    nss) { # new subsession
        :

    }
    ;;

    pwd) { # get working directory of foremost programm running in the current terminal
        :
    }
    ;;

    split|nw|neww|spv|sph|ss|new-window|rs|rsp|sps|smart|cw) {
        BACKGROUNDED=
        SPLIT=
        SMART_SPLIT=

        if { ! test "$HAS_STDIN" = y; } && test "$HAS_STDOUT" = y && ! test "$VIPE_MODE_FORCE" = y; then
            RETURN_ID=y
            BACKGROUNDED="-d"
            DETACHMENT_SENTINEL=n
            HAS_STDIN=
            HAS_STDOUT=
        fi

        if test "$f" = "sps" || test "$f" = "smart"; then
            SMART_SPLIT=y
        elif test "$f" = "ss"; then
            SUB_SESSION=y

        elif test "$f" = "split"; then
            SPLIT=-h
        elif test "$f" = "spv"; then
            SPLIT=-h
        elif test "$f" = "sph"; then
            SPLIT=-v
        fi

        if test "$DETACHMENT_SENTINEL" = "y"; then
            RETURN_CODE=
        else
            RETURN_CODE=0
        fi

        : ${HIGHLIGHT:=""}
        : ${PRESS_ANY_KEY_FINISH:=""}
        PRESS_ANY_KEY_FINISH_KEY=f
        FORWARD_ARGS=n
        CHANGE_SHELL=n
        : ${REPEAT_COMMAND:="n"}
        REMAIN_ON_EXIT=n
        CAT_ON_EXIT=n
        RETRY_SLEEP=0
        NEOVIM=n
        NEOVIM_TMUX=n
        : "${RETURN_ID:="n"}"
        SILENCE=n
        TRAPINT=y # This is so the window doesn't close if you press C-c in less
        while :; do opt="$1"; case "$opt" in
            -n) {
                window_name="$2"
                shift
                shift
            }
            ;;

            -coe) {
                CAT_ON_EXIT=y
                shift
            }
            ;;

            -x) {
                debugging=y
                shift
            }
            ;;

            -sw) {
                switch_to_target=y
                shift
            }
            ;;

            -A|-autoretry) {
                REPEAT_COMMAND=y
                PRESS_ANY_KEY_FINISH=n
                RETRY_SLEEP=2
                shift
            }
            ;;

            -quiet|-noerror)
                PRESS_ANY_KEY_ON_ERROR=n; shift
            ;;

            -noquiet|-error)
                PRESS_ANY_KEY_ON_ERROR=y; shift
            ;;

            -s) {
                session_name="$2"
                shift
                shift
            }
            ;;

            -w) {
                HIGHLIGHT=warn
                shift
            }
            ;;

            -nv|-nvc) { # wrap in a neovim
                NEOVIM=y
                shift
            }
            ;;

            -nvt) { # wrap in a neovim
                NEOVIM_TMUX=y
                shift
            }
            ;;

            -hlred) {
                HIGHLIGHT=red
                shift
            }
            ;;

            -hlgreen) {
                HIGHLIGHT=green
                shift
            }
            ;;

            -hlblue) {
                HIGHLIGHT=blue
                shift
            }
            ;;

            -hldblue) {
                HIGHLIGHT=dblue
                shift
            }
            ;;

            -notrapint) {
                TRAPINT=n
                shift
            }
            ;;

            -trapint) {
                TRAPINT=y
                shift
            }
            ;;

            -safe) {
                SAFE=y
                shift
            }
            ;;

            -P) {
                RETURN_ID=y
                shift
            }
            ;;

            -t) {
                TARGET="$2"
                shift
                shift
            }
            ;;

            -d|-bg) {
                BACKGROUNDED="-d"
                shift
            }
            ;;

            -R|-repeat) {
                REPEAT_COMMAND=y
                PRESS_ANY_KEY_FINISH=y
                shift
            }
            ;;

            -r|-roe) {
                REPEAT_COMMAND=y
                PRESS_ANY_KEY_FINISH=y
                shift
            }
            ;;

            -sh) {
                CHANGE_SHELL=y
                DEFAULT_SHELL="$2"
                shift
                shift
            }
            ;;

            -silence|-q) {
                SILENCE=y
                shift
            }
            ;;

            -bash) {
                CHANGE_SHELL=y
                DEFAULT_SHELL="bash"
                shift
            }
            ;;

            -p|-size-percent) {
                split_size="$2"
                shift
                shift
            }
            ;;

            -zsh) {
                CHANGE_SHELL=y
                DEFAULT_SHELL="zsh"
                shift
            }
            ;;

            -paks|-pakstart) {
                PRESS_ANY_KEY_START=y
                shift
            }
            ;;

            -pak|-pakf|-pakfinish) {
                PRESS_ANY_KEY_FINISH=y
                shift
            }
            ;;

            -pakfk|-pakfinishkey) {
                PRESS_ANY_KEY_FINISH=y
                PRESS_ANY_KEY_FINISH_KEY="$2"
                shift
                shift
            }
            ;;

            -nopak|-nopakf|-nopakfinish) { # Used in conjunction with -R and less
                PRESS_ANY_KEY_FINISH=n
                shift
            }
            ;;

            -c) {
                dir="$(p "$2" | pen-bs "()'")"
                dir="$(eval echo -e "$dir")" # expand
                CWD="$dir"
                cd "$CWD"
                export CWD

                envstring+="export CWD=\"$CWD\"; "

                shift
                shift
            }
            ;;

            -tpwd) {
                if [ -z "$TARGET" ]; then
                    if [ -n "$TMUX_PANE" ]; then
                        TARGET="$TMUX_PANE"
                    else
                        TARGET="$CALLER_TARGET"
                    fi
                fi

                dir="$(tpwd -t "$TARGET")"
                dir="$(eval echo -e "$dir")"
                printf -- "%s\n" "$dir" > /tmp/tm.txt
                pen-tm n "$dir"
                export CWD

                shift
            }
            ;;

            -sin) {
                HAS_STDIN=y;
            }
            ;;

            -rsi|-icmd|-cin|-xargs|-iargs) {

                STDIN_IS_COMMAND=y
                HAS_STDIN=n
                shift
            }
            ;;

            -v) { # we want to be able to run pen-v (vim)
                SPLIT=-h
                shift
            }
            ;;

            -h|h) {
                SPLIT=-v
                shift
            }
            ;;

            -fa|-forward-args|-fargs|-args) {
                FORWARD_ARGS=y
                shift
            }
            ;;

            *) break;
        esac; done

        if [ -z "$TARGET" ]; then
            if [ -n "$CURRENT_SESSION_NAME" ]; then
                TARGET="$CURRENT_SESSION_NAME"
            else
                TARGET="$CALLER_TARGET"
            fi
        fi

        if test "$CHANGE_SHELL" = "y"; then
            PREVIOUS_SHELL="$(pen-tm op default-shell)"
            DEFAULT_SHELL="$(which "$DEFAULT_SHELL")"
            pen-tm op default-shell "$DEFAULT_SHELL"
        fi

        : ${window_name:="new-window"}

        sentinal_string="tm_sentinal_${RANDOM}_$$"

        if test "$debugging" = "y"; then
            cmd_pre+="set -xv; "
        fi

        case "$DEFAULT_SHELL" in
            bash) {
                cmd_pre+="set -o pipefail; "
                :
            }
            ;;

            zsh) {
                cmd_pre+="setopt pipefail; "
                :
            }
            ;;

            *)
        esac

        cmd_pre="$cmd_pre stty stop undef; stty start undef; "
        test "$PRESS_ANY_KEY_START" = "y" && cmd_pre="$cmd_pre pen-pak s; "

        if test "$HAS_STDIN" = "y"; then
            ff0="$(pen-ux mkfifo tm_stdin)"

            if test "$BUFFER_IN" = "y"; then
                cmd_pre="$cmd_pre buffer | "
            fi

            if test "$SPONGE_IN" = "y"; then
                cmd_pre="$cmd_pre pen-sponge | "
            fi

            if test "$UNBUFFER_IN" = "y"; then
                cmd_pre="$cmd_pre unbuffer -p "
            fi

            cmd_pre="$cmd_pre cat \"$ff0\" | "
        fi

        if test "$SILENCE" = "y"; then
            cmd_post="$cmd_post >/dev/null "
        fi

        if test "$HAS_STDOUT" = "y"; then
            ff1="$(pen-ux mkfifo tm_stdout)"

            if test "$UNBUFFER_OUT" = "y"; then
                cmd_pre="$cmd_pre unbuffer"
            fi

            if test "$BUFFER_OUT" = "y"; then
                cmd_post="$cmd_post | buffer"
            fi

            if test "$SPONGE_OUT" = "y"; then
                cmd_post="$cmd_post | pen-sponge"
            fi

            cmd_post="$cmd_post >$ff1"
        fi

        tf_rc="$(0</dev/null pen-tf rc txt || echo /dev/null)"

        cmd_post="$cmd_post; ret=\$?; printf -- \"%s\" \$ret > \"$tf_rc\""

        if test "$PRESS_ANY_KEY_FINISH" = "y"; then
            cmd_post="$cmd_post; pen-pak $PRESS_ANY_KEY_FINISH_KEY"
        elif test "$PRESS_ANY_KEY_ON_ERROR" = "y"; then
            cmd_post="$cmd_post; test \$ret -ne 0 && ( p 'exit code '\$ret' => '; pen-pak )"
        fi

        if test "$REPEAT_COMMAND" = "y"; then
            cmd_pre="while :; do $cmd_pre"
            if [ "$RETRY_SLEEP" -gt "0" ]; then
                cmd_post="$cmd_post; sleep $RETRY_SLEEP; done"
            else
                cmd_post="$cmd_post; done"
            fi
        fi

        if test "$CAT_ON_EXIT" = "y"; then
            tf_capture="$(pen-tf capture || echo /dev/null)"
            trap "rm \"$tf_capture\" 2>/dev/null" 0
        fi

        if test "$DETACHMENT_SENTINEL" = "y"; then
            if test "$CAT_ON_EXIT" = "y"; then
                cmd_post="$cmd_post; pen-tm -te -d capture - > \"$tf_capture\""
            fi

            if ! test "$SUB_SESSION" = "y"; then
                cmd_post="$cmd_post; tmux wait-for -S $sentinal_string; sleep 1;"
            fi
        fi

        if test "$STDIN_IS_COMMAND" = "y"; then
            CMD="$(cmd "$@")"
            cmd="$CMD"

            IFS= read -rd '' arguments < <(cat /dev/stdin)

            cmd+=" $arguments"

        else
            if ! test "$FORWARD_ARGS" = "y"; then
                if test -n "$2"; then
                    cmd="$2"
                    dir="$1"
                elif test -n "$1"; then
                    cmd="$1"
                fi
            else
                CMD="$(cmd "$@")"
                cmd="$CMD"
            fi
        fi

        if test "$NEOVIM" = "y"; then
            cmd="nv -E -term $(cmd-nice-posix "$cmd")"
        elif test "$NEOVIM_TMUX" = "y"; then
            cmd="nvt -E $(cmd-nice-posix "$cmd")"
        fi

        if [ -z "$dir" ]; then
            : ${CWD:="$(pwd)"}
            dir="$CWD"
        fi

        if [ -z "$cmd" ]; then
            cmd="$shell"
        fi

        if test "$switch_to_target" = "y"; then
            pen-tm sel "$TARGET"
        fi

        envstring+="export CWD=\"$dir\"; "

        tf_exports="$(printf -- "%s\n" "$envstring" | pen-tf sh || echo /dev/null)"

        printf -- "%s\n" "export TTY=\$(tty);" >> "$tf_exports"

        fullcmd="test -f \"$tf_exports\" && . $tf_exports; ${cmd_pre} $cmd ${cmd_post}"
        printf -- "%s\n" "$fullcmd" | pen-ds -s tm

        if test "$SMART_SPLIT" = "y"; then
            if pen-test-should-hsplit; then
                SPLIT=-v
            else
                SPLIT=-h
            fi
        fi

        ID_FORMAT="#{session_id}:#{window_id}.#{pane_id}"

        if test "$SAFE" = "y"; then
            fullcmd="bash -c $(cmd-nice-posix "$fullcmd") || pen-pak -m 'bad syntax'"
        fi

        if test "$TRAPINT" = "y"; then
            fullcmd="trap '' INT; $fullcmd"
        fi

        fullcmd="$(printf -- "%s" "$fullcmd" | pen-esc '`')"

        printf -- "%s\n" "$fullcmd" | pen-ds -s tm_fullcmd

        if printf -- "%s\n" "$TARGET" | grep -q -P '^[a-z_]+$'; then
            TARGET="$TARGET:"
        fi

        if test "$f" = "cw"; then
            :
            pen-tm breakp -s -E "$fullcmd"
        elif test "$f" = "rs" || test "$f" = "rsp"; then
            full_id="$(tmux respawnp -k -t "$TARGET" -t "$TARGET" "export TMUX=; $fullcmd")"
        elif test "$SUB_SESSION" = "y"; then

            unset TMUX

            if test -n "$session_name"; then
                session_name_opt=" -s $session_name "
            fi

            full_id="$(tmux new -P -F "$ID_FORMAT" -d $session_name_opt -n "$window_name" -c "$dir" "$fullcmd")"

            if ! test -n "$BACKGROUNDED"; then
                tmux attach -t "$full_id"
            fi

        elif test -n "$SPLIT"; then
            if test -n "$split_size"; then
                split_size="-p $split_size"
            fi
            full_id="$(tmux split -F "$ID_FORMAT" -P -t "$TARGET" $SPLIT $split_size $BACKGROUNDED -c "$dir" "$fullcmd")"
        else
            # Work around a window-renaming bad feature
            if printf -- "%s\n" "$TARGET" | grep -q -P '^[0-9]+$'; then
                # I probably indended the target to be a session name
                TARGET="${TARGET}:"
            fi

            full_id="$(tmux neww -P -F "$ID_FORMAT" -t "$TARGET" $PARENT_SESSION $BACKGROUNDED -n "$window_name" -c "$dir" "$fullcmd")"
            case "$HIGHLIGHT" in
                warn) {
                    tmux setw -t "$full_id" window-status-format '#[fg=colour244]#I #[fg=colour227,bg=colour161]#W'
                }
                ;;

                red) {
                    tmux setw -t "$full_id" window-status-format '#[fg=colour244]#I #[fg=colour160,bg=colour235]#W'
                }
                ;;

                blue) {
                    tmux setw -t "$full_id" window-status-format '#[fg=colour244]#I #[fg=colour026,bg=colour235]#W'
                }
                ;;

                dblue) {
                    tmux setw -t "$full_id" window-status-format '#[fg=colour244]#I #[fg=colour024,bg=colour233]#W'
                }
                ;;

                green) {
                    tmux setw -t "$full_id" window-status-format '#[fg=colour244]#I #[fg=colour040,bg=colour235]#W'
                }
                ;;

                *)
            esac

        fi

        if test "$CHANGE_SHELL" = "y"; then
            pen-tm op default-shell "$PREVIOUS_SHELL"
        fi

        if test "$RETURN_ID" = "y"; then
            echo "$full_id"
        fi

        if test "$HAS_STDIN" = "y"; then
            cat > "$ff0"
            rm "$ff0" 2>/dev/null
        fi

        if test "$HAS_STDOUT" = "y"; then
            cat "$ff1" &
        fi

        if test "$DETACHMENT_SENTINEL" = "y"; then
            if ! test "$SUB_SESSION" = "y"; then
                tmux wait-for "$sentinal_string"
                # Killing the pane speeds up the user experience
                tmux kill-pane -t "$full_id"
            fi
        fi

        if test "$CAT_ON_EXIT" = "y"; then
            cat "$tf_capture"
        fi

        sleep 0.1

        if [ -z "$RETURN_CODE" ]; then
            RETURN_CODE="$(cat "$tf_rc")"
            if [ -z "$RETURN_CODE" ]; then
                RETURN_CODE=99
            fi
        fi

        trap "rm \"$tf_rc\" 2>/dev/null" 0

        if [ -e "$ff1" ]; then
            rm "$ff1" 2>/dev/null
        fi
        exit "$RETURN_CODE"
    }
    ;;

    run) { # Delete this?
        tmux neww -t "$CALLER_TARGET" "$1"
    }
    ;;

    refresh) {
        tmux source-file ~/.tmux.conf
        tmux refresh-client ~/.tmux.conf
    }
    ;;

    run-debug-windows) {

        pen-tm n "$f :: NOT IMPLEMENTED"

    }
    ;;

    nxw|nxtw) {
        tmux next-window -t "$CALLER_TARGET"
    }
    ;;

    prw|prvw) {
        tmux previous-window -t "$CALLER_TARGET"
    }
    ;;

    new-script) {
        fn="$SCRIPTS/new-script-${RANDOM}.sh"

        touch "$fn"
        chmod a+x "$fn"

        printf -- "%s\n" "#!/bin/bash" >> "$fn"
        printf -- "%s\n" "export TTY" >> "$fn"
        printf -- "%s\n" >> "$fn"

        pen-tm -S -te nw "vim \"$fn\""
    }
    ;;

    cap) {
        pen-tm -te -d capture -clean -wrap -noabort -
    }
    ;;

    cap-pane|capp) {
        pen-tm -te -d capture "$@" -clean -
    }
    ;;

    scrape|scrape-filter) {
        cap="$(pen-tm cap)"
        printf -- "%s" "$cap" | pen-tm -f -S -tout nw -noerror "pen-f filter-with-fzf"
    }
    ;;

    scrape-things-fast) {
        cap="$(pen-tm cap)"
        printf -- "%s" "$cap" | filter-things.sh | pen-tm -f -S -tout nw -noerror "mfz -m | pen-xc -i"
    }
    ;;

    scrape-things) {
        cap="$(pen-tm cap)"
        printf -- "%s" "$cap" | pen-tm -f -S -tout nw -noerror "pen-f filter-things"
    }
    ;;

    lasturl) {

        urls="$(pen-tm cap | xurls | chomp)"
        if test "$(printf -- "%s" "$urls" | wc -l)" -gt 0; then
            printf -- "%s" "$urls" | pen-tm fzf -1 | pen-xc -i -n
        else
            unbuffer pen-xc -i -n "$urls"
        fi
    }
    ;;

    scrapep) {
        cap="$(pen-tm capp)"
        printf -- "%s" "$cap" | pen-tm -f -S -tout nw -noerror "pen-f filter-with-fzf"
    }
    ;;

    search) {
        pen-tm -f -te -d capture -t localhost -clean -editor "JUSTIFY_LEFT=y orve" -wrap
    }
    ;;

    visor) {
        pen-tm -f -te -d capture -t localhost -clean -editor "JUSTIFY_LEFT=y orspe -ic generate-glossary-buttons-over-buffer-force-on" -wrap
    }
    ;;

    avy) {
        pen-tm -f -te -d capture -clean -editor "e -fi avy-goto-char" -wrap
    }
    ;;

    wrap) {
        pen-tm -f -te -d capture -clean -editor "e" -wrap
    }
    ;;

    em|easymotion) {
        cap_file="$(pen-tm cap | pen-tf txt; sleep 0.5)"
        if [ -s "$cap_file" ]; then
            pen-tm -te -d nw -n easymotion "pen-v -c 'set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2)' \"$cap_file\""
        fi

        exit 0
    }
    ;;

    kill-other) {
        tmux kill-pane -t :.+
        set-tmux-hostname
    }
    ;;

    nv-wrap) {
        pen-tm -te -d capture -clean -wrap -nv
    }
    ;;

    capture-stdout) { # captures the terminal and puts it to stdout
        pen-tm -te -d capture -clean -
    }
    ;;

    capture-stdout-wrap) { # captures the terminal including panes and puts it to stdout
        pen-tm -te -d capture -clean -wrap -
    }
    ;;

    capture) {
        mkdir -p ~/programs/tmux/capture

        x="$(tmux display -p "#{cursor_x}")"
        y="$(tmux display -p "#{cursor_y}")"

        ANSI=n
        ANSI=y
        DO_SEND_KEYS=n
        SCROLLBACK=-32768
        CAPTURE_OPTIONS=" -J "
        EDITOR="pen-v"
        STDOUT= # no editor. no value relies on is_tty
        NOABORT=n
        while [ $# -gt 0 ]; do case $1 in
            -a|-ansi) {

                ANSI=y

                shift
            }
            ;;

            -c|-clean) {

                ANSI=n

                shift
            }
            ;;

            -tty) {
                STDOUT=n

                shift
            }
            ;;

            -|-stdout) {
                STDOUT=y

                shift
            }
            ;;

            -f|-filter) {
                ns disabled $1 because ambiguous

                exit 0

                shift
            }
            ;;

            -p) {
                PREVIEW=y

                shift
            }
            ;;

            -noabort) {
                NOABORT=y

                shift
            }
            ;;

            -t) {
                CALLER_TARGET="$2"
                CALLER_PANE="$2"
                shift
                shift
            }
            ;;

            -nosendkeys) {
                DO_SEND_KEYS=n

                shift
            }
            ;;

            -sendkeys) {
                DO_SEND_KEYS=y

                shift
            }
            ;;

            -s|-session) {

                shift
            }
            ;;

            -ts|-top-session) {

                shift
            }
            ;;

            --pc|--preview-cmd) {
                PREVIEW=y
                PREVIEW_CMD=y

                shift
            }
            ;;

            -e|-emacs) {
                EDITOR="e c"

                shift
            }
            ;;

            -editor) {
                EDITOR="$2"

                shift
                shift
            }
            ;;

            -nv) {
                EDITOR="nv -c 'nmap q :q!<CR>'"

                shift
            }
            ;;

            -v|-vim) {
                EDITOR="pen-v"

                shift
            }
            ;;

            -session) {

                shift
            }
            ;;

            -wrap) { # The tmux wrapper session
                WRAP=y
                SCROLLBACK=0

                shift
            }
            ;;

            -nohist|-nohistory) {
                SCROLLBACK="0"

                shift
            }
            ;;

            -history) {
                SCROLLBACK=-32768

                shift
            }
            ;;

            -b|-bottom) { # start emacs/vim at bottom of buffer

                shift
            }
            ;;

            *) break;
        esac; done

        if test "$ANSI" = "y"; then
            CAPTURE_OPTIONS+=" -e "
            EDITOR=ansivim
        fi

        unset TMUX

        tf_tmcapture="$(pen-tf tmcapture txt || echo /dev/null)"
        bn="$(basename "$tf_tmcapture")"
        mkdir -p $HOME/programs/tmux/capture
        np="$HOME/programs/tmux/capture/$bn"
        mv "$tf_tmcapture" "$np"

        if test "$WRAP" = "y"; then
            swidth="$(tmux display -t "$CALLER_TARGET" -p "#{session_width}")"
            sheight="$(tmux display -t "$CALLER_TARGET" -p "#{session_height}")"
            sheight="$(( sheight + 2 ))"

            tmux new-session -d -x "$swidth" -y "$sheight" -A -s wrap \; respawnp -k -t "wrap:1" "TMUX= tmux attach -t \"$CALLER_TARGET\""

            c=0

            grepstring="$CALLER_TARGET"
            if test "$grepstring" = "localhost"; then
                grepstring="$(hostname | pen-str cap)"
            fi

            while ! grep -q "\[ $grepstring \]" "$np"; do
                ((++c))
                if test "$NOABORT" = "n" && [ "$c" -eq 10 ]; then
                    notify-send "Leaving capture \"[ $grepstring ]\" because it took too long."
                    break
                fi

                tmux capture-pane -t "wrap:1.0" \; save-buffer "$np"
            done

            tmux kill-pane -t "wrap:1.0"
        else
            eval "tmux capture-pane -t "$CALLER_PANE" $CAPTURE_OPTIONS -S $SCROLLBACK"

            tmux save-buffer "$np"
        fi

        cat "$np" | clean-term-capture | pen-sponge "$np"

        if test "$STDOUT" = ""; then
            if is_tty; then
                STDOUT=n
            fi
        fi

        if test "$STDOUT" = "y"; then
            cat "$np"
        else
            full_lines="$(wc -l "$np" | awk '{print $1}')"
            final_x=$x
            final_y="$(( y + 1 ))"
            pane_id="$(tmux neww -t "$CALLER_TARGET" -F "#{pane_id}" -P -n capture "stty stop undef; stty start undef; TTY= GOTO_COLUMN=$final_x GOTO_LINE=$final_y $EDITOR \"$np\"")"

            if test $DO_SEND_KEYS = "pen-f" && test "$EDITOR" = "pen-v"; then
                tmux send-keys -t "$pane_id" "C-k"
            else
                :
            fi

        fi
    }
    ;;

    fr|free-resources) {
        pen-tm n "$f :: NOT IMPLEMENTED"

    }
    ;;

    jump) { # easymotion jump
        pen-tm n "$f :: NOT IMPLEMENTED"

    }
    ;;

    tnf|new-file) {
        tf="$(u pen-tf new txt)"

        pen-tm -S -te nw "vim \"$tf\""

    }
    ;;

    saykeyunbound) {
        key="$1"; : ${key:="key"}
        message="$2" # "new key M-T"

        exec &>/dev/null

        if [ -n "$message" ]; then
            pen-tm n "$key has been unbound. $message"
        else
            pen-tm n "$key has been unbound"
        fi
    }
    ;;

    edit-x-clipboard) {
        pen-tm -f -te nw xce
    }
    ;;

    calc) {
        pen-tm n "$f :: TODO: Further implemention" &>/dev/null

        win calculator

    }
    ;;

    wa|wolfram-alpha) {
        pen-tm n "$f :: NOT IMPLEMENTED"
        exit 1

    }
    ;;

    scrapep|scrape-paths) {
        pen-tm n "$f :: NOT IMPLEMENTED"
        exit 1

    }
    ;;

    r|ranger) {
        dir="$(p "$dir" | q)"

        : ${CWD:="$(pwd)"}; cd "$CWD"

        export CWD

        pen-tm -f -d -t nw -c "$CWD" -fargs ranger "$@"
    }
    ;;

    shortcuts) {
        paths="$(tm-list-shortcuts)"

        if [ -n "$paths" ]; then

            pl "$paths" | pen-str uniq | pen-tm -f -i -S nw -noerror "mfz -nm" | {
                dn="$(cat|umn)"
                dnq="$(printf -- "%s" "$dn" | q)"
                exec <`pen-tm-tty`

                if [ -n "$dn" ]; then
                    if ! [ -e "$dn" ]; then
                        pen-tm -f -d -te dv "$dn :: No longer exists"
                    fi
                    export CWD="$dn"

                    pen-tm -f -te -d nw -c "$dn" "zcd $(cmd-nice-posix "$dnq")"
                fi
                exit 0
            }
            exit $?
        else
            ns "No dirs exist anymore." &>/dev/null
            pen-tm -f -te -d dir
        fi
        exit 0
    }
    ;;

    urls) {
        pen-tm capp | xurls | tail -n 1 | pen-xc -i -n
        pen-tm capp | xurls | pen-soak | pen-sps pen-v
    }
    ;;

    urls-file) {
        pen-tm -f -d -t nw tm-urls
    }
    ;;

    d|dir|directories) {
        pen-tm -f -d -t nw tm-dir
    }
    ;;

    s|src|source-files) {
        pen-tm -f -d -t nw tm-src
    }
    ;;

    tools) {
        pen-tm -f -d -t nw tm-tools
    }
    ;;

    rsp|respawn-pane) {
        pen-tm n "$f :: NEEDS WORK"

        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -t) {
                TARGET="$2"

                shift
                shift
            }
            ;;

            -w) {
                SET_REMAIN_ON_EXIT=y

                shift
            }
            ;;

            -f) {
                FORCE=y

                shift
            }
            ;;

            *) break;
        esac; done

        CMD="$(cmd "$@")"

        if test "$FORCE" = "y"; then
            OPS+=" -f "
        fi

        if [ -n "$CMD" ]; then
            tmux respawn-pane -t "$CALLER_TARGET" $OPS -k "$CMD"
        else
            tmux respawn-pane -t "$CALLER_TARGET" $OPS -k
        fi

    }
    ;;

    project-edit) {
        pen-tm n "$f :: NOT IMPLEMENTED. Use projectile"
        exit 1

    }
    ;;

    copy-session-name) {
        pen-tm n "$f :: NOT IMPLEMENTED. Need objects to represent sessions. name vs id"
        exit 1

    }
    ;;

    n|notify) {
        message="$1"

        ns "$message" &>/dev/null

    }
    ;;

    lw|last-window) {
        last_window_num="$(tmux list-windows -t "$CALLER_TARGET" | tail -n 1 | sed 's/\([0-9]\+\):.*/\1/')"
        if [ -n "$last_window_num" ]; then
            tmux select-window -t ":${last_window_num}"
        fi
    }
    ;;

    dv|display-var) {
        CMD="$(cmd-nice-posix "$@")"
        : ${CMD:="$(cmd-nice-posix "$@")"}

        if test "$HAS_STDIN" = "y"; then
            message="$(cat)"
        else
            message="$CMD"
        fi
        message="$(p "$message" | q)"

        pen-tm -t -d sph -pak "printf -- "%s\n" $message"
    }
    ;;

    copy-pane-command) {
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -nc|-nocontect) {
                NOCONTEXT=y
                shift
            }
            ;;

            *) break;
        esac; done

        if test "$NOCONTEXT" = "y"; then
            pen-shpv "pane_start_command" | {
                sed -e 's/^.*start undef;\s\+//' -e 's/\s*;\s*ret=.*$//'
            } | pen-xc -i -n
        else
            pen-shpv "pane_start_command" | pen-xc -i -n
        fi
    }
    ;;

    tput-search) { # This was the urwid program that allowed me to select different search engines
        keys="$(cat)"

        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

    efs|edit-fsnotes) {
        pen-tm n "$f :: NOT IMPLEMENTED"
        :
    }
    ;;

    gfs|get-fsnotes|fsnotes) {
        pen-tm n "$f :: NOT IMPLEMENTED"
        :
    }
    ;;

    show-vim-mappings) {
        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

    find-path-from-notes) {
        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

    find-text-in-terminals) {
        pen-tm n "$f :: NOT IMPLEMENTED"

    }
    ;;

    search-command-copy) {
        pen-tm n "$f :: NOT IMPLEMENTED"

    }
    ;;

    ncmd|notes-commands) { # scrape out all the commands and run them. Use search for this

        pen-tm -tt -d dv "$f :: NOT IMPLEMENTED"

    }
    ;;

    ntv|tvs) {
        pen-tm tv -vs "$@"
    }
    ;;

    tv) { # just have a look at what's inside as the program is running
        SILENCE=n
        REMEMBER_IT=n
        EDITOR=pen-v
        window_mode=sps
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -q) {
                SILENCE=y
                shift
            }
            ;;

            -nv|-vs|-s) {
                EDITOR=vs
                shift
            }
            ;;

            -rec) {
                REMEMBER_IT=y
                shift
            }
            ;;

            -m) {
                window_mode="$2"
                shift
                shift
            }
            ;;

            -spv|-nw|-sph) {
                window_mode="$(p "$opt" | pen-mcut -d - -f2)"
                shift
            }
            ;;

            *) break;
        esac; done

        if test "$SILENCE" = "y"; then
            exec &>/dev/null
        fi

        IFS= read -rd '' input < <(cat /dev/stdin)

        ft="$1"

        if [ -n "$ft" ]; then

            tf_ft="$(pen-tf ft "$ft" || echo /dev/null)"

            printf -- "%s" "$input" > "$tf_ft"
            pen-tm -d -tout spv -noerror "$EDITOR -nad $tf_ft"
        else
            printf -- "%s" "$input" | pen-tm -S -tout $window_mode -noerror "$EDITOR -nad"
        fi
        printf -- "%s" "$input"
    }
    ;;

    cat|catp|cat-pane) {
        opts=

        FROM_START=n
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -a) {
                FROM_START=y
                shift
            }
            ;;

            -na) {
                FROM_START=n
                shift
            }
            ;;

            *) break;
        esac; done

        target="$1"

        if test "$FROM_START" = "y"; then
            opts+=" -p -S - "
        fi

        {
            if [ -n "$target" ]; then
                tmux capture-pane $opts -t "$target" \; save-buffer -
            else
                tmux capture-pane $opts \; save-buffer -
            fi
        } | {
            erase-trailing-whitespace |
            sed -e :a -e '/^\n*$/{$d;N;};/\n$/ba'
        }

        exit 0
    }
    ;;

    pp|pipe-pane) {
        FROM_START=n
        CONTINUE=y
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -a) {
                FROM_START=y
                shift
            }
            ;;

            -C|-continue) {
                CONTINUE=y
                shift
            }
            ;;

            -nc|-nocontinue) {
                CONTINUE=n
                shift
            }
            ;;

            *) break;
        esac; done

        ff=/tmp/$$.data; trap "rm -f $ff" EXIT; mknod $ff p

        target="$1"

        if test "$FROM_START" = "y"; then
            tmux capture-pane -e -p -S - -t "$target"
        fi

        if test "$CONTINUE" = "y"; then
            if [ -n "$target" ]; then
                tmux pipe-pane -t "$target" "cat > $ff"
            else
                tmux pipe-pane "cat > $ff"
            fi

            cat "$ff"
        fi

        exit 0
    }
    ;;

    get-session) {
        printf -- "%s" "$CALLER_TARGET"
        exit 0
    }
    ;;

    get-pane) {
        printf -- "%s" "$CALLER_PANE" | ns

        exit 0
    }
    ;;

    pc|pipec|pipe-to-command|sf|select-filter|split-and-pipe|spp) {
        filter="$(set -o pipefail; cat $PENELD/config/filters.sh | pen-tm mfz | remove-hash-comments.sh)"
        ret="$?"

        if ! test "$ret" -eq "130"; then
            pen-tm -d spv "unbuffer pen-tm pp -a '$CALLER_PANE' | $filter; pen-pak -m \"source pane closed\""
            tmux select-pane -t "$CALLER_PANE"
        fi

        exit 0
    }
    ;;

    wrto|pipe|pv) { # greedy stream (sub-linewise) through command in tmux split

        : "${pipe_cmd:="$1"}"
        : "${pipe_cmd:="$f"}"

        case "$pipe_cmd" in
            pipe) { pipe_cmd="cat"; } ;;

            *)
        esac

        stdinfd=/proc/$$/fd/0
        stdoutfd=/proc/$$/fd/1

        0</dev/null pen-tm sps -w "cat \"$stdinfd\" | $pipe_cmd"
    }
    ;;

    vipe|eipe) { # edit and continue
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -wintype) {
                wintype="$2"
                shift
                shift
            }
            ;;

            *) break;
        esac; done
        : "${wintype:="sps"}"

        pipe_cmd="$1"; : ${pipe_cmd:="$f"}

        # This shouldn't be necessary
        if stdin_exists; then
            pen-tm -sout -vipe "$wintype" "$pipe_cmd" | cat
        else
            echo -n | pen-tm -sout -vipe "$wintype" "$pipe_cmd" | cat
        fi
    }
    ;;

    yn) {
        exec 0</dev/null
        CMD="$(cmd "$@")"
        : ${CMD:="$(cmd "$@")"}
        pen-tm -te sps -bash "yn $CMD"
        exit "$?"
    }
    ;;

    ised) {
        stdinfd=/proc/$$/fd/0
        stdoutfd=/proc/$$/fd/1

        0</dev/null pen-tm -te sps -w "ised $stdinfd $stdoutfd" | cat
    }
    ;;

    icat) {
        stdinfd=/proc/$$/fd/0
        stdoutfd=/proc/$$/fd/1

        0</dev/null pen-tm -te sps -nv -w "cat $stdinfd | tee $stdoutfd 1>&2" | cat
    }
    ;;

    sk|stream-keys|send-keys) {

        while true; do
            line=''

            while IFS= read -r -N 1 ch; do
                case "$ch" in
                    $'\04') got_eot=1   ;&
                    $'\n')  break       ;;
                    *)      line="$line$ch" ;;
                esac
            done

            printf 'line: "%s"\n' "$line"

            if (( got_eot )); then
                break
            fi
        done

        target=
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -t) {
                target="$2"
                shift
                shift
            }
            ;;

            *) break;
        esac; done

        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

    monitor) {
        pen-tm n "$f :: NOT FULLY IMPLEMENTED"

        pen-tm -d nw "htop"
    }
    ;;

    select-subsession) {
        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

    subsession) {
        pen-tm n "$f :: NOT IMPLEMENTED"
        paths="$(find . -maxdepth 1 -type d)"
        if [ -n "$paths" ]; then
            paths="$(pl "$paths" | pen-str uniq | pen-tm -f -i spv -noerror "mfz" | umn)"
            if [ -n "$paths" ]; then

                bn="$(basename "$paths")"

                pen-tm ns -r -l -s -c "$bn"
            fi
        fi
    }
    ;;

    kass|kill-subsessions) {
        pen-tm n "$f :: NOT IMPLEMENTED. Use data structure"
    }
    ;;

    kss|kill-subsession) {
        pen-tm n "$f :: NOT IMPLEMENTED. Use data structure"
    }
    ;;

    bh|base-here) {
        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

    bl|base-localhost) {
        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

    os|omni-session) {
        pen-tm n "$f :: NOT IMPLEMENTED. Can't remember what this did"
    }
    ;;

    lkb|list-keybindings) {
        tmux list-keys | pen-tm -S -tout nw -n tmux-key-bindings "pen-v -c \"set ft=tmux\""
    }
    ;;

    cr|compile-run) {
        pen-tm n "$f :: NOT IMPLEMENTED"

    }
    ;;

    open-list-of-files-in-emacs) {

        pen-tm -S -tout spv -noerror sp
    }
    ;;

    tp|open-list-of-files-in-windows) {

        for var in "$@"
        do
            exec < <(printf -- "%s\n" "$var")
        done

        input="$(cat)"

        exec 0<&-

        printf -- "%s" "$input" | awk 1 | umn | while read -r line; do
            if [ -e "$line" ]; then

                tm-open-file-blue "$line"
            else

                line="$(p "$line" | scrape-files.sh | qne)" # use scrape-files because it could be an org-mode link
                bn="$(basename "$line" | slugify)"

                pen-tm -te -d nw -n "$bn" "open -e $line"
            fi
        done
    }
    ;;

    vim-open-buffer-list-in-windows) {

        input="$(cat)"
        exec 0<&-

        printf -- "%s" "$input" | sed '1d' | sed 's/^[^"]\+\(.*"\)[^"]\+$/\1/' | uq -ftln | umn | awk 1 | while read -r line; do
            if [ -e "$line" ]; then

                tm-open-file-green "$line"
            fi
        done
    }
    ;;

    ngrams) {
        tmux capture-pane -t "$CALLER_TARGET" \; show-buffer\; delete-buffer

    }
    ;;

    gram) {
        tmux capture-pane -t "$CALLER_TARGET" \; show-buffer\; delete-buffer

        pattern="$1"
        : ${pattern:="Â»"}

        y="$(tmux display -p "#{cursor_y}")"

        pen-tm -f cat | sed -n "$((y + 1))p" | {
            clean-repl
        } | pen-xc -i -n
    }
    ;;

    remote-xclip) {
        pen-tm n "$f :: NOT IMPLEMENTED"

        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -r) {

                exit 0
                shift
            }
            ;;

            *) break;
        esac; done

    }
    ;;

    mru|most-recently-used) {
        exec 2>&4

        list-mru -m

        exit 0

    }
    ;;

    unimplemented) {
        p1="$1"; : ${p1:="This command is"}
        pen-tm n "$p1 :: NOT IMPLEMENTED"
    }
    ;;

    git) {
        pen-tm n "$p1 :: NOT IMPLEMENTED"
        pl "git status for everything below"
        pl "I could open a hydra here or I could use lots of different ranger bindings"
        pen-pak
    }
    ;;

    gist) {
        pen-tm n "$p1 :: NOT IMPLEMENTED"
        pl "git status for everything below"
        pl "Use a command from the git hydra"

        pl "Remotes"
        git remote -v | pen-f urls

        pen-pak
    }
    ;;

    copy-pane-name) {

        format_string="#{session_name}:#{window_name}.#{pane_index}"

        pane_name="$(tmux display-message -p "$format_string")"
        tmux display-message "copied pane name: $format_string"

        printf -- "%s\n" "$pane_name" | pen-xc -n
    }
    ;;

    copy-pane-id) {

        format_string="#{session_id}:#{window_id}.#{pane_id}"

        pane_name="$(tmux display-message -p "$format_string")"
        tmux display-message "copied pane id: $format_string"

        p "$pane_name" | pen-xc
    }
    ;;

    lock) {
        tmux lock-session -t localhost:
    }
    ;;

    move-to-start) {
        tmux set base-index 1 \; move-window -r \; move-window -t 0
    }
    ;;

    move-to-end) {
        tmux set base-index 1 \; move-window -r \; move-window -t :
    }
    ;;

    command-history) {
        pen-tm sel "localhost:historyÂ»" && pen-tm rsp -f -t "localhost:historyÂ»"
    }
    ;;

    recent-isues) {
        pen-tm sel "localhost:recent-issuesÂ»"
        tmux respawn-pane -k -t "localhost:recent-issuesÂ»"
    }
    ;;

    sel|select) {

        target="$1"
        orig_target="$target"
        target="$(printf -- "%s" "$target" | sed 's/\.\([^%0-9]\)/\*\1/')"

        set -o pipefail
        tmux select-window -t "$target" 2>/dev/null || tmux select-pane -t "$target" 2>/dev/null || {
            re_target="$(p "$orig_target" | sed 's/\(\.[^0-9]\)/\\\1/g' | sed 's/\*/\.*/g')"
            tm-lsp.sh | grep -P "$re_target\t" | head -n 1 | sed 's/.*\t//' | xargs -l tmux select-window -t
        } || exit 1

        PARENT_PANE_ID="$(tmux show-env -t "$target" PARENT_WINDOW_ID | sed 's/.*=//')"
        if [ -n "$PARENT_PANE_ID" ]; then
            pen-tm sel "$PARENT_PANE_ID"
        fi

        exit $?

        target_session="${target%:*}"
        target_windowpane="${target##*:}"
        target_window="${target_windowpane%.*}"
        target_pane="${target_windowpane##*.}"

        pl "session: $target_session"
        pl "window: $target_window"
        pl "windowpane: $target_windowpane"
        pl "pane: $target_pane"

        exit 0
    }
    ;;

    copy-previous-line) {
        copy-line -1
    }
    ;;

    yank-line|copy-current-line) {
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -f|-from) {
                DO_FROM=y
                shift
            }
            ;;

            *) break;
        esac; done

        export DO_FROM

        copy-line "$1"
    }
    ;;

    get-last-output) {
        pattern="$1"
        : ${pattern:="Â»"}

        pen-tm -f capture-stdout | remove-trailing-blank-lines | sed '/^$/d' | tac | sed -n -e 1d -e "0,/$pattern/p" | tac | sed 1d
    }
    ;;

    edit-file) {
        paths="$(find . -maxdepth 1 -type pen-f | sed 's/^..//')"
        if [ -n "$paths" ]; then
            paths="$(pl "$paths" | pen-str uniq | pen-tm -f -i spv -noerror "mfz -p" | umn)"
            pl "$paths" | awk1 | while IFS=$'\n' read -r line; do
                if test -n "$line"; then
                    pen-tm tp "$line"
                fi
            done

        fi
        :
    }
    ;;

    find-window-from-session) {

        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -no-activate) { # This option allowed me to go to a window without triggering less to become vim.
                no_activate=y
                shift
            }
            ;;

            -no-split) { # This option allowed me to go to a window without triggering less to become vim.
                no_split=y
                shift
            }
            ;;

            *) break;
        esac; done

        fzfcmd="tm-lsp.sh \"${CALLER_TARGET}\" | his -i -r -f white '\.org' | his -i -r -f purple directories | his -i -r -f blue links | his -i -b red -f yellow '\(problems\)' | his -i -r -f orange '\(setup\|scripts\)' | his -i -r -f green commands | his -i -r -f yellow notes | his -i -f blue localhost | his -i -f red '\.[0-9]\+' | his -i -f purple : | mfz -A -nm | strip-ansi"
        if test "$no_split" = "y"; then
            result="$(eval "$fzfcmd")"
        else
            result="$(pen-tm -f -S spv -noerror "$fzfcmd")"
        fi

        if [ -n "$result" ]; then
            full_pane_id="$(p "$result" | sed 's/.*\t//')"

            pen-tm sel "$full_pane_id"
        fi

    }
    ;;

    select-current) {
        lastwin="$(tmux list-windows -t localhost_current | sed -n '$s/^\([0-9]\+\).*/\1/p')"
        pen-tm sel "localhost_current:$lastwin"
        exit 0
    }
    ;;

    open-dirs) {
        selections="$(pen-tm -s -fout spv -noerror "pen-f find-no-git -d | mfz")"
        if [ -n "$selections" ]; then
            printf -- "%s\n" "$selections" | \
            while read -r line; do
                if [ -e "$line" ]; then
                    line="$(p "$line" | qne)"
                    bn="$(basename "$line")"
                    pen-tm -te -d nw -noerror -n "$bn" "open -e $line"
                fi
            done
        fi
    }
    ;;

    open-files) {
        selections="$(pen-tm -s -fout spv -noerror "pen-f f | mfz")"
        if [ -n "$selections" ]; then
            printf -- "%s\n" "$selections" | \
            while read -r line; do
                if [ -e "$line" ]; then
                    line="$(p "$line" | qne)"
                    bn="$(basename "$line")"
                    pen-tm -te -d nw -noerror -n "$bn" "open -e $line"
                fi
            done
        fi
    }
    ;;

    mfz|fzf) {
        pen-tm -S -sout sps -args -noerror "$f" "$@" | cat
        exit $?
    }
    ;;

    less) {
        pen-tm -S -tout spv -noerror tless
        exit $?
    }
    ;;

    filter) {
        IFS= read -rd '' input < <(cat /dev/stdin)

        export HAS_STDOUT
        sout="$(set -o pipefail; printf -- "%s" "$input" | pen-tm spv -noerror "pen-f filter-with-fzf" | cat)"
        ret="$?"

        if test "$ret" -eq 0; then
            {
                if [ -n "$sout" ]; then
                    printf -- "%s" "$sout"
                else
                    printf -- "%s" "$input"
                fi
            } | {
                if test "$HAS_STDOUT" = "y"; then
                    cat
                else
                    pen-tv
                fi
            }
        fi

        exit "$ret"
    }
    ;;

    tw|w) { slug="$(echo "$@" | tr -d '\n' | slugify | cut -c -10)"; pen-tm -d nw -n "$slug" -fa "$@"; } ;;
    h) { pen-tm -d sph -d -fa "$@"; } ;;
    pen-v) { pen-tm -d spv -d -fa "$@"; } ;;

    template) {
        :
    }
    ;;

    *) {
        pen-tm n "$f :: NOT IMPLEMENTED"
    }
    ;;

esac

exit 0
