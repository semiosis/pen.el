#!/bin/bash
export TTY

# exec 2>/dev/null

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -fn) {
        runfn="$2"
        shift
        shift
    }
    ;;

    *) break;
esac; done

colorize() { lolcat -f; }
makebluebg() { printf -- "%s" "[44m"; sed -u "s=\(.\)\(\[38\)=\1[44m\1\2=g"; }
fontify() { smbraille; }

if test -n "$runfn"; then
    "$runfn" "$@"
    exit "$?"
fi

rainbow=y
bluebg=y
while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -b) {
        big=y
        shift
    }
    ;;

    -bgb) {
        bluebg=y
        # writing backgrounded spaces is effectively clearing
        # so we don't need to clear completely
        fastclear=y
        shift
    }
    ;;

    -nobgb) {
        bluebg=
        shift
    }
    ;;

    -fastclear) {
        fastclear=y
        shift
    }
    ;;

    -rb) {
        rainbow=y
        shift
    }
    ;;

    -norb) {
        rainbow=
        shift
    }
    ;;

    *) break;
esac; done

# ( hs "$(basename "$0")" "$@" "#" "<==" "$(ps -o comm= $PPID)" 0</dev/null ) &>/dev/null

# 314 seems to be the number to make lolcat wheel around modulo
# for i in $(seq 1 314); do echo "$message"; done | lolcat -f

tput civis
message="$@"
: "${message:="Â» Loading Â»Â»Â»Â»Â»Â»Â»Â»Â»"}"

# colourwheel="$(for i in $(seq 1 314); do echo "$message"; done | lolcat -f)"
# colourwheel="$(for i in $(seq 1 314); do echo "$message" | sed "s/.....\$/...../"; done | lolcat -f)"

# Caching scripts:
# Firstly the variables I want must be included as such.
# script='for i in $(seq 1 314); do pattern="$(echo -n . | rps "$(( i % 10 ))")"; echo "$message" | sed "s/$pattern\$/$pattern/"; done | lolcat -f'
# script='for i in $(seq 1 314); do pattern="$(echo -n . | rps "$(( i % 10 ))")"; replacement="$(printf -- "%s" "$pattern" | sed "s=\.= =g")"; echo "$message" | sed "s/$pattern\$/$replacement/"; done | lolcat -f'
# script='for i in $(seq 1 314); do pattern="$(echo -n . | rps "$(( i % 10 ))")"; replacement="$(printf -- "%s" "$pattern" | sed "s=\.= =g")"; echo "$message" | sed "s/^$pattern/$replacement/"; done | lolcat -f'
# script='for i in $(seq 314 -1 1); do pattern="$(echo -n . | rps "$(( i % 10 ))")"; replacement="$(printf -- "%s" "$pattern" | sed "s=\.= =g")"; echo "$message" | sed "s/^$pattern/$replacement/"; done | lolcat -f'

IFS= read -r -d '' script <<'HEREDOC'
for i in $(seq 314 -1 1); do
    pattern="$(echo -n . | rps "$(( i % 10 ))")";
    replacement="$(printf -- "%s" "$pattern" | sed "s=\.= =g")";
    echo "$message" | sed "s/$pattern\$/$replacement/" | ( if test "$big" = y; then spinner -fn fontify; else cat; fi; );
done |
    ( if test "$rainbow" = y; then spinner -fn colorize; else cat; fi; ) |
    ( if test "$bluebg" = y; then spinner -fn makebluebg; else cat; fi; )
HEREDOC
script="$(printf -- "%s" "$script" | sed -z "s/\n */ /g")"

# cmd ocif bash -c "bluebg=\"$bluebg\"; rainbow=\"$rainbow\"; big=\"$big\"; message=\"$message\"; $script"
# exit
colourwheel="$(ocif bash -c "bluebg=\"$bluebg\"; rainbow=\"$rainbow\"; big=\"$big\"; message=\"$message\"; $script")"

# printf -- "%s\n" "$colourwheel" | tv

trap func_trap INT
func_trap() {
    tput cnorm
    endr -INT $$ &>/dev/null
    kill -9 "$$"
}

# trap "trap - SIGTERM && echo quitting && kill -- -$$" SIGINT SIGTERM EXIT

clear

if test "$fastclear" = "y"; then
    clear_sequence="[H"
else
    clear_sequence="[H[J"
fi

stdin_exists() {
    {
    ! [ -t 0 ] && \
    ! test "$(readlink /proc/$$/fd/0)" = /dev/null  && \
    ! test "$(readlink /proc/$$/fd/0)" = "$(readlink /proc/$$/fd/1)"
    # stdin may be redirected to the tty, but  will continue to say false (due to a bash bug)
    # So test to make sure 0 does not point to 1
    } &>/dev/null
}

(
# This subshell responds to the INT propagated from parent script
trap func_exit INT; func_exit() { exit; }

# This works:
trap func_makesmall USR1; func_makesmall() {
    echo hi | tv; big=; colourwheel="$(ocif bash -c "bluebg=\"$bluebg\"; rainbow=\"$rainbow\"; big=\"$big\"; message=\"$message\"; $script")"; run;
}

run() {
if test "$big" = "y"; then
    while :; do
        trap func_exit INT; func_exit() { exit 1; }

        printf -- "%s\n" "$colourwheel" | while IFS= read line; do
            trap func_exit INT; func_exit() { exit 1; }

            read line2
            printf -- "%s" "$clear_sequence"
            printf -- "%s\n" "$line"
            printf -- "%s" "$line2"
            # echo
            sleep 0.1
        done || exit 1
    done || exit 1
else
    while :; do
        trap func_exit INT; func_exit() { exit 1; }

        printf -- "%s\n" "$colourwheel" | while IFS= read line; do
            trap func_exit INT; func_exit() { exit 1; }

            printf -- "%s" "$clear_sequence"
            printf -- "%s" "$line"
            # echo
            sleep 0.1
        done || exit 1
    done || exit 1
fi
}

run

) &
jobid="$!"

# invisible `read -n1 char`
read_char() {
    stty -icanon -echo
    char="$(dd bs=1 count=1 2>/dev/null)"
    stty icanon echo
}

pid="$$"
while read_char; do
    case "$char" in
        t) {
            # window_name="$2"
            echo Changed settings | tv &>/dev/null
            # endr -INT "$jobid" 2>/dev/null
            # spinner -nobgb -norb &
        }
        ;;

        s) {
            # window_name="$2"
            # echo Not quite stopped
            endr -INT "$jobid" 2>/dev/null
            # spinner -nobgb -norb &
        }
        ;;

        m) {
            # window_name="$2"
            # echo Not quite stopped
            endr -np -INT "$jobid" 2>/dev/null
            kill -USR1 "$jobid" 2>/dev/null
            # spinner -nobgb -norb &
        }
        ;;

        *) {
            endr -INT "$pid" 2>/dev/null
            tput cnorm

            break;
        }
        ;;
    esac
done

endr -INT $$ 2>/dev/null
wait
tput cnorm
exit
