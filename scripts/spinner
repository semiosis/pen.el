#!/bin/bash
export TTY

# exec 2>/dev/null

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -fn) {
        runfn="$2"
        shift
        shift
    }
    ;;

    *) break;
esac; done

colorize() { lolcat -f; }
makebluebg() { printf -- "%s" "[44m"; sed -u "s=\(.\)\(\[38\)=\1[44m\1\2=g"; }
fontify() { smbraille; }

if test -n "$runfn"; then
    "$runfn" "$@"
    exit "$?"
fi

rainbow=y
bluebg=y
while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -b) {
        big=y
        shift
    }
    ;;

    -bgb) {
        bluebg=y
        # writing backgrounded spaces is effectively clearing
        # so we don't need to clear completely
        fastclear=y
        shift
    }
    ;;

    -nobgb) {
        bluebg=
        shift
    }
    ;;

    -fastclear) {
        fastclear=y
        shift
    }
    ;;

    -rb) {
        rainbow=y
        shift
    }
    ;;

    -norb) {
        rainbow=
        shift
    }
    ;;

    *) break;
esac; done

# ( hs "$(basename "$0")" "$@" "#" "<==" "$(ps -o comm= $PPID)" 0</dev/null ) &>/dev/null

# 314 seems to be the number to make lolcat wheel around modulo
# for i in $(seq 1 314); do echo "$message"; done | lolcat -f

tput civis
message="$@"
: "${message:="Â» Loading Â»Â»Â»Â»Â»Â»Â»Â»Â»"}"

IFS= read -r -d '' script <<'HEREDOC'
for i in $(seq 314 -1 1); do
    pattern="$(echo -n . | rps "$(( i % 10 ))")";
    replacement="$(printf -- "%s" "$pattern" | sed "s=\.= =g")";
    echo "$message" | sed "s/$pattern\$/$replacement/" | ( if test "$big" = y; then spinner -fn fontify; else cat; fi; );
done |
    ( if test "$rainbow" = y; then spinner -fn colorize; else cat; fi; ) |
    ( if test "$bluebg" = y; then spinner -fn makebluebg; else cat; fi; )
HEREDOC
script="$(printf -- "%s" "$script" | sed -z "s/\n */ /g")"

colourwheel="$(ocif bash -c "bluebg=\"$bluebg\"; rainbow=\"$rainbow\"; big=\"$big\"; message=\"$message\"; $script")"

trap func_trap INT
func_trap() {
    tput cnorm
    endr -INT $$ &>/dev/null
    kill -9 "$$"
}

# trap "trap - SIGTERM && echo quitting && kill -- -$$" SIGINT SIGTERM EXIT

clear

if test "$fastclear" = "y"; then
    clear_sequence="[H"
else
    clear_sequence="[H[J"
fi

stdin_exists() {
    {
    ! [ -t 0 ] && \
    ! test "$(readlink /proc/$$/fd/0)" = /dev/null  && \
    ! test "$(readlink /proc/$$/fd/0)" = "$(readlink /proc/$$/fd/1)"
    # stdin may be redirected to the tty, but  will continue to say false (due to a bash bug)
    # So test to make sure 0 does not point to 1
    } &>/dev/null
}

awk 1 <<HEREDOC > /dev/shm/spinnervars.txt
bluebg="$bluebg"
rainbow="$rainbow"
big="$big"
message="$message"
HEREDOC

run() {
    if test "$big" = y; then
        run_big
    else
        run_small
    fi
}

run_big() {
    while :; do
        trap exit INT

        printf -- "%s\n" "$colourwheel" | while IFS= read line; do
            trap exit INT

            read line2

            # sadly, it's not possible to change the tmux popup border after it has been made, AFAIK
            # firstcol="$(echo "line2" | sed -n 's/[^;]*;5;\([0-9]\+\)m.*/\1/p;q;')"
            # tmux set popup-border-style 'bg=default,fg=colour012'

            printf -- "%s" "$clear_sequence"
            printf -- "%s\n" "$line"
            printf -- "%s" "$line2"
            sleep 0.1
        done || exit 1
    done || return 1
}

run_small() {
    while :; do
        trap exit INT

        printf -- "%s\n" "$colourwheel" | while IFS= read line; do
            trap exit INT

            printf -- "%s" "$clear_sequence"
            printf -- "%s" "$line"
            echo Small
            # echo
            sleep 0.1
        done || exit 1
    done || return 1
}

# Main subprocess
(
    # This subshell responds to the INT propagated from parent script to
    # prevent orphaning of background child processes
    trap exit INT

    # This works:
    trap func_rerun USR1; func_rerun() {
        vars="$(cat /dev/shm/spinnervars.txt | tr -s '\n' ';')"
        colourwheel="$(ocif bash -c "$vars $script")"
        eval "$vars"
        run
    }

    run
) &
jobid="$!"

# invisible `read -n1 char`
read_char() {
    stty -icanon -echo
    char="$(dd bs=1 count=1 2>/dev/null)"
    stty icanon echo
}

reload_job() {
    # The 'Main subprocess' is not quit, but its children are
    # Before the 'Main subprocess' discovers its child processes have ended, trigger it to start a new job
    # This is really dodgy. At least one process must survive or it will die
    # These commands need to happen at the same time...
    endr -np -INT "$jobid" 2>/dev/null
    kill -USR1 "$jobid" 2>/dev/null
}

changevar() {
    varname="$1"
    val="$2"

    test -n "$varname" || exit 1

    cat /dev/shm/spinnervars.txt | sed "/^${varname}=\"/s/\".*\"/\"$val\"/" | soak | tee /dev/shm/spinnervars.txt &>/dev/null
}

pid="$$"
while read_char; do
    case "$char" in
        k) {
            endr -INT "$jobid" 2>/dev/null
            printf -- "%s" "$clear_sequence"
            echo loop stopped
        }
        ;;

        G) { changevar bluebg ""; reload_job; } ;;
        g) { changevar bluebg "y"; reload_job; } ;;
        B) { changevar big ""; reload_job; } ;;
        b) { changevar big "y"; reload_job; } ;;
        R) { changevar rainbow ""; reload_job; } ;;
        r) { changevar rainbow "y"; reload_job; } ;;

        *) {
            endr -INT "$pid" 2>/dev/null
            tput cnorm

            break;
        }
        ;;
    esac
done

endr -INT $$ 2>/dev/null
wait
tput cnorm
exit
