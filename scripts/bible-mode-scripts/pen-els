#!/bin/bash
export TTY

# This script runs a standalone vanilla emacs to run code

# . $SCRIPTS/lib/hs

sn="$(basename -- "$0")"

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -sn) {
        sn="$2"
        shift
        shift
    }
    ;;

    -tcp) {
        use_tcp=y
        shift
    }
    ;;

    *) break;
esac; done

case "$sn" in
    canonicalise-bible-book-title|canonicalise-bible-book-title-els) {
        fun_name=bible-canonicalise-ref
    }
    ;;

    list-bible-book-titles-els) {
        fun_name=list-bible-book-titles-lines
    }
    ;;

    get-haystacks-and-findstrs-from-rosie-grep-sexp-els) {
        fun_name=get-haystacks-and-findstrs-from-rosie-grep-sexp
    };;

    pen-els) {
        fun_name="$1"
        shift
    }
    ;;

    *) {
        fun_name="$sn"
    }
    ;;
esac

. $SCRIPTS/lib/stdin_exists

fun_name="$(p "$fun_name" | sed 's/^els-//')"

if stdin_exists; then
    input_fp="$(cat | tf -X input txt)"
else
    input_fp="$(0</dev/null tf -X input txt)"
    if test "$#" -gt 0; then
        printf -- "%s" "$1" > "$input_fp"
        shift
    fi
fi

output_fp="$(0</dev/null tf -X output txt)"

# By default the stdin is the first arg to the emacs function?
# Yes. And the stdin can be large because the first parameter
# will be passed in as a file path.

# OK, therefore, the arguments go:
# - fun_name input_fp output_fp [&rest]

if test "$use_tcp" = "y"; then
    # - Maybe I should implement this inside the pen-e command
    # - This needs to use q-cip
    pen-e -E-tcp-echo "(sqrt 5)"
else
    pen.els "$fun_name" "$input_fp" "$output_fp" "$@" 2>/dev/null
fi

ret="$?"

# Do I remove the temp files?
# I think I should.
{
printf -- "%s" "$(cat "$output_fp")"
# rm -f "$input_fp"
# rm -f "$output_fp"
}

exit "$ret"
