#!/bin/bash
export TTY

# ( hs "$(basename "$0")" "$@" "#" "<==" "$(ps -o comm= $PPID)" 0</dev/null ) &>/dev/null

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -m) {
        module="$2"
        shift
        shift
    }
    ;;

    -pp) {
        pretty=y
        shift
    }
    ;;

    *) break;
esac; done

: "${module:="NASB"}"

# scrape-bible-references | 

stdin_exists() {
    {
    ! [ -t 0 ] && \
    ! test "$(readlink /proc/$$/fd/0)" = /dev/null  && \
    ! test "$(readlink /proc/$$/fd/0)" = "$(readlink /proc/$$/fd/1)"
    # stdin may be redirected to the tty, but  will continue to say false (due to a bash bug)
    # So test to make sure 0 does not point to 1
    } &>/dev/null
}

if ! stdin_exists; then
    if test "$#" -eq 1 && test -f "$1"; then
        exec < <(cat "$1")
    elif test "$#" -gt 0; then
        CMD="$(cmd "$@")"
        exec < <(printf -- "%s\n" "$CMD")
    else
        echo "bible-show-verses: No input" | hls red 1>&2
        exit "$#"
    fi
fi

raw="$(s join ";" | xargs "diatheke" "-b" "$module" "-o" "w" "-f" "plain" "-k")"
mod="$(printf -- "%s\n" "$raw" | sed -n '$p')"
raw="$(printf -- "%s\n" "$raw" | sed '$d')"

is_tty() { [ -t 1 ] && ! test "$TERM" = "dumb"; }

: "${COLS:="50"}"

unset COLUMNS
if test "$pretty" = "y"; then
    if is_tty; then
        eval `resize`
        LINES=$(tput lines)
        COLUMNS=$(tput cols)

        if test "$COLUMNS" -lt "$COLS"; then
            COLS="$COLUMNS"
        fi
    fi
fi

{
    printf -- "%s\n" "$raw"
} |
    sed -z 's/\([0-9]:\) *\n/\1 /g' | sed 's/^\s*//' | {
    if test "$pretty" = "y"; then
        awk1 | while IFS=$'\n' read -r line; do
        (
            exec 0</dev/null
            printf -- "%s\n" "$line" | sed 's/: .*//' | udl
            printf -- "%s\n" "$line" | sed 's/.*: //' | fold -w "$COLS" -s
            echo
        )
        done
    else
        cat
    fi
    echo "$mod"
} | pavs
