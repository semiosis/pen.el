#!/bin/bash

# Pen
# Version 4.0, bash

# echo "shutdown computer" | penf -u pf-nlsh/2 "Windows 95" {}

# Invocations:
# - pen/penx
# - penf
# - ii
# - lg/lgx/looking-glass
# - cosm/paracosm
# - nlsh
# - apo/apostrophe

# On the host: for Pen
# ufs $MYGIT/semiosis/yas-snippets $HOME/.pen/host/snippets
# ufs $HOME/learn-functions $HOME/.pen/documents/learn-functions

pen_version=4.0

sn="$(basename "$0")"
bn="$sn"
rp="$(realpath "$bn")"

if ! which "$sn" &>/dev/null; then
    dn="$(dirname "$(realpath "$0")")"
    export PATH="$PATH:$dn"
fi

ocif() {
    if which ocif &>/dev/null; then
        command ocif "$@"
    else
	:
    fi
}
dgrey() {
    if which dgrey &>/dev/null; then
        command dgrey "$@"
    else
	:
    fi
}
hls() {
    if which hls &>/dev/null; then
        command hls "$@"
    else
	cat
    fi
}

pen() {
    if which pen &>/dev/null; then
        command pen "$@"
    else
	rp="$(realpath "$0")"
        "$rp" "$@"
    fi
}

cmd() {
    for var in "$@"
    do
        printf "'%s' " "$(printf %s "$var" | sed "s/'/'\\\\''/g")";
    done | sed 's/ $//'
}

cmd-onelineify-safe() {
    if which cmd-onelineify-safe &>/dev/null; then
        command cmd-onelineify-safe "$@"
    else
	cmd "$@"
    fi
}

# cmd-unonelineify-safe is used for an eval. Therefore, I must properly escape contained single quotes
cmd-unonelineify-safe() {
    for var in "$@"
    do
        printf "'%s' " "$(printf %s "$var" | pen-str unonelineify-safe | sed "s/'/'\\\\''/g")";
    done | sed 's/ $//'
}

cmd-nice() {
    # TODO Check for builtin
    # cmd-nice-jq

    for var in "$@"
    do
        printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\*\)"/\1\1\\"/g')";
        # printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\\)\([^"]\|$\)/\1\1\2/g' | sed 's/\(\\*\)"/\1\1\\"/g')";
    done | sed 's/ $//'
}

cmd-nice-with-bs() {
    for var in "$@"
    do
        # printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\*\)"/\1\1\\"/g')";
        printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\\)\([^"]\|$\)/\1\1\2/g' | sed 's/\(\\*\)"/\1\1\\"/g')";
    done | sed 's/ $//'
}

export PS4='+	"$(basename $0)"	${LINENO}	 '

export PEN_INVOCATION="$sn $(cmd "$@")"

# This may speed things up
test -f $PENELD/scripts/utils.sh && . $PENELD/scripts/utils.sh

# This will detach the docker container immediately - but how to disable entirely?
# At least I have saved C-p from being highjacked.
# C-q in emacs is used to enter the next character. This seems like an OK binding.
docker_detach_keys="ctrl-q,ctrl-q"

inside-docker-p() {
    test -f /.dockerenv
}

macos-p() {
    [[ $OSTYPE == 'darwin'* ]]
}

pen_image_tag() {
    if ! inside-docker-p; then
        : "${image:="$(docker image ls | grep "semiosis/pen.el *latest" | cut -d ' ' -f 1)"}"
        : "${image:="$(docker image ls | grep "semiosis/pen *latest" | cut -d ' ' -f 1)"}"
    fi

    : "${image:="semiosis/pen.el"}"

    echo "$image:latest"
    return 0
}

: "${pen_image:="$(pen_image_tag)"}"
: "${pen_image:="semiosis/pen.el:latest"}"

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -cn) {
        PEN_CONTAINER_NAME="$2"
        shift
        shift
    }
    ;;

    -im) {
        pen_image="$2"
        shift
        shift
    }
    ;;

    *) break;
esac; done
: "${PEN_CONTAINER_NAME:="pen"}"

export PEN_CONTAINER_NAME

get_config_dir() {
    if test -n "$PEN_CONTAINER_NAME"; then
        test -d "$HOME/.$PEN_CONTAINER_NAME" && : "${PEN_CONFIG_DIR:="$HOME/.$PEN_CONTAINER_NAME"}"
    else
        test -d "$HOME/.pen" && : "${PEN_CONFIG_DIR:="$HOME/.pen"}"
    fi
    echo "$PEN_CONFIG_DIR"
    return 0
}

# By unsetting, it's undecided.
# But should it be decided by this script?
# Or should it be decided by pen-e?
# Currently, pen-e only considers PEN_USE_GUI
unset PEN_USE_GUI
# The environment may contain $PREFER_GUI

drunning=
docker-running-p() {
    set -o pipefail
    test "$drunning" = y || test -n "$(docker ps --filter "name=${PEN_CONTAINER_NAME}$" | sed 1d)"
    ret="$?"
    if test "$ret" -eq 0; then
        drunning=y
        :
    else
        false
    fi
    # if test "$drunning" = y || docker exec "${PEN_CONTAINER_NAME}" true; then
}

stdin_exists() {
    ! [ -t 0 ] && \
        ! test "$(readlink /proc/$$/fd/0)" = /dev/null && \
        ! test "$(readlink /proc/$$/fd/0)" = "$(readlink /proc/$$/fd/1)"
    # stdin may be redirected to the tty, but `test -t 0` will continue to say false (due to a bash bug)
    # So test to make sure 0 does not point to 1
}

if ! stdin_exists; then
    # If no stdin, make it point to the tty
    exec <&1
else
    mkdir -p ~/.pen
    if test -f ~/.pen/pen_stdin.txt && ! test -w ~/.pen/pen_stdin.txt; then
        (
        set -xv
        sudo chown $USER:$USER ~/.pen/pen_stdin.txt
        )
    fi
    cat > ~/.pen/pen_stdin.txt
    input_captured=y
    exec <&1
fi

# set -xv

test_deps() {
    (
    set -xv
    command -v realpath && \
        command -v basename
    ) 2>&1
}

# port linear coefficient - pen-test encodes as 42
# Add this number to ports.
# May not have bc
# coefficient="$(echo "$PEN_CONTAINER_NAME" | perl -lne 'printf "%03d", ord for split ""' | fold -w1 | paste -sd+ - | bc)"
coefficient="$(bash -c "echo \$(( $(echo "$PEN_CONTAINER_NAME" | perl -lne 'printf "%03d", ord for split ""' | fold -w1 | paste -sd+ -) ))")"
: "${coefficient:="0"}"
TTYD_PORT="$((7681 + $coefficient))"
export TTYD_PORT
KHALA_PORT="$((9837 + $coefficient))"
export KHALA_PORT

ensure_dependencies() {
    ds="$(test_deps)"
    code="$?"
    if ! test "$code" = 0; then
        echo "Please ensure dependencies are installed"

        for s in realpath basename; do
            echo "https://command-not-found.com/$s"
        done

        exit "$?"
    fi
}

ensure_dependencies

yn () {
    if test "$yes" = "y"; then
        return 0
    fi

    if test "$no" = "y"; then
        return 1
    fi

    y_chars="Yy"
    n_chars="Nn"
    while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
        -N|-carefully) {
            allowed_re="^[YN]$"
            shift
        }
        ;;

        -y|-y-chars) {
            y_chars="$2"
            shift
            shift
        }
        ;;

        -n|-n-chars) {
            n_chars="$2"
            shift
            shift
        }
        ;;

        *) break;
    esac; done

    allowed_re="^[${y_chars}/${n_chars}]$"

    message="$@"

    : ${message:="Are you sure?"}

    exec 1>&2

    echo
    message="$(printf -- "%s" "$message")"
    echo -e " $message"
    echo

    allowed_re="$(printf -- "%s" "$allowed_re")"
    allowed_re_color="$(printf -- "%s" "$allowed_re")"

    if test "$YN_DEFAULT" = "y"; then
        echo y
        exit 0
    fi

    if test "$YN_DEFAULT" = "n"; then
        echo n
        exit 1
    fi

    while :; do
        read -p " $allowed_re_color: " -n 1 -r
        echo
        [[ $REPLY =~ $allowed_re ]] && break
    done
    echo

    [[ $REPLY =~ ^[$y_chars]$ ]]
}

{
stty stop undef; stty start undef
} 2>/dev/null

# TODO Add ability to share a file or entire directory with the host -- this would only work for docker run though
# But file sharing could work with the client if I use a hardlink to the ~/.pen/documents directory
# docker run --rm -v "$(pwd):/$(pwd | slugify)" -w "/$(pwd | slugify)" -ti --entrypoint= $pen_image ./run.sh

# tput setaf 240 | v

IFS= read -r -d '' info_txt <<HEREDOC
Pen is under continual development.
If something is broken, try pulling everything.
If it's still broken, try again in a day.
If it's still broken, please make an issue on GitHub.
If you currently have a working setup, don't pull updates unless you want the newest features.
Or report to mullikine on Discord: https://discord.gg/JwKGbAdNHR
https://github.com/semiosis/pen.el/

In development:
- à¿‹ Semiosis Protocol
- TakaheAI
HEREDOC

is_tty() { [ -t 1 ]; }

if is_tty; then
    HAS_TTY=y
else
    HAS_TTY=n
    batch=y
fi

: "${PEN_PREFER_GUI:="y"}"
: "${PEN_SHARE_X:="y"}"

docker() {
    if test "$DEBUG_ABORT" = "y"; then
        cmd "$@" | awk 1
        exit "$?"
    fi

    export PEN_NO_TM

    if inside-docker-p; then
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            bash) break;;
            run.sh|/root/run.sh|./run.sh) {
                if inside-docker-p; then
                    shift
                    set -- newframe.sh "$@"
                else
                    shift
                    set -- run.sh "$@"
                fi
                break
            };;
            newframe.sh|/root/newframe.sh|./newframe.sh) {
                shift
                set -- newframe.sh "$@"
                break
            };;
            eval.sh|/root/eval.sh|./eval.sh) {
                shift
                set -- eval.sh "$@"
                break
            };;
            *) shift;;
        esac; done

        if test "$USE_NVC" = "y"; then
            set -- nvc "$@"
        fi

        # tmux new-window "$@" || tmux new-session "$@"
        "$@"
    else
        command docker "$@"
    fi
}

case "$sn" in
    pi) {
        sn=pen
        : "${PREFER_GUI:="n"}"
    }
    ;;

    pen) {
        sn=pen
        : "${PREFER_GUI:="y"}"
        # Minimum for apostrophe is 2
        # export PEN_N_WORKERS=2
    }
    ;;

    pin) {
        sn=pen
        : "${PREFER_GUI:="n"}"
        : "${no:="y"}"
        # Minimum for apostrophe is 2
        export PEN_N_WORKERS=2
    }
    ;;

    piz) {
        sn=pen
        : "${PREFER_GUI:="n"}"
        : "${NO_EMACS:="y"}"
        : "${no:="y"}"
        # Minimum for apostrophe is 2
        export PEN_N_WORKERS=2
    }
    ;;

    pind) {
        sn=pen
        : "${PREFER_GUI:="n"}"
        : "${no:="y"}"
        PEN_USE_REMOTE_PATH=y
        export PEN_N_WORKERS=2
    }
    ;;

    pend) {
        sn=pen
        : "${PREFER_GUI:="y"}"
        : "${no:="y"}"
        PEN_USE_REMOTE_PATH=y
        export PEN_N_WORKERS=2
    }
    ;;

    ptm) {
        sn=pen
        start_shell=y
        set -- tmux new "$@"
    }
    ;;

    pan) {
        sn=pen
        start_shell=y
        set -- /bin/sh -c "tmux attach -t pen 2>/dev/null || tmux attach -t localhost 2>/dev/null || tmux attach -t init 2>/dev/null || tmux attach"
    }
    ;;

    psh) {
        sn=pen
        start_shell=y
    }
    ;;

    *)
esac

: "${PEN_USE_GUI:="$PREFER_GUI"}"

if test "$sn" = penx; then
    sn=penc

    PEN_USE_GUI=y
    PEN_SHARE_X=y
fi

if test "$sn" = pent; then
    if inside-docker-p || docker-running-p; then
        sn=penc
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
    fi
fi

if test "$sn" = lg; then
    PEN_USE_GUI=n
elif test "$sn" = lgx; then
    sn=lg

    PEN_USE_GUI=y
    PEN_SHARE_X=y
fi

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    sh) {
        start_shell=y
        shift
        break
    }
    ;;

    tm) {
        start_shell=y
        shift
        set -- in-tm "$@"
        break
    }
    ;;

    tmux) {
        start_shell=y
        shift
        set -- tmux "$@"
        break
    }
    ;;

    simplesh) {
        docker run --rm --name "$PEN_CONTAINER_NAME" -ti semiosis/pen.el:latest /bin/bash
        exit "$?"
    }
    ;;

    web) {
        pen-gui-browser "http://localhost:$TTYD_PORT"
        exit
    }
    ;;

    lsp) {
        shift
        set -- sh pen-lsp "$@"
        start_shell=y
        break
    }
    ;;

    tma) {
        start_shell=y
        shift
        set -- "$@" eval "tmux attach || tmux || zsh"
        break
    }
    ;;

    -tty|-nw|-t) {
        PEN_USE_GUI=n
        shift
    }
    ;;

    -nto) {
        PEN_NO_TIMEOUT=y
        shift
    }
    ;;

    -notm) {
        export PEN_NO_TM=y
        shift
    }
    ;;

    # TODO Make it so I can override parameters such as this from the YAML
    # Keep a second YAML or a directory with the values.
    # Would be great to be using a virtual filesystem as the abstraction, actually.
    -n1) {
        export PEN_N_WORKERS=1
        shift
    }
    ;;

    -nem) {
        export NO_EMACS=y
        shift
    }
    ;;

    -nworkers) {
        export PEN_N_WORKERS="$2"
        shift
        shift
    }
    ;;

    -n1) {
        export PEN_N_WORKERS=1
        shift
    }
    ;;

    -frametype) {
        export FRAME_TYPE="$2"
        shift
        shift
    }
    ;;

    -nn) {
        no=y
        show_banner=n
        shift
    }
    ;;

    -n) {
        no=y
        shift
    }
    ;;

    -eth) {
        EXPOSE_ETHEREUM=y
        shift
    }
    ;;

    -rp) {
        PEN_USE_REMOTE_PATH=y
        shift
    }
    ;;

    --parallel|--pool|-l) {
        export USE_POOL=y
        shift
    }
    ;;

    --temp) {
        PEN_TEMPERATURE="$2"
        shift
        shift
    }
    ;;

    --tokens) {
        PEN_MAX_GENERATED_TOKENS="$2"
        shift
        shift
    }
    ;;

    --stop) {
        PEN_STOP_SEQUENCE="$2"
        shift
        shift
    }
    ;;

    --engine) {
        PEN_ENGINE="$2"
        shift
        shift
    }
    ;;

    -human) {
        PEN_ENGINE=human
        shift
    }
    ;;

    --citation) {
        pen-citation
        exit "$?"
        shift
        shift
    }
    ;;

    -nv) {
        USE_NVC=y
        shift
    }
    ;;

    -y) {
        yes=y
        shift
    }
    ;;

    -offline) {
        network=offline
        shift
    }
    ;;

    -network) {
        network="$2"
        shift
        shift

        # Possible values:
        # - offline
        # - host
        # - swarm
        # - modal
        #   - modal is a private network limited to the container
    }
    ;;

    -all|-a) {
        all=y
        shift
    }
    ;;

    -fz) {
        # edit match with pen-eipe
        # --print-query
        # fuzzy="pen-tm mfz -pq -nv"
        # -pq will break pen.vim
        # echo "Once upon " | mfz -pq | v
        fuzzy="pen-tm mfz -nv"
        one_linerise_candidates=y
        shift
    }
    ;;

    -json|-j) {
        output_json=y
        shift
    }
    ;;

    -nojson|-nj) {
        output_json=n
        shift
    }
    ;;

    # Show prompt
    -prompt|-p) {
        prompt=y
        shift
    }
    ;;

    # Show prompt
    -override-prompt|-op) {
        override_prompt="$2"
        shift
        shift
    }
    ;;

    -inject|-i) {
        inject_gen_start="$2"
        shift
        shift
    }
    ;;

    # No generation/query
    -nogen|-n) {
        no_gen=y
        shift
    }
    ;;

    -running-p) {
        docker-running-p
        exit "$?"
    }
    ;;

    -X) {
        PEN_SHARE_X=y
        shift
    }
    ;;

    -noX|-safe) {
        PEN_USE_GUI=n
        PEN_SHARE_X=n
        shift
    }
    ;;

    -nogui|-tty) {
        PEN_USE_GUI=n
        shift
    }
    ;;

    -big) {
        pen_image=semiosis/pen.el:big
        PEN_CONTAINER_NAME=penbig
        shift
    }
    ;;

    -gui|-x) {
        PEN_USE_GUI=y
        PEN_SHARE_X=y
        shift
    }
    ;;

    -d) {
        DEBUG=y
        shift
    }
    ;;

    -nse) {
        no_start_emacs=y
        shift
    }
    ;;

    -u) {
        UPDATE=y
        PEN_UPDATE=t
        shift
    }
    ;;

    --pen-update|--do-update) {
        PEN_UPDATE="$2"
        shift
        shift
    }
    ;;

    --prompt-hist-id) {
        PROMPT_HIST_ID="$2"
        shift
        shift
    }
    ;;

    -Q) {
        vanilla=y
        use_pen_config=n
        shift
    }
    ;;

    -q) {
        vanilla=y
        use_pen_config=y
        shift
    }
    ;;

    *) break;
esac; done

# Not sure exactly why but this export is needed right here after opts
export UPDATE

if test "$PEN_UPDATE" = "y"; then
    PEN_UPDATE=t
fi

if test "$PEN_ENGINE" = "human" || test "$PEN_ENGINE" = "Human"; then
    PEN_NO_TIMEOUT=y
fi

if test "$UPDATE" = "y"; then
    PEN_UPDATE=t
else
    : "${PEN_UPDATE:="nil"}"
fi

if test "$PEN_UPDATE" = "t"; then
    UPDATE=y
fi

export PEN_NO_TIMEOUT
export PEN_ENGINE

case "$FRAME_TYPE" in
    tty) {
        PEN_USE_GUI=n
    }
    ;;

    gui) {
        PEN_USE_GUI=y
    }
    ;;

    *)
esac

if test -n "$PROMPT_HIST_ID"; then
    PROMPT_HIST_ID="\"$PROMPT_HIST_ID\""
else
    PROMPT_HIST_ID=nil
fi

if ! test -n "$PEN_TEMPERATURE"; then
    PEN_TEMPERATURE=nil
fi

if ! test -n "$PEN_MAX_GENERATED_TOKENS"; then
    PEN_MAX_GENERATED_TOKENS=nil
fi

if ! test -n "$PEN_STOP_SEQUENCE"; then
    PEN_STOP_SEQUENCE=nil
else
    PEN_STOP_SEQUENCE="$(cmd-nice-posix "$PEN_STOP_SEQUENCE")"
fi

if ! test -n "$PEN_ENGINE"; then
    PEN_ENGINE=nil
fi

if test "$PEN_ENGINE" = "nil"; then
    PEN_ENGINE_Q=nil
else
    PEN_ENGINE_Q="\"$PEN_ENGINE\""
fi

export USE_NVC

if ! test "$start_shell" = y && \
    test "$input_captured" = y && \
    ! printf -- "%s\n" "$1" | grep -q -P '^pf-' && \
    ! test "$sn" = penu && \
    ! test "$sn" = pena && \
    ! test "$sn" = penj && \
    ! test "$sn" = penf; then

    if test "$sn" = pen && test "$#" -eq 0 && { inside-docker-p || docker-running-p; }; then
        sn=penc
    fi

    set -- "$@" /root/.pen/pen_stdin.txt
fi

if test -z "$DISPLAY"; then
    export PEN_SHARE_X=n
fi

if ! test "$PEN_SHARE_X" = "y"; then
    export DISPLAY=
fi

ensure_pen_running() {
    if ! inside-docker-p && ! docker-running-p; then
        {
            echo "Failed {"
            echo "    $PEN_INVOCATION"
            echo
            echo "    Please start Pen.el server first: pen -nw"
            echo "}"
        } | hls red 1>&2
        exit 1

        echo Starting Pen. Please wait... 1>&2

        # Start pen in background and wait, or start and detach when done
        # How can I detach it when done loading?
        # Maybe the only  way is to ensure that pen -n always starts pen with no interruptions.
        # TODO Ensure that pen.el still starts, even with empty ~/.pen
        ( unbuffer pen -nw -n "$@" &>/dev/null; ) & disown

        while !  docker exec "${PEN_CONTAINER_NAME}" true &>/dev/null; do
            sleep 1
        done
    fi
}

if test "$start_shell" = "y"; then
    # export DISPLAY=
    # nvt

    while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
        "") { shift; }; ;;
        -nse) {
            no_start_emacs=y
            shift
        }
        ;;

        -E) {
            CMD="$2"
            shift
            shift
        }
        ;;

        *) break;
    esac; done

    : ${CMD:="$(cmd "$@")"}
    : "${CMD:="/bin/bash || /bin/zsh || sh"}"

    if inside-docker-p; then
        "$@"

    elif test "$no_start_emacs" = y && ! docker-running-p; then
        echo "Running basic shell without Pen server" | hls blue

        test -n "$MYGIT" && test -d "$MYGIT/semiosis/pen.el" && : "${PENEL_DIR:="$MYGIT/semiosis/pen.el"}"
        test -d "$HOME/pen.el" && test -d "$HOME/pen.el" && : "${PENEL_DIR:="$HOME/pen.el"}"
        test -d "pen.el" && : "${PENEL_DIR:="`pwd`/pen.el"}"

        candidate_config_dir="$(get_config_dir)"
        if test -n "$candidate_config_dir"; then
            test -d "$candidate_config_dir" && : "${PEN_CONFIG_DIR:="$candidate_config_dir"}"
        fi

        IFS= read -r -d '' shcode <<HEREDOC
        pen-docker run -d --rm --name "$PEN_CONTAINER_NAME" -ti \
            -e DISPLAY=${DISPLAY} \
            --detach-keys="$docker_detach_keys" \
            $(test -n "$PEN_CONFIG_DIR" && printf -- "%s " -v "$PEN_CONFIG_DIR:/root/.pen" ) \
            $(test -n "$PENEL_DIR" && printf -- "%s " -v "$PENEL_DIR:/root/.emacs.d/host/pen.el" ) \
            semiosis/pen.el:latest \
            /bin/sh -c "trap 'exit 147' TERM; tail -f /dev/null & while wait \${!}; test \$? -ge 128; do true; done" &>/dev/null
HEREDOC
        eval "$shcode"
    elif ! inside-docker-p && ! docker-running-p; then
        # Start pen in background and wait
        ensure_pen_running
    fi

    if is_tty; then
        if test "$input_captured" = y; then
            mkdir -p ~/.pen
            docker exec --detach-keys="$docker_detach_keys" -e DISPLAY=${DISPLAY} -it "$PEN_CONTAINER_NAME" 'sh' '-c' ". /root/.profile; . /root/.emacs.d/pen.el/scripts/setup-term.sh; cat ~/.pen/pen_stdin.txt | $CMD"
        else
            docker exec --detach-keys="$docker_detach_keys" -e DISPLAY=${DISPLAY} -it "$PEN_CONTAINER_NAME" 'sh' '-c' ". /root/.profile; . /root/.emacs.d/pen.el/scripts/setup-term.sh; $CMD"
        fi
    else
        if test "$input_captured" = y; then
            mkdir -p ~/.pen
            docker exec --detach-keys="$docker_detach_keys" -e DISPLAY=${DISPLAY} "$PEN_CONTAINER_NAME" 'sh' '-c' ". /root/.profile; . /root/.emacs.d/pen.el/scripts/setup-term.sh; cat ~/.pen/pen_stdin.txt | $CMD"
        else
            docker exec --detach-keys="$docker_detach_keys" -e DISPLAY=${DISPLAY} "$PEN_CONTAINER_NAME" 'sh' '-c' ". /root/.profile; . /root/.emacs.d/pen.el/scripts/setup-term.sh; $CMD"
        fi
    fi

    if test "$no_start_emacs" = y; then
        if docker-running-p && yn "Stop container?"; then
            docker stop "$PEN_CONTAINER_NAME"
        fi
    fi
    exit "$?"
fi

vanilla=
use_pen_config=y

if test "$use_pen_config" = "y"; then
    if ! test "$batch" = "y"; then
        if ! test -d "$HOME/.pen" && yn "Create ~/.pen on host (store API keys and generations)?"; then
            mkdir -p "$HOME/.pen"
        fi
    fi

    candidate_config_dir="$(get_config_dir)"
    if test -n "$candidate_config_dir"; then
        test -d "$candidate_config_dir" && : "${PEN_CONFIG_DIR:="$candidate_config_dir"}"
    fi

    if ! test "$batch" = "y" && ! test "$no" = y; then
        : "${PEN_CONFIG_DIR:="$(read -ep "PEN_CONFIG_DIR (leave empty to use docker): ")"}"
    fi

    if test -d "$PEN_CONFIG_DIR"; then
        PEN_CONFIG_DIR="$(realpath "$PEN_CONFIG_DIR")"
    fi
fi

# if test -d "$PEN_CONFIG_DIR"; then
#     mkdir -p "$PEN_CONFIG_DIR/documents"
# fi
# Make it anyway, because pen-xc needs it
test -n "$PEN_CONFIG_DIR" && mkdir -p "$PEN_CONFIG_DIR/documents/notes"

if { test "$sn" = pen || test "$sn" = penc || test "$sn" = penv || test "$sn" = pent; } && \
    test "$PEN_USE_REMOTE_PATH" = y && \
    test "$#" -eq 1 && \
    test -n "$1"; then

    remote_path="$1"
    remote_path="$(realpath "$remote_path")"
    shift
    set -- "$remote_path"

    export NO_QUIT_WORKERS=y

    # This is for read-only text at the top of a potentially new file
    export PEN_PROMPT
    export PEN_HELP
    export PEN_OVERLAY
    export PEN_PREOVERLAY
    export PEN_EIPE_DATA

    if test "$USE_POOL" = "y"; then
        remote_cmd=newframe.sh
        # remote_cmd=/root/.emacs.d/host/pen.el/scripts/newframe.sh
    fi
elif { test "$sn" = pen || test "$sn" = penc || test "$sn" = penv || test "$sn" = pent; } && \
    test "$#" -eq 1 && \
    test -n "$1" && \
    { test -f "$1" || test -d "$1" || which "$1" &>/dev/null; } && \
    test -d "$PEN_CONFIG_DIR/documents"; then

    if { ! test -f "$1"; } && which "$1" &>/dev/null; then
        fp="$(which "$1")"
    else
        fp="$1"
    fi
    # echo "$fp" | tv &>/dev/null

    rp="$(realpath "$fp")"

    shift
    set -- "$rp" "$@"

    bn="$(basename "$rp")"

    export NO_QUIT_WORKERS=y

    # This is for read-only text at the top of a potentially new file
    export PEN_PROMPT
    export PEN_HELP
    export PEN_OVERLAY
    export PEN_PREOVERLAY
    export PEN_EIPE_DATA

    if ! inside-docker-p; then
        local_path="$(realpath "$rp" | pen-convert-path-to-local)"
        if test "$rp" = "$local_path"; then
            ln -f "$rp" "$PEN_CONFIG_DIR/documents/$bn"
            shift
            set -- "/root/.pen/documents/$bn" "$@"
        else
            shift
            set -- "$local_path" "$@"
        fi

        # This is ideal, but requires more work
        # set -- -e "(find-file $(cmd-nice "/root/.pen/documents/$bn"))"
    fi

    if test "$USE_POOL" = "y"; then
        remote_cmd=newframe.sh
        # remote_cmd=/root/.emacs.d/host/pen.el/scripts/newframe.sh
    fi
fi

if test "$sn" = pen && test "$1" = -e && docker-running-p; then
    shift
    sn=pene
fi

if test "$sn" = pen && test "$#" -eq 0 && { inside-docker-p || docker-running-p; }; then
    sn=penc
fi

if test "$sn" = pena; then
    sn=penf
    all=y
    : "${output_json:="y"}"
elif test "$sn" = penj; then
    sn=penf
    : "${output_json:="y"}"
fi

has_placeholder() {
    i=1
    found=
    for var in "$@"
    do
        h="$((i - 1))"
        j="$((i + 2))"
        if test "$var" = "{}"; then
            set -- "${@:1:$h}" "$in" "${@:j}"
            found=y
        fi
        ((i++))
    done

    test "$found" = y
}

export PEN_PF_INVOCATION="$(cmd "$@")"

case "$sn" in
    penf) {
        # cmd "$@" | tv &>/dev/null
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -ask) {
                ask_for_missing_values=y
                shift
            }
            ;;

            *) break;
        esac; done

        fun="$1"

        if test "$input_captured" = y; then
            arity="$(( $# ))"
        else
            arity="$(( $# - 1 ))"
        fi

        if has_placeholder "$@"; then
            arity="$(( $arity - 1 ))"
        fi

        if ! printf -- "%s\n" "$fun" | grep -q -P '/[0-9]+$'; then
            fun="$(penl 2>&1 | grep -P "^(pf-)?${fun}/$arity$")"
        fi

        if test "$ask_for_missing_values" = "y" && ! printf -- "%s\n" "$fun" | grep -q -P "/${arity}$"; then
            true_arity="$(printf -- "%s" "$fun" | sed 's=.*/==')"
            n_missing="$(( true_arity - arity ))"
            start_pos="$(( arity + 1 ))"
            sig="$(unbuffer penh "$fun" | sed 's=.*&optional ==' | cut -d ' ' -f "$start_pos-$true_arity" | tr ' ' '\n')"
            vals="$(
                printf -- "%s\n" "$sig" | awk 1 | while IFS=$'\n' read -r varname; do
                    printf -- "%s " "$(cmd "$(ask-line "$varname")")"
                done
            )"
            CMD="$(cmd "$@")"
            eval "set -- $CMD $vals"
            arity="$true_arity"
        fi

        if ! printf -- "%s\n" "$fun" | grep -q -P "/${arity}$"; then
            sn=penh
            penl_strip_pf=y
        elif ! test "$input_captured" = y; then
            if test "$#" -eq 0; then
                sn=penl
                penl_strip_pf=y
            elif test -z "$fun" && test "$#" -ge 1 && ! printf -- "%s\n" "$1" | grep -Pq "/$(( $# - 1 ))\$"; then
                sn=penh
                penl_strip_pf=y
            fi
        fi
    }
    ;;

    *)
esac

case "$sn" in
    pen|penf) {
        if test "$sn" = penf; then
            if test -n "$fun"; then
                shift
                set -- "$fun" "$@"
            fi
            if test -n "$1" && ! printf -- "%s\n" "$1" | grep -q -P '^pf-'; then
                fun="pf-$1"
                shift
            else
                fun="$1"
                shift
            fi
            sn="pen"
        else
            fun="$1"
            shift
        fi

        if printf -- "%s\n" "$fun" | grep -q -P '^pf-'; then
            show_banner=n

            pfname="$fun"

            if test "$input_captured" = y; then
                # This has issues
                # in="$(cat | qne)"

                # So do I escape or not? Yes. Also remove final whitespace
                # To test, ensure this works:
                # echo -n "Once upon " | penf --pool pf-generic-completion-50-tokens/1
                in="$(cat ~/.pen/pen_stdin.txt | sed -z 's/\s\+$//' | pen-limit-chars)"

                if test "$1" = {}; then
                    shift

                    # This has issues
                    set -- "$in" "$@"
                elif test "$#" -gt 1; then
                    if has_placeholder "$@"; then
                        eval "set -- $(cmd-placeholder "$in" "$@")"
                    else
                        # set -- "$@" "$in"
                        set -- "$in" "$@"
                    fi
                else
                    set -- "$in" "$@"
                fi
            fi

            export PEN_PF_INVOCATION="$pfname $(cmd "$@")"

            if ! printf -- "%s\n" "$pfname" | grep -q -P '/[0-9]*'; then
                pfname="$pfname/$#"
            else
                # If the arity is specified, then take any extras and use as the variadic_arg

                arity="$(printf -- "%s" "$pfname" | cut -d / -f 2)"
                transultimate_pos="$((arity + 1))"

                variadic_arg_arr=("${@:transultimate_pos}")
                variadic_arg="$(cmd-nice "${variadic_arg_arr[@]}")"

                # Only keep the regular vars
                set -- "${@:1:$arity}"
            fi

            if test -n "$variadic_arg"; then
                variadic_arg="'($variadic_arg)"
            else
                variadic_arg=nil
            fi

            CMD="$(cmd-nice "$@")"

            if test "$prompt" = "y"; then
                include_prompt=t
            else
                include_prompt=nil
            fi

            if test "$no_gen" = "y"; then
                no_gen=t
            else
                no_gen=nil
            fi

            if test -n "$inject_gen_start"; then
                inject_gen_start="$(cmd-nice "$inject_gen_start")"
            else
                inject_gen_start="nil"
            fi

            if test -n "$override_prompt"; then
                override_prompt="$(cmd-nice "$override_prompt")"
            else
                override_prompt="nil"
            fi

            # if test "$DEBUG" = "y"; then
            #     echo "(json-encode-list (pen-batch (pen-update ($pfname $CMD :no-select-result t :include-prompt $include_prompt :no-gen $no_gen :variadic-var $variadic_arg))))" | tv &>/dev/null
            # fi

            if test "$one_linerise_candidates" = "y"; then
                output_fn=pen-list2str-oneliners
            elif test "$output_json" = "y"; then
                output_fn=json-encode-list
            else
                output_fn=pen-list2str
            fi

            if test "$all" = "y"; then
                ncompletions_limiter_fn="mapcar 'identity"
            else
                ncompletions_limiter_fn=pen-single-generation
            fi

            set -- -e "($output_fn (pen-batch ($ncompletions_limiter_fn (pen-force ((do-pen-update $PEN_UPDATE) (pen-force-engine $PEN_ENGINE_Q) (max-generated-tokens $PEN_MAX_GENERATED_TOKENS) (force-temperature $PEN_TEMPERATURE) (force-stop-sequence $PEN_STOP_SEQUENCE)) ($pfname $CMD :no-select-result t :prompt-hist-id $PROMPT_HIST_ID :include-prompt $include_prompt :no-gen $no_gen :variadic-var $variadic_arg :override-prompt $override_prompt :inject-gen-start $inject_gen_start)))))"

            HAS_TTY=n
            batch=y
            docker_cmd=exec
            remote_cmd=/root/.emacs.d/pen.el/scripts/eval.sh
        else
            # Put it back
            set -- "$fun" "$@"
        fi
    }
    ;;

    pensh) {
        # HAS_TTY=y
        batch=y
        docker_cmd=exec

        firstarg="$1"
        shift

        remote_cmd="$firstarg"
    }
    ;;

    penc) {
        set -- -c "$@"
    }
    ;;

    pene) {
        show_banner=n
        set -- -e "$@"
    }
    ;;

    # pen call ilambda function
    # Example: peni list-programming-languages 5
    # pene "(pps (progn (idefun list-programming-languages) (list-programming-languages \"5\")))"
    # peni color-of-thing watermelon
    peni) {
        show_banner=n
        sn=pene
        do_page=y

        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -npp) {
                no_prepend_previous=y
                shift
            }
            ;;

            *) break;
        esac; done

        ifunc_name="$1"
        shift

        output_json=y

        ifunc_name="$(p "$ifunc_name" | slugify)"

        ARGS="$(cmd-nice-posix "$@")"

        if test "$no_prepend_previous" = "y"; then
            code="(pps (progn (idefun $ifunc_name) (pen-no-prepend-previous ($ifunc_name $ARGS))))"
        else
            code="(pps (progn (idefun $ifunc_name) ($ifunc_name $ARGS)))"
        fi

        set -- -e "(pen-force ((do-pen-update $PEN_UPDATE) (pen-force-engine $PEN_ENGINE_Q) (max-generated-tokens $PEN_MAX_GENERATED_TOKENS) (force-temperature $PEN_TEMPERATURE) (force-stop-sequence $PEN_STOP_SEQUENCE)) $code)"
    }
    ;;

    # pen call ilambda macro (generate code)
    # (pps (macroexpand (progn (imacro fib-sequence)(fib-sequence 5))))
    penm) {
        show_banner=n
        sn=pene

        imacro_name="$1"
        shift

        ARGS="$(cmd-nice-posix "$@")"

        set -- -e "(pps (progn (imacro $imacro_name) (macroexpand ($imacro_name $ARGS))))"
    }
    ;;

    pent) {
        # This is used to run docker terminal emacs with -e
        # Advanced.
        # Used for ii.
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
        # export DEBUG_ABORT=y
        # set -- -t -- -e "$@"
    }
    ;;

    pente) {
        # This is used to run docker terminal emacs with -e
        # Advanced.
        # Used for ii.
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
        export USE_NVC
        # export DEBUG_ABORT=y
        set -- -t -- -e "$@"
    }
    ;;

    penv) {
        export USE_NVC=y
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
    }
    ;;

    penu) {
        show_banner=n
        UPDATE=y
        set -- -e "$@"
    }
    ;;

    penl) {
        show_banner=n
        set -- -e '(pen-list2str pen-prompt-functions)'
    }
    ;;

    lg|looking-glass) {
        show_banner=y
        # set -- -ic "(pen-funcall-interactively 'eww $(cmd-nice "$1"))"
        # This *must* be a regular funcall.
        set -- -ic "(funcall 'eww $(cmd-nice "$1"))"
    }
    ;;

    paracosm|cosm) {
        show_banner=y
        HAS_TTY=y
        PEN_USE_GUI=n
        # set -- -ic "(pen-funcall-interactively 'pen-org-brain-switch-brain $(cmd-nice "$1"))"

        set -- -ic "(call-interactively 'pen-org-brain-switch-brain)"
    }
    ;;

    penh) {
        if test -n "$1" && ! printf -- "%s\n" "$1" | grep -q -P '^pf-'; then
            fun="$1"
            shift

            set -- "pf-$fun" "$@"
        fi

        if test -n "$1" && ! printf -- "%s\n" "$1" | grep -q -P '/[0-9]'; then
            if test "$#" -gt 0; then
                fun="$(penl | grep "^$1/" | head -n 1)"
            else
                fun="$(penl | grep "^$1/$#" | head -n 1)"
            fi
        fi

        show_banner=n
        if test "$#" -eq 0; then
            fun="$(penz)"
        else
            fun="$1"
        fi
        set -- -e "(helpful--signature '$fun)"
    }
    ;;

    penq) {
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            "") { shift; }; ;;
            -f) {
                force_shutdown_now=y
                shift
            }
            ;;

            *) break;
        esac; done

        show_banner=n

        # Attempting shutdown of Pen.el
        in-pen sync-elpa-with-host

        if { ! inside-docker-p; } && docker-running-p; then
            set -- -e "(progn (pen-sn \"pen-shutdown\")(kill-emacs))"
            force_shutdown_container=y

            if test "$force_shutdown_now" = "y"; then
                docker container stop "$PEN_CONTAINER_NAME" 2>/dev/null
                exit "$?"
            fi
        elif inside-docker-p; then
            pen-shutdown
            killall emacs
        else
            echo Not running. 1>&2
            exit 0
        fi
    }
    ;;

    penz) {
        show_banner=n
        fuzzy="mfz -nv"
        set -- -e '(pen-list2str pen-prompt-functions)'
    }
    ;;

    *) {
        show_banner=n
        if test "$input_captured" = y; then
            in="$(cat ~/.pen/pen_stdin.txt)"

            if test "$1" = {}; then
                shift

                set -- "$(cat)" "$@"
            elif test "$#" -gt 1; then
                i=1
                for var in "$@"
                do
                    h="$((i - 1))"
                    j="$((i + 2))"
                    if test "$var" = "{}"; then
                        set -- "${@:1:$h}" "$in" "${@:j}"
                    fi
                    ((i++))
                done
            else
                set -- "$in" "$@"
            fi
        fi

        CMD="$(cmd-nice "$@")"

        set -- -e "(pen-list2str (pen-single-generation (pen-force ((do-pen-update $PEN_UPDATE) (pen-force-engine $PEN_ENGINE_Q) (max-generated-tokens $PEN_MAX_GENERATED_TOKENS) (force-temperature $PEN_TEMPERATURE) (force-stop-sequence $PEN_STOP_SEQUENCE)) ($sn $CMD :no-select-result t :temperature $PEN_STOP_SEQUENCE :prompt-hist-id $PROMPT_HIST_ID))))"
        HAS_TTY=n
        batch=y
        docker_cmd=exec
        remote_cmd=./.emacs.d/pen.el/scripts/eval.sh
    }
    ;;
esac

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    config) {
        shift
        set -- -ic "(call-interactively 'pen-customize)"
    }
    ;;

    *) break;
esac; done

{
if ! test "$show_banner" = n; then
    printf -- "%s\n" "$banner"
    case "$sn" in
        lg*|looking-glass*) {
            looking-glass-logo
        }
        ;;

        ap*) {
            apostrophe-logo
        }
        ;;

        paracosm*|cosm*) {
            paracosm-logo
        }
        ;;

        ii*) {
            ii-logo
        }
        ;;

        nlsh*) {
            nlsh-logo
            echo "Natural Language Shell"
            echo
        }
        ;;

        *) {
            ocif -today pen-banner.sh | cat
            dgrey
            echo
            echo Version: ${pen_version}, License: GPL-3 | hls orange
            echo
            dgrey
            printf -- "%s\n" "$info_txt"
            echo "Using image: $pen_image"
        }
        ;;
    esac
    echo
fi
} 1>&2

: "${docker_cmd:="run"}"
: "${remote_cmd:="/root/run.sh"}"

opt="$1"
case "$opt" in
    uninstall) {
        set -xv
        sudo rm -irf ~/.pen
    }
    ;;

    *)
esac

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -c) {
        batch=y
        docker_cmd=exec

        shift

        CMD="$(cmd-nice "$@")"
        : ${CMD:="$(cmd-nice "$@")"}

        if inside-docker-p; then
            remote_cmd=newframe.sh
        else
            remote_cmd="/root/.emacs.d/pen.el/scripts/newframe.sh"
        fi

        # Shift all so it doesn't do -e here
        # shift "$#"
    }
    ;;

    -ic) {
        batch=y
        docker_cmd=exec
        INTERACTIVE=y

        shift

        CMD="$(cmd-nice "$@")"
        : ${CMD:="$(cmd-nice "$@")"}

        if inside-docker-p; then
            remote_cmd=newframe.sh
        else
            remote_cmd="/root/.emacs.d/pen.el/scripts/newframe.sh"
        fi

        # Shift all so it doesn't do -e here
        # shift "$#"
    }
    ;;

    -e) {
        HAS_TTY=n
        batch=y
        PEN_SHARE_X=n
        docker_cmd=exec
        if inside-docker-p; then
            remote_cmd=eval.sh
        else
            remote_cmd="/root/.emacs.d/pen.el/scripts/eval.sh"
        fi
        shift

        if test "$UPDATE" = "y"; then
            last_arg="${@: -1}"
            test "$#" -gt 0 && set -- "${@:1:$(($#-1))}" # shift last arg

            set -- "$@" "(pen-update $last_arg)"
        fi
    }
    ;;

    # This is like pene, has the tty
    -t) {
        batch=y
        PEN_SHARE_X=n
        docker_cmd=exec
        INTERACTIVE=y
        shift

        if inside-docker-p; then
            remote_cmd=newframe.sh
        else
            remote_cmd="/root/.emacs.d/pen.el/scripts/newframe.sh"
        fi

        if test "$UPDATE" = "y"; then
            last_arg="${@: -1}"
            test "$#" -gt 0 && set -- "${@:1:$(($#-1))}" # shift last arg

            set -- "$@" "(pen-update $last_arg)"
        fi
    }
    ;;

    -rcmd) {
        remote_cmd="$2"
        shift
        shift
    }
    ;;

    --)
        shift
        break
    ;;

    *) break;
esac; done

{
echo "remote_cmd=\"$remote_cmd\"" | hls green 
dgrey
} 1>&2

if ! test "$vanilla" = "y" && ! inside-docker-p && ! docker-running-p; then
    test -n "$MYGIT" && test -d "$MYGIT/semiosis/glossaries" && : "${GLOSSARIES_DIR:="$MYGIT/semiosis/glossaries"}"
    test -d "glossaries" && : "${GLOSSARIES_DIR:="`pwd`/glossaries"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/ilambda" && : "${ILAMBDA_DIR:="$MYGIT/semiosis/ilambda"}"
    test -d "ilambda" && : "${ILAMBDA_DIR:="`pwd`/ilambda"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/prompts" && : "${PROMPTS_DIR:="$MYGIT/semiosis/prompts"}"
    test -d "prompts" && : "${PROMPTS_DIR:="`pwd`/prompts"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/engines" && : "${PEN_ENGINES_DIR:="$MYGIT/semiosis/engines"}"
    test -d "engines" && : "${PEN_ENGINES_DIR:="`pwd`/engines"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/creation" && : "${PEN_CREATION_DIR:="$MYGIT/semiosis/creation"}"
    test -d "creation" && : "${PEN_CREATION_DIR:="`pwd`/creation"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/personalities" && : "${PEN_PERSONALITIES_DIR:="$MYGIT/semiosis/personalities"}"
    test -d "personalities" && : "${PEN_PERSONALITIES_DIR:="`pwd`/personalities"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/incarnations" && : "${PEN_INCARNATIONS_DIR:="$MYGIT/semiosis/incarnations"}"
    test -d "incarnations" && : "${PEN_INCARNATIONS_DIR:="`pwd`/incarnations"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/tomes" && : "${PEN_TOMES_DIR:="$MYGIT/semiosis/tomes"}"
    test -d "tomes" && : "${PEN_TOMES_DIR:="`pwd`/tomes"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/dni" && : "${PEN_DNI_DIR:="$MYGIT/semiosis/dni"}"
    test -d "dni" && : "${PEN_DNI_DIR:="`pwd`/dni"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/metaverses" && : "${PEN_METAVERSES_DIR:="$MYGIT/semiosis/metaverses"}"
    test -d "metaverses" && : "${PEN_METAVERSES_DIR:="`pwd`/metaverses"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/protoverses" && : "${PEN_PROTOVERSES_DIR:="$MYGIT/semiosis/protoverses"}"
    test -d "protoverses" && : "${PEN_PROTOVERSES_DIR:="`pwd`/protoverses"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/pen.el" && : "${PENEL_DIR:="$MYGIT/semiosis/pen.el"}"
    test -d "$HOME/pen.el" && test -d "$HOME/pen.el" && : "${PENEL_DIR:="$HOME/pen.el"}"
    test -d "pen.el" && : "${PENEL_DIR:="`pwd`/pen.el"}"
    # : "${PENEL_DIR:="$(read -ep "PENEL_DIR (leave empty to use docker): ")"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/pen-contrib.el" && : "${CONTRIB_DIR:="$MYGIT/semiosis/pen-contrib.el"}"
    test -d "pen-contrib.el" && : "${CONTRIB_DIR:="`pwd`/pen-contrib.el"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/pensieve" && : "${PENSIEVE_DIR:="$MYGIT/semiosis/pensieve"}"
    test -d "pensieve" && : "${PENSIEVE_DIR:="`pwd`/pensieve"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/khala" && : "${KHALA_DIR:="$MYGIT/semiosis/khala"}"
    test -d "khala" && : "${KHALA_DIR:="`pwd`/khala"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/rhizome" && : "${RHIZOME_DIR:="$MYGIT/semiosis/rhizome"}"
    test -d "rhizome" && : "${RHIZOME_DIR:="`pwd`/rhizome"}"

    test -d "$MYGIT/semiosis/openai-api.el" && : "${OPENAI_API_EL_DIR:="$MYGIT/semiosis/openai-api.el"}"
    test -d "openai-api.el" && : "${OPENAI_API_EL_DIR:="`pwd`/openai-api.el"}"
    # : "${OPENAI_API_EL_DIR:="$(read -ep "OPENAI_API_EL_DIR (leave empty to use docker): ")"}"

    # yn "Pull docker image?" && docker pull $pen_image

    if test -n "$PEN_CONFIG_DIR" && test -d "$PEN_CONFIG_DIR" && test -d "$PENEL_DIR"; then
        my_config_fp="$PEN_CONFIG_DIR/pen.yaml"
        example_config_fp="$PENEL_DIR/config/example-pen.yaml"
        if test -f "$example_config_fp" && ! test -f "$my_config_fp"; then
            cp -a "$example_config_fp" "$PEN_CONFIG_DIR"/pen.yaml
        fi
    fi

    if ! test "$batch" = y && \
        ! test "$yes" = y && \
        ! test "$no" = y && \
        yn "Keep updated"; then
        yes=y
    fi

    # set -v
    if ! test "$batch" = "y"; then
        yn "Pull docker image?" && (
            echo docker pull $pen_image
            docker pull $pen_image
        )
    fi

    if ! test "$batch" = "y"; then
        if test -d "$PEN_ENGINES_DIR"; then
            yn "Pull engines repo? (recommended)" && (
                cd "$PEN_ENGINES_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone engines repo here?" && (
                git clone "http://github.com/semiosis/engines"
            )
        fi
    fi

    test -d "engines" && : "${PEN_ENGINES_DIR:="engines"}"

    if ! test "$batch" = "y"; then
        if test -d "$ILAMBDA_DIR"; then
            yn "Pull ilambda repo? (recommended)" && (
                cd "$ILAMBDA_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone ilambda repo here?" && (
                git clone "http://github.com/semiosis/ilambda"
            )
        fi
    fi

    test -d "ilambda" && : "${ILAMBDA_DIR:="ilambda"}"

    if ! test "$batch" = "y"; then
        if test -d "$PROMPTS_DIR"; then
            yn "Pull prompts repo? (recommended)" && (
                cd "$PROMPTS_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone prompts repo here?" && (
                git clone "http://github.com/semiosis/prompts"
            )
        fi
    fi

    test -d "prompts" && : "${PROMPTS_DIR:="prompts"}"

    if ! test "$batch" = "y"; then
        if test -d "$PEN_CREATION_DIR"; then
            yn "Pull creation repo? (recommended)" && (
                cd "$PEN_CREATION_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone creation repo here?" && (
                git clone "http://github.com/semiosis/creation"
            )
        fi
    fi

    test -d "creation" && : "${PEN_CREATION_DIR:="creation"}"

    if ! test "$batch" = "y"; then
        if test -d "$PEN_PERSONALITIES_DIR"; then
            yn "Pull personalities repo? (recommended)" && (
                cd "$PEN_PERSONALITIES_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone personalities repo here?" && (
                git clone "http://github.com/semiosis/personalities"
            )
        fi
    fi

    test -d "personalities" && : "${PEN_PERSONALITIES_DIR:="personalities"}"

    if ! test "$batch" = "y"; then
        if test -d "$PEN_INCARNATIONS_DIR"; then
            yn "Pull incarnations repo? (recommended)" && (
                cd "$PEN_INCARNATIONS_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone incarnations repo here?" && (
                git clone "http://github.com/semiosis/incarnations"
            )
        fi
    fi

    test -d "incarnations" && : "${PEN_INCARNATIONS_DIR:="incarnations"}"

    if ! test "$batch" = "y"; then
        if test -d "$PEN_TOMES_DIR"; then
            yn "Pull tomes repo? (recommended)" && (
                cd "$PEN_TOMES_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone tomes repo here?" && (
                git clone "http://github.com/semiosis/tomes"
            )
        fi
    fi

    test -d "tomes" && : "${PEN_TOMES_DIR:="tomes"}"

    if ! test "$batch" = "y"; then
        if test -d "$PEN_DNI_DIR"; then
            yn "Pull dni repo? (recommended)" && (
                cd "$PEN_DNI_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone dni repo here?" && (
                git clone "http://github.com/semiosis/dni"
            )
        fi
    fi

    test -d "dni" && : "${PEN_DNI_DIR:="dni"}"

    if ! test "$batch" = "y"; then
        if test -d "$PEN_METAVERSES_DIR"; then
            yn "Pull metaverses repo? (recommended)" && (
                cd "$PEN_METAVERSES_DIR"
                git pull --rebase origin master
            )
        else
            yn "Clone metaverses repo here?" && (
                git clone "http://github.com/semiosis/metaverses"
            )
        fi
    fi

    test -d "metaverses" && : "${PEN_METAVERSES_DIR:="metaverses"}"

    if ! test "$batch" = "y"; then
        test -d "$PENEL_DIR" && yn "Pull pen.el repo? (recommended)" && (
            cd "$PENEL_DIR"
            git pull --rebase origin master
        )
    fi

    if ! test "$batch" = "y"; then
        test -d "$CONTRIB_DIR" && yn "Pull pen-contrib.el repo? (recommended)" && (
            cd "$CONTRIB_DIR"
            git pull --rebase origin master
        )
    fi

    if ! test "$batch" = "y"; then
        test -d "$PENSIEVE_DIR" && yn "Pull pensieve repo? (recommended)" && (
            cd "$PENSIEVE_DIR"
            git pull --rebase origin master
        )
    fi

    if ! test "$batch" = "y"; then
        test -d "$RHIZOME_DIR" && yn "Pull rhizome repo? (recommended)" && (
            cd "$RHIZOME_DIR"
            git pull --rebase origin master
        )
    fi

    if ! test "$batch" = "y"; then
        test -d "$KHALA_DIR" && yn "Pull khala repo? (recommended)" && (
            cd "$KHALA_DIR"
            git pull --rebase origin master
        )
    fi

    if test -d "$ILAMBDA_DIR"; then
        ILAMBDA_DIR="$(realpath "$ILAMBDA_DIR")"
    fi

    if test -d "$PROMPTS_DIR"; then
        PROMPTS_DIR="$(realpath "$PROMPTS_DIR")"
    fi

    if test -d "$PEN_ENGINES_DIR"; then
        PEN_ENGINES_DIR="$(realpath "$PEN_ENGINES_DIR")"
    fi

    if test -d "$PEN_PERSONALITIES_DIR"; then
        PEN_PERSONALITIES_DIR="$(realpath "$PEN_PERSONALITIES_DIR")"
    fi

    if test -d "$PEN_TOMES_DIR"; then
        PEN_TOMES_DIR="$(realpath "$PEN_TOMES_DIR")"
    fi

    if test -d "$PEN_DNI_DIR"; then
        PEN_DNI_DIR="$(realpath "$PEN_DNI_DIR")"
    fi

    if test -d "$PEN_METAVERSES_DIR"; then
        PEN_METAVERSES_DIR="$(realpath "$PEN_METAVERSES_DIR")"
    fi

    if test -d "$PEN_PROTOVERSES_DIR"; then
        PEN_PROTOVERSES_DIR="$(realpath "$PEN_PROTOVERSES_DIR")"
    fi
fi

# TODO Solve permissions issues with the host ~/.pen directory

# --env "USER=$USER" \
# --env "GROUP=$USER" \
# --env "USER_ID=1000" \
# --env "GROUP_ID=1000" \

if ! test -n "$DISPLAY"; then
    PEN_USE_GUI=n
fi

export PEN_USE_GUI
export PEN_SHARE_X
export NO_EMACS

if test "$docker_cmd" = run && docker-running-p && ! inside-docker-p; then
    docker_cmd=exec
fi

# This auto starts pen.el. Not what I want
# if ! inside-docker-p && ! docker-running-p; then
#     if printf -- "%s\n" "$INSIDE_EMACS" | grep -q comint &>/dev/null; then
#         unbuffer pen &>/dev/null & disown
#     fi
# 
#     if test "$docker_cmd" = exec; then
#         set -- -e "$@"
#     fi
#     docker_cmd=run
#     remote_cmd="/root/run.sh"
# fi

# docker_cmd should only = run if it hasn't started yet
if inside-docker-p && test "$docker_cmd" = run; then
    docker_cmd=exec
fi

case "$docker_cmd" in
    run) {

    if test -n "$DISPLAY"; then
        cmd-nice xhost + | awk 1 1>&2
        xhost +

        echo
        echo If this fails, try running pen with -noX
        echo " pen -noX"
        echo
    fi

CMD="$(cmd "$@")"
: ${CMD:="$(cmd "$@")"}

: "${USER:="$(whoami)"}"

IFS= read -r -d '' shcode <<HEREDOC
    if ! is_tty; then
        remote_cmd="unbuffer $remote_cmd"
    fi

    # --user "$(id -u):$(id -g)"

    # Double ensure it's removed
    docker container rm "$PEN_CONTAINER_NAME" &>/dev/null

    pen-docker "$docker_cmd" \
        -d \
        $(test "$docker_cmd" = run && printf -- "%s " --rm ) \
        $(test -n "$OPENAI_API_KEY" && printf -- "%s " -e "OPENAI_API_KEY:$OPENAI_API_KEY" ) \
        $(test -n "$PEN_CONFIG_DIR" && printf -- "%s " -v "$PEN_CONFIG_DIR:/root/.pen" ) \
        $(test -n "$ILAMBDA_DIR" && printf -- "%s " -v "$ILAMBDA_DIR:/root/.emacs.d/host/ilambda" ) \
        $(test -n "$PROMPTS_DIR" && printf -- "%s " -v "$PROMPTS_DIR:/root/.emacs.d/host/prompts" ) \
        $(test -n "$PEN_ENGINES_DIR" && printf -- "%s " -v "$PEN_ENGINES_DIR:/root/.emacs.d/host/engines" ) \
        $(test -n "$PEN_METAVERSES_DIR" && printf -- "%s " -v "$PEN_METAVERSES_DIR:/root/.emacs.d/host/metaverses" ) \
        $(test -n "$PEN_PROTOVERSES_DIR" && printf -- "%s " -v "$PEN_PROTOVERSES_DIR:/root/.emacs.d/host/protoverses" ) \
        $(test -n "$PEN_PERSONALITIES_DIR" && printf -- "%s " -v "$PEN_PERSONALITIES_DIR:/root/.emacs.d/host/personalities" ) \
        $(test -n "$PEN_TOMES_DIR" && printf -- "%s " -v "$PEN_TOMES_DIR:/root/.emacs.d/host/tomes" ) \
        $(test -n "$PEN_DNI_DIR" && printf -- "%s " -v "$PEN_DNI_DIR:/root/.emacs.d/host/dni" ) \
        $(test -n "$PENEL_DIR" && printf -- "%s " -v "$PENEL_DIR:/root/.emacs.d/host/pen.el" ) \
        $(test -n "$CONTRIB_DIR" && printf -- "%s " -v "$CONTRIB_DIR:/root/.emacs.d/host/pen-contrib.el" ) \
        $(test -n "$PENSIEVE_DIR" && printf -- "%s " -v "$PENSIEVE_DIR:/root/.emacs.d/host/pensieve" ) \
        $(test -n "$RHIZOME_DIR" && printf -- "%s " -v "$RHIZOME_DIR:/root/.emacs.d/host/rhizome" ) \
        $(test -n "$KHALA_DIR" && printf -- "%s " -v "$KHALA_DIR:/root/.emacs.d/host/khala" ) \
        $(test -n "$GLOSSARIES_DIR" && printf -- "%s " -v "$GLOSSARIES_DIR:/root/.emacs.d/host/glossaries" ) \
        $(test -n "$OPENAI_API_EL_DIR" && printf -- "%s " -v "$OPENAI_API_EL_DIR:/root/.emacs.d/host/openai-api.el" ) \
        $(
        if command -v yq &>/dev/null && test -f ~/.pen/pen.yaml; then
            cat ~/.pen/pen.yaml | yq -r ".volumes[]" | awk 1 | while IFS=$'\n' read -r vol; do
            vol="$(realpath "$vol")"
            test -n "$vol" && printf -- "%s " -v "$vol:/volumes/$vol" 
            done
        elif test -f ~/.pen/volumes.txt && test -f cat ~/.pen/volumes.txt; then
            cat ~/.pen/volumes.txt | awk 1 | while IFS=$'\n' read -r vol; do
            vol="$(realpath "$vol")"
            test -n "$vol" && printf -- "%s " -v "$vol:/volumes/$vol" 
            done
        fi
        ) \
        $(test "$HAS_TTY" = y && printf -- "%s " -ti ) \
        --hostname pen-$(hostname) \
        --env PEN_USE_GUI \
        --env PEN_SHARE_X \
        --env PEN_NO_TM \
        --env INTERACTIVE \
        --env EXPOSE_ETHEREUM \
        --env PEN_CONTAINER_NAME \
        --env TTYD_PORT \
        --env KHALA_PORT \
        --env PEN_ENGINE \
        --env PEN_NO_TIMEOUT \
        --env PEN_N_WORKERS \
        --env NO_EMACS \
        --env PEN_PROMPT \
        --env PEN_HELP \
        --env PEN_OVERLAY \
        --env NO_QUIT_WORKERS \
        --env USE_NVC \
        --env TERM \
        --env USE_NVC \
        --detach-keys="$docker_detach_keys" \
        $(if test -n "$DISPLAY"; then
        cmd --privileged \
        --env COLORFGBG \
        -e DISPLAY=${DISPLAY} \
        --env EMAIL \
        --env "PEN_USER=$USER" \
        --env GIT_AUTHOR_EMAIL \
        --env GIT_AUTHOR_NAME \
        --env GIT_COMMITTER_EMAIL \
        --env GIT_COMMITTER_NAME \
        --env SSH_AUTH_SOCK \
        --env "TIMEZONE=UTC" \
        --env "VIDEO_GROUP_ID=44" \
        -v /dev/dri:/dev/dri \
        -v /dev/shm:/dev/shm \
        -v /tmp/.X11-unix:/tmp/.X11-unix \
        "--cap-add=SYS_PTRACE" \
        "--cap-add=SYS_ADMIN" \
        "--cap-add=NET_ADMIN" \
        --ulimit "rtprio=100:100" \
        -v /var/log/coredumps:/var/log/coredumps
        fi
        ) \
        $(if macos-p; then
            cmd --env="DISPLAY=host.docker.internal:0"
        fi
        ) \
        $(if test "$network" = swarm; then
        ` #  Overlay networks connect multiple Docker workers together and enable swarm services to communicate with each other. `
        (
        docker swarm init
        docker network create --driver=overlay --attachable --subnet=192.168.0.0/16 pennet
        ) 1>&2
            cmd --network pennet
        elif test "$network" = modal; then
            ` # modal network for MyTeaParty `
            :
        elif test "$network" = offline; then
            cmd --network none
        else
        ` # both of these work `
        ` # cmd --network bridge `
            cmd --network host
        fi
        ) \
        --expose $TTYD_PORT -p $TTYD_PORT:$TTYD_PORT \
        --expose $KHALA_PORT -p $KHALA_PORT:$KHALA_PORT \
        $(
        if test "$EXPOSE_ETHEREUM" = y; then
            cmd --expose 8545; p " "
            cmd --expose 8546; p " "
            cmd --expose 30303; p " "
            cmd --expose 30303/udp
        fi
        ) \
        --entrypoint= --name=$PEN_CONTAINER_NAME $pen_image "$remote_cmd" $CMD

    echo Starting Pen.el 1>&2
    sleep 15

    # After it has started, simply run again
    # "$sn" tm new pen-watch-workers
    ( sleep 2 && "$sn" sh tmux run -t pen: "spinner-start -b" ) & disown
    # The spinner is stoppen in pen-banner.sh
    "$sn" sh pen-tm init-or-attach -n pen
HEREDOC
    }
    ;;

    # --user "$(id -u):$(id -g)"
    exec) {
        if ! inside-docker-p && ! docker-running-p; then
            ensure_pen_running
            exit 1
        fi

        if test "$INTERACTIVE" = "y"; then
            if test "$1" = -e; then
                shift
                elisp="$@"
                set -- -e "$@"
            else
                elisp="$@"
            fi
            
            set -- -e "(switch-to-buffer \"*scratch*\") (pen-force ((do-pen-update $PEN_UPDATE) (pen-force-engine $PEN_ENGINE_Q) (max-generated-tokens $PEN_MAX_GENERATED_TOKENS) (force-temperature $PEN_TEMPERATURE) (force-stop-sequence $PEN_STOP_SEQUENCE)) $elisp)"
        fi

        # Test quotes:
        # pena --temp 0.9 -u pf-very-witty-pick-up-lines-for-a-topic/1 "new \"zealand" | jq-list-to-lines

        remote_cmd="$(printf -- "%s" "$remote_cmd" | sed 's/.*\/run.sh/newframe.sh/')"

        evalcommand="$(cmd-nice ". ~/.emacs.d/pen.el/scripts/setup-term.sh; $(cmd-nice eval "$(cmd-onelineify-safe "$remote_cmd" "$@")")")"
IFS= read -r -d '' shcode <<HEREDOC
pen-docker "$docker_cmd" --detach-keys="$docker_detach_keys" --env USE_POOL --env USE_NVC --env NO_EMACS --env PEN_USE_GUI --env PEN_SHARE_X --env PEN_NO_TM --env PEN_CONTAINER_NAME --env PEN_ENGINE --env PEN_NO_TIMEOUT $(test "$HAS_TTY" = y && printf -- "%s " -ti ) "$PEN_CONTAINER_NAME" bash -c $evalcommand
HEREDOC
    }
    ;;

    *)
esac

pen-docker() {
    # echo the environment passed to the command
    printf -- "%s\n" docker "$@" | sed -z "s/--env\\n/--env /g" | grep -- --env | grep -v = | cut -d ' ' -f 2 | while read varname; do val="${!varname}"; if test -n "$val"; then echo "${varname}=$val"; fi; done | hls blue 1>&2

    docker "$@"
}

pen_eval() {
    if test "$DEBUG" = "y"; then
	if which cmd-nice-with-bs &>/dev/null; then
	    firstarg="cmd-nice-with-bs $1"
            shift
            set -- "$firstarg" "$@"
	else
	    echo "$@"
	fi
    fi

    if test "$penl_strip_pf" = "y"; then
        eval "$@" | sed 's/^pf-//'
    else
        eval "$@"
    fi
}

# pen-pl "$shcode" | pen-tv &>/dev/null

export EXPOSE_ETHEREUM
export INTERACTIVE

pen_eval_fuzzy_maybe() {
    echo "$shcode" | hls purple 1>&2
    if printf -- "%s\n" "$shcode" | grep -q -P "^pen-docker.*-ti.*setup-term.*eval.*newframe.sh" && ! test "$PEN_USE_GUI" = "y"; then
        echo ensure xterm 1>&2
    fi
    # docker "exec" --detach-keys="ctrl-q,ctrl-q" --env USE_POOL --env USE_NVC --env NO_EMACS --env PEN_USE_GUI --env PEN_SHARE_X --env PEN_NO_TM --env PEN_CONTAINER_NAME --env PEN_ENGINE --env PEN_NO_TIMEOUT -ti  "pen" bash -c ". ~/.emacs.d/pen.el/scripts/setup-term.sh; \"eval\" \"'/root/.emacs.d/host/pen.el/scripts/newframe.sh'\""
    if test -n "$fuzzy"; then
        pen_eval "$shcode" | eval "$fuzzy" | pen-str unonelineify
    else
        pen_eval "$shcode"
    fi
}

if test "$do_page" = y; then
    pen_eval_fuzzy_maybe | pen-host-pager
else
    pen_eval_fuzzy_maybe
fi
ret="$?"

if test "$docker_cmd" = exec && is_tty && test "$INTERACTIVE" = y; then
    clear
    echo Pen exited | hls red
    tmux send C-l &>/dev/null
fi

if test "$force_shutdown_container" = "y"; then
    # penq should've quit pen.el, but it may be hanging
    if docker-running-p; then
        sleep 0.5
        echo Force quitting Pen.el container | hls red 1>&2
        docker container stop "$PEN_CONTAINER_NAME" 2>/dev/null
    fi
fi

if test "$sn" = penh; then
    zrepl -nocl -E "penf $fun"
else
    exit "$ret"
fi
