#!/bin/bash
export TTY

test -d "/root/.pen/tmp" && : "${TMPDIR:="/root/.pen/tmp"}"
test -d "/tmp" && : "${TMPDIR:="/tmp"}"

unset CWD

shopt -s extglob
shopt -s globstar

# TODO Add something to activate a venv
# pen-x -sh bash -s '. .env/bin/activate' -c m -i

# DONE Add something to run a file *AS* a type of file (such as a Dockerfile)
# vim +/"-spec) {" "$SCRIPTS/pen-cr"

export NOPAK

cd_run() {
    CWD="$1" exec pen-x -zsh -s "ls" -c m -s "./$mant" -c m -a
}

cd_ls() {
    CWD="$1" exec pen-x -zsh -s "ls" -c m -a
}

sn="$(basename "$0")"

# is_tty works for detecting the different between a tty and compilation-mode in emacs
is_tty() { [ -t 1 ] && ! test "$TERM" = "dumb"; }

if is_tty; then
    interactive=y
else
    interactive=n
fi

case "$sn" in
    cri) {
        interactive=y
    }
    ;;

    *)
esac

pen-pak() {
    zcd .
}

sudomaybe() {
    if test "$DO_SUDO" = "y"; then
        cmd m"$@" 1>&2
        m"$@"
    else
        "$@"
    fi
}

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    -i) {
        interactive=y
        shift
    }
    ;;

    -ls|-li|-list) {
        cat "$SCRIPTS/${sn}" | pen-scrape "trycr [^\$ ]+$" | cut -d ' ' -f 2 | print-line-if-path-exists | uniqnosort | pen-pavs
        exit $?
    }
    ;;

    -ch|-pick|-sel|-choose) {
        sel="$("$SCRIPTS/${sn}" -li | pen-fzf)"
        if test -n "$sel"; then
            eval "$SCRIPTS/${sn} $sel"
        else
            :
            pen-cr
            # echo "cr: aborting"
        fi
        exit $?
    }
    ;;

    -y) {
        export YN_DEFAULT=y
        shift
    }
    ;;

    -d|-ud) {
        USE_DIR=y
        shift
    }
    ;;

    -spec) {
        fnspec="$2"
        shift
        shift
    }
    ;;

    -ft*) { # Because "$1" == "-ft kotlin", when used in shebang
        # echo "$opt"
        if pen-pl "$opt" | grep -q -P -- '-ft.+'; then
            file_type="$(p "$opt" | sed 's/^-ft *//')"
            # file_type="${opt##* }"
            shift
        else
            file_type="$2"
            shift
            shift
        fi
    }
    ;;

    *) break;
esac; done

# echo "$file_type"
# exit 0

# printf -- "%s\n" "$1"

stdin_exists() {
    ! [ -t 0 ]
}

if stdin_exists && ! test -f "$1"; then
    fp="$(cat | pen-tf txt)"
    exec <&2
else
    fp="$1"
    shift
fi

arg1="$fp"

if ! test -f "$1" && test -d "$fp" && ! test "$USE_DIR" = y; then
    cd "$fp"
    fp=
fi

tryfun() {
    fun_name="$1"
    eval "$1"
}

scrapefromreadme() {
    commands="$(timeout 3 scrape-install-commands-from-readme 2>/dev/null)"
    if test -n "$commands" && pen-yn "See build commands?"; then
        command="$(p "$commands" | pen-fzf -1)"
        if test -n "$command"; then
            zrepl -E "$command"
        fi
    fi
}

trycr() {
    while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
        "") { shift; }; ;;
        -d) {
            USE_DIR=y
            shift
        }
        ;;

        *) break;
    esac; done

    fp="$1"

    # if test "$fp" = "Cargo.toml"; then
        # set -x
    # fi

    dn="$(dirname "$fp")"
    fn="$(basename "$fp")"

    export USE_DIR

    if test "$USE_DIR" = "y" && test -d "$fn"; then
        pen-yn "Use $fp?" && pen-cr "$fn"
    else
        # the dn might not exist, actually
        test -d "$dn" && cd "$dn"

        if ! test -e "$fn"; then
            # Can't use iname
            # ls 1>&2
            possible="$(find . -maxdepth 1 -name "$fn" -print -quit)"
            if test -n "$possible"; then
                fn="$possible"
            fi
        fi

        if test -e "$fn" && pen-yn "Use $fp?"; then
            pen-cr "$fn"
        fi
    fi

    return 0
}

if test -z "$fp"; then
    # Look for build files

    echo pen-cr
    echo Looking for build files | udl

    tryfun scrapefromreadme # 2>/dev/null
    if test -f .gitmodules && pen-yn "update git submodules?"; then
        # git submodule update --init
        git submodule update --init --recursive --remote
    fi
    for f in install*; do
        test -f "$f" && trycr "$f"
    done

    # default.nix sets the environment to do building. Therefore, it should go first
    # $MYGIT/serokell/gui-haskell-app
    trycr default.nix

    trycr build.sh
    trycr install.sh
    trycr docker-compose.yml

    trycr -d .github

    for f in $(pen-glob "**/Dockerfile*"); do
        (
            trycr "$f"
        )
    done
    trycr bootstrap
    trycr appveyor.yml
    trycr CMakeLists.txt # Keep this before Makefile
    USE_DIR=y trycr .env
    USE_DIR=y trycr venv
    USE_DIR=y trycr .venv
    # Makefile.PL must come before Makefile
    trycr Makefile.PL
    trycr Makefile
    trycr GNUmakefile
    trycr project.clj
    trycr build.boot
    trycr gradlew
    trycr build.gradle
    trycr composer.json
    trycr build.xml
    trycr tsconfig.json
    trycr Pipfile
    trycr Rakefile
    trycr meson.build
    trycr build.sbt
    trycr Gemfile
    trycr pom.xml
    trycr deps.edn
    trycr psc-package.json
    trycr bower.json
    trycr leanpkg.toml
    trycr BUILD
    trycr BUILD.bazel
    trycr spago.dhall
    trycr Gruntfile.js
    trycr make.jl
    trycr Project.toml
    trycr autogen.sh
    trycr go.mod
    trycr environment.yml
    trycr configure
    trycr main.go
    trycr yarn.lock
    trycr brower.json
    trycr gulpfile.js
    trycr package.json
    # package.yaml for hpack
    trycr package.yaml
    trycr Setup.hs
    # trycr *.cabal
    for f in *.cabal; do
        trycr "$f"
    done
    trycr stack.yaml
    trycr poetry.lock
    trycr pyproject.toml
    trycr setup.py
    trycr mkdocs.yml
    # This is so it doesnt permanently change directory.
    ( trycr "tests/__init__.py"; )
    ( trycr "tests/*.py"; )
    for f in "*.ipynb"; do
        trycr "$f"
    done
    for f in "*.nix"; do
        trycr "$f"
    done
    trycr test.py
    trycr tests.py
    trycr configure.ac
    trycr Cargo.toml
    trycr Makefile.toml
    trycr requirements.txt
    trycr DotNetCoreKoans.sln
    trycr dune-project
    trycr config.toml

    glow -d

    exit 1
fi

fp="$(pen-glob "$fp")"
rp="$(realpath "$fp")"
dn="${rp%/*}"
dnbn="$(basename "$dn")"

# TODO check for binary files
if test -f "$fp"; then
    first_line="$(head -n 1 "$fp")"
fi

td_cr="$(mktemp -t -d td_crXXXXXX || echo /dev/null)"
trap "rmdir \"$td_cr\" 2>/dev/null" 0

bn="$(basename "$rp")"
fn=$(basename "$rp")
ext="${fn##*.}"
mant="${fn%.*}"

if test -f "$rp" && test -s "$rp"; then
    read first_line < "$rp"
fi

rp="$(p "$rp" | pen-mnm | pen-umn)"

if [ -z "$file_type" ]; then
    file_type="$ext"
fi

# pen-tm -d dv "$file_type"

is_tty() {
    # If stout is a tty
    [[ -t 1 ]]
}

case "$rp" in
    *vscode/packages*) {
        cat "$rp" | sed '/^$/d' | sed '/^#/d' | awk 1 | while IFS=$'\n' read -r line; do
            /usr/bin/code --install-extension "$line"
        done

        exit 0
    }
    ;;

    $MYGIT/mullikine/glossaries/*.txt|$NOTES/ws/*/glossary.txt) {
        push-glossary
        exit 0
    }
    ;;

    */ilambda/hs/*) {
        cd /root/.emacs.d/host/ilambda/hs/
        cabal build
        # pet cabal repl
        pet cabal repl
        exit 0
    }
    ;;

    $MYGIT/semiosis/khala*) {
        cd $MYGIT/semiosis/khala/
        lein run
        zrepl -cm lein run
        exit 0
    }
    ;;

    $MYGIT/semiosis/pensieve*) {
        cd $MYGIT/semiosis/pensieve/
        zrepl lein run
        exit 0
    }
    ;;

    $MYGIT/semiosis/rhizome/*) {
        cd $MYGIT/semiosis/rhizome/
        zrepl lein run
        exit 0
    }
    ;;

    $DUMP$NOTES/ws/blog/blog/*|$HOME/blog/posts/*.org) {
        ans="$(qa -. edit \
                  -d deploy-hugo \
                  )"

        case "$ans" in
            edit) { vs $0; } ;;
            deploy-hugo) { deploy-hugo; } ;;
            *) ;;
        esac

        exit 0
    }
    ;;

    $MYGIT/mullikine/presentation-prompt-engineering-in-emacs/*) {
        cd $MYGIT/mullikine/presentation-prompt-engineering-in-emacs

        gen-slides presentation.org

        pen-pak
        exit 0
    }
    ;;

    $MYGIT/takaheai/otagoai-website/*) {
        ans="$(qa -. edit \
                  -t test \
                  -d deploy )"

        case "$ans" in
            edit) { vs $0; } ;;
            test) { shx deploy-takaheai -nd; } ;;
            deploy) { shx deploy-takaheai; } ;;
            *) ;;
        esac

        pen-pak
        exit 0
    }
    ;;

    $MYGIT/infogetics/infogetics-hugo/*|$MYGIT/infogetics/infogetics.github.io/*) {
        deploy-infogetics

        pen-pak
        exit 0
    }
    ;;

    $MYGIT/semiosis/semiosis-hugo/*|$MYGIT/semiosis/semiosis.github.io/*) {
        deploy-semiosis

        pen-pak
        exit 0
    }
    ;;

esac

# echo "$fn" | tv &>/dev/null

# This is the original, potential symlink file name
: "${fnspec:="$(basename "$fp")"}"

# The predicates need to be more complex than merely the file path

make() {
    # Run an implicit make config before each make
    command make config
    command make "$@"
}

python() {
    python3.7 "$@"
}

case "$fnspec" in
    .compton.conf) {
        killall compton
        set -m
        compton & disown
        pen-tm n "Compton restarted"
        exit 0
    }
    ;;

    .env) {
        pen-x -sh bash -s '. .env/bin/activate' -c m -i
        exit 0
    }
    ;;

    .venv) {
        pen-x -sh bash -s '. .venv/bin/activate' -c m -i
        exit 0
    }
    ;;

    venv) {
        pen-x -sh bash -s '. venv/bin/activate' -c m -i
        exit 0
    }
    ;;

    test.py|tests.py) {
        cd "$dn"
        # Do this in a split because pen-cr may be run from emacs
        # pen-sps sp-ic-x -cd -sn python-pytest-popup
        # This has history
        # sp -e "(python-pytest-file \"test.py\")"
        # pen-sps python-eruntest

        pen-sps nvt -pak pen-python "$fn"
        nvt -pak python-trace "$fn"

        exit 0
    }
    ;;

    shanepy.py) {
        cd "$dn"
        rm /usr/local/lib/python2.7/dist-packages/shanepy*
        rm /usr/local/lib/python3.5/dist-packages/shanepy*
        rm /usr/local/lib/python3.6/dist-packages/shanepy*
        rm /usr/local/lib/python3.7/dist-packages/shanepy*
        rm /usr/local/lib/python3.8/dist-packages/shanepy*
        python setup.py build -b $TMPDIR/shanepy install --record $TMPDIR/files.txt
        python3.5 setup.py build -b $TMPDIR/shanepy install --record $TMPDIR/files.txt
        python3.6 setup.py build -b $TMPDIR/shanepy install --record $TMPDIR/files.txt
        python3.7 setup.py build -b $TMPDIR/shanepy install --record $TMPDIR/files.txt
        # python3.7 setup.py build -b $TMPDIR/shanepy_user install --record $TMPDIR/files_user.txt
        python3.8 setup.py build -b $TMPDIR/shanepy install --record $TMPDIR/files.txt

        . ~/sh-source/conda-init
        chown shane:shane $TMPDIR/files.txt
        chown shane:shane $TMPDIR/files_user.txt
        python setup.py build -b $TMPDIR/shanepy install --record $TMPDIR/files.txt

        cd $MYGIT/mullikine/shanepy
        make clean

        pen-tm n "shanepy installed"

        if is_tty; then
            pen-pak
        fi

        exit 0
    }
    ;;

    environment.yml) {
        cd "$dn"
        conda env create -f environment.yml
        name="$(cat "$fp" | yq -r .name)"
        zrepl -cm -E ". $HOME/sh-source/miniconda3.sh; conda activate $name"
        pen-pak -k c
        exit 0
    }
    ;;

    go.mod) {
        cd "$dn"
        pwd
        if pen-yn "Attempt go get?"; then
            shorturl="$(pen-vc url | sed 's/^https\?:\/\///')"
            go get -u "$shorturl"
        else
            set -xv
            go build
            go install
        fi
        pen-pak -k c
        exit 0
    }
    ;;

    main.go) {
        cd "$dn"
        pwd
        if pen-yn "Attempt go run?"; then
            go run main.go
        elif pen-yn "Attempt go get?"; then
            shorturl="$(pen-vc url | sed 's/^https\?:\/\///')"
            go get -u "$shorturl"
        else
            set -xv
            go build
            go install
        fi
        pen-pak -k c
        exit 0
    }
    ;;

    # Not necessarily executable
    install.sh|build.sh) {
        # set -xv
        cd "$dn"
        # This needs to be perl, not sh, in case it's a bash script and
        # not POSIX compatible
        perl ./"$fn"
        exit 0
    }
    ;;

    install*) {
        cd "$dn"
        if test -x "$fn"; then
            DO_SUDO="$(yn "Use sudo?" && p y)"
            if test "$DO_SUDO" = "y"; then
                m"./$fn"
            else
                "./$fn"
            fi
        else
            if test "$(head -c 2 "$rp")" = "#!"; then
                perl "$rp"
                pen-pak
                exit $?
            fi
        fi
        exit "0"
    }
    ;;

    Makefile.toml) {
        cd "$dn"
        if pen-yn "Attempt cargo install?"; then
            set -xv

            dnbn="$(basename "$dn")"

            cargo install "$dnbn"
        else
            set -xv
            cargo make
            cargo make install
        fi
        pen-pak -k c
        exit 0
    }
    ;;

    # Cargo.toml
    Cargo.*) {
        cd "$dn"
        if pen-yn "Attempt cargo install?"; then
            set -xv

            dnbn="$(basename "$dn")"

            cargo install "$dnbn"
        else
            set -xv
            cargo build
            cargo install --force --path .

            # cargo build --release
            # cargo run --release --bin wezterm -- start
        fi
        pen-pak -k c
        exit 0
    }
    ;;

    yarn.lock) {
        cd "$dn"
        set -xv
        yarn install
        # yarn run compile
        yarn run

        pen-yn "Install globally?" && yarn global add "$dnbn"

        pen-pak -k c
        exit 0
    }
    ;;

    bower.json) {
        cd "$dn"
        bower install
        exit 0
    }
    ;;

    texi) {
        cd "$dn"
        makeinfo "$fn"
        exit 0
    }
    ;;

    mkdocs.yml) {
        cd "$dn"
        mkdocs build
        exit 0
    }
    ;;

    gulpfile.js) {
        cd "$dn"
        npm pen-i gulp
        gulp
        exit 0
    }
    ;;

    package.json) {
        cd "$dn"

        DO_SUDO="$(yn "Use sudo?" && p y)"

        if pen-yn "Install only (y)?\n Otherwise, select from available commands (n)"; then
            cat package.json| jq -r ".scripts | keys[]" | tr '\n' ' ' | sed -e 's/^/npm commands: /' -e 's/ $//' | awk 1
            sudomaybe npm build
            sudomaybe npm install
            sudomaybe npm start
        else
            set -xv
            sudomaybe npm install

            key="$(cat "$fn" | jq -r ".scripts | keys[]" | pen-fzf)"
            if test -n "$key"; then
                sudomaybe npm run-script "$key"
                # cmd="$(cat "$fn" | jq -r ".scripts.$key")"
                # if tent -n "$cmd"; then
                    # eval "$cmd"
                # fi
            fi
        fi

        pen-pak
        exit 0
    }
    ;;

    bootstrap) {
        cd "$dn"
        sh bootstrap
        ynx ./configure
        ynx make
        ynx make install
        exit 0
    }
    ;;

    appveyor.yml) {
        cd "$dn"
        v "$fn"
        exit 0
    }
    ;;

    autogen.sh) {
        cd "$dn"
        ./autogen.sh
        ./configure && make -j 8
        pen-yn "make install?" && make install
        exit 0
    }
    ;;

    configure) {
        # './configure', 'make config' or 'make iconfig', then 'make'

        set -xv

        cd "$dn"
        if test -f config.status; then
            pen-ns "The previous config for $dn was $(./config.status --config)"
            if pen-yn "Use previous config?"; then
                ./config.status --config | v
                eval "./configure $(./config.status --config)" && make -j 8
            elif pen-yn "Open previous config?"; then
                ./config.status --config | v
            else
                ./configure && make -j 8
            fi
        else
            ./configure && make -j 8
        fi
        exit 0
    }
    ;;

    project.clj) {
        cd "$dn"
        set -xv
        # lein run

        if test -n "$(open-main | cat)" && pen-yn "Run main? (y)"; then
            echo "pass it arguments to programhere"
            zrepl lein run

            # The following isn't guaranteed to run
            # zrepl lein run -m main
        elif pen-yn "Start REPL (y)?"; then
            pen-x -sh "lein repl" -e "=>" -s "(in-ns 'main)" -c m -i
        elif pen-yn "Install (y)?"; then
            lein deps
            lein test
            lein install
        else
            :
        fi

        exit 0
    }
    ;;

    bower.json) {
        cd "$dn"
        bower install
        exit 0
    }
    ;;

    leanpkg.toml) {
        cd "$dn"
        leanpkg configure && leanpkg build
        exit 0
    }
    ;;

    BUILD|BUILD.bazel) {
        cd "$dn"
        # bazel build

        ## bazelisk is a wrapper that selects the correct version
        # bazelisk query ...
        # bazelisk build ...

        # bazelisk query ... 2>/dev/null | grep -Po "^//.*" | pen-sps vs
        # pen-sps zrepl -E "bazelisk build "

        bazelisk query ... 2>/dev/null | grep -Po "^//.*" | pen-fzf -1 | pen-xa pen-sps zrepl bazelisk build

        # bazelisk build //tools/tests:test_message4_proto

        # bazelisk query
        bazelisk build
        exit 0
    }
    ;;

    requirements.txt) {
        cd "$dn"

        # This is how it's created
        # pip freeze > requirements.txt

        # TODO Ask to use venv

        if pen-yn "Use venv?"; then
            set -xv

            upgrade-pip
            pwd

            # test -d venvdir || python3.6 -m venv venvdir
            test -d .env || python -m venv .env

            # pen-x -shE ""

            # . venvdir/bin/activate
            source .env/bin/activate

            # pip install --upgrade pip

            # which -a pip
            # which -a python

            pip install -r "$fn"

            pen-x -sh bash -s '. .env/bin/activate' -c m -i
        else
            echo Installing requirements 1>&2

            # pip install -r "$fn"
            # py pen-i -r "$fn"

            # This method aborts on first failed
            # mpip3.5 install -r "$fn"
            # mpip3.6 install -r "$fn"

            export PYTHONPATH=.
            pip install -r "$fn"

            # mpip3.5 install -r "$fn"
            # mpip3.6 install -r "$fn"
            # mpip3.8 install -r "$fn"

            # cat "$fn" | sed -e '/^\s*#.*$/d' -e '/^\s*$/d' | xargs -n 1 mpip3.5 install
            # cat "$fn" | sed -e '/^\s*#.*$/d' -e '/^\s*$/d' | xargs -n 1 mpip3.6 install

            # pip-install-requirements-txt
        fi

        exit 0
    }
    ;;

    requirements*.txt) {
        # py -38 pen-i -r requirements-dev.txt
        py pen-i -r requirements-dev.txt
        exit $?
    }
    ;;

    docker-compose.yml) {
        cd "$dn"

        if pen-yn "Generate plantuml?"; then
            (
                cd "$(td)"
                cat "$rp" | docker-compose-plantuml --link-graph | pen-tf plantuml | pen-xa v
            )
        fi

        # if pen-yn "View plantuml svg?"; then
        #     (
        #         cd "$(td)"
        #         scope.sh "$rp" | plantuml -w -svg | pen-tf svg | pen-xa win ie
        #     )
        # fi
        if pen-yn "docker compose up?"; then
            cd "$dn"
            set -xv
            # docker-compose up
            docker-compose -f "$bn" up
            pen-pak
        fi

        # pen-pak
        exit 0
    }
    ;;

    Gruntfile.js) {
        cd "$dn"

        # This installs the local grunt
        npm install

        # This runs the local grunt
        grunt
    }
    ;;

    vagrantfile|Vagrantfile) {
        cd "$dn"

        boxname="box-$(date-ts)"

        # The vagrantfile actually contains box definitions

        box="$(cat "$fp" | remove-leading-and-trailing-spaces.sh | grep config.vm.define | pen-str field 2 | tr -d '[",]' | pen-fzf)"

        test -n "$box" && vagrant up "$box"

        # vagrant package --output "${boxname}.box" --vagrantfile Vagrantfile

        pen-pak
        exit 0
    }
    ;;

    composer.json) {
        cd "$dn"
        set -xv

        # Install PHP
        # https://www.php.net/downloads.php

        # Build and install
        echo Build and install
        composer-setup
        php composer.phar install

        echo

        # Install via package manager
        echo Install via package manager
        project_name="$(cat composer.json | jq -r .name)"
        composer require "$project_name"

        pen-pak
        exit 0
    }
    ;;

    k8s-entrypoint.sh) {
        ni "$fp"
    }
    ;;

    Gemfile) {
        cd "$dn"
        bundle install
        pen-pak
        exit 0
    }
    ;;

    Gemfile) {
        cd "$dn"
        guard
        pen-pak
        exit 0
    }
    ;;

    config.toml) {
        cd "$dn"
        if test -d content && test -d themes; then
            echo "$dn"

            # dn="$(p "$dn" | pen-mnm | pen-umn)"

            set -xv
            if test "$dn" = "$MYGIT/takaheai/otagoai-website"; then
                deploy-takaheai
            else
                hugo
            fi
        else
            echo "Not sure what this config.toml is for"
        fi
        pen-pak
        exit 0
    }
    ;;

    Dockerfile*) {
        cd "$dn"

        # TODO Figure out how to read these args and send them to docker
        args="$(cat "$fn" | grep -Po "^ARG [^ ]+" | pen-str field 2)"
        test -n "$args" && {
            echo Export these and try again
            printf -- "%s\n" "$args"
        }

        if pen-yn "Install?"; then
            # TODO "--squash" is only supported on a Docker worker with experimental features enabled
            # --squash .
            # real-docker image build -f "$fn" --squash --no-cache --network=host -t "$(dirslug | sed 's/^-*//' | tr -d '\n';)-$(pwd | hash-crc32 | tr -d '\n'):1.0" .
            real-docker image build -f "$fn" --no-cache --network=host -t "$(dirslug | sed 's/^-*//' | tr -d '\n';)-$(pwd | hash-crc32 | tr -d '\n'):1.0" .
        else
            real-docker image build -f "$fn" --no-cache --network=host .
        fi

        # This builds an image and creates a name:tag for it
        # docker image build -t bulletinboard:1.0 .

        # docker container run --publish 8000:8080 --detach --name bb bulletinboard:1.0
        pen-pak
        exit 0
    }
    ;;

    configure.ac|Makefile.am) {
        cd "$dn"
        # autoreconf --install
        autoreconf -i || {
            libtoolize --force
            aclocal
            autoheader
            automake --force-missing --add-missing
            autoconf
            # ./configure
        }

        if ! is_tty || pen-yn "Configure and make as well?"; then
            ./configure
            make -j 10
        fi

        if test -f Makefile && is_tty && pen-yn "Install?"; then
            make install
        fi
        exit 0
    }
    ;;

    # Java
    build.xml) {
        cd "$dn"
        # ant -f build.xml
        # ant
        ant local
        exit 0
    }
    ;;

    tsconfig.json) {
        cd "$dn"
        tsc
        exit 0
    }
    ;;

    *.xunit.xml) {
        junit2html --summary-matrix "$fp" | pa -vs
        exit 0
    }
    ;;

    gitlab-ci.yml) {
        prog="$(qa -c compile-yaml -q yiq -r run)"
        case "$prog" in
            compile-yaml|yiq) {
                pen-tm -d nw -args filter "$prog" "$rp"
            }
            ;;

            # This will run in tmp
            run) {
                run-gitlab-ci "$fp"
            }
            ;;

            # run-in-tmp) {
            #     run-gitlab-ci -t "$fp"
            # }
            # ;;

            *)
        esac

        pen-pak
        exit 0
    }
    ;;

    .gitlab-ci.yml) {
        prog="$(qa -c compile-yaml -q yiq -r run)"
        case "$prog" in
            compile-yaml|yiq) {
                pen-tm -d nw -args filter "$prog" "$rp"
            }
            ;;

            run) {
                run-gitlab-ci "$fp"
            }
            ;;
            *)
        esac

        pen-pak
        exit 0
    }
    ;;

    # Clojure build tool
    build.boot) {
        cd "$dn"
        if pen-yn "REPL?"; then
            boot repl
        else
            # This will show the help
            boot 2>&1 | pen-pavs
        fi
        pen-pak
        exit 0
    }
    ;;

    # Clojure dependencies
    deps.edn) {
        cd "$dn"
        clj
        # clj-rebel
        pen-pak
        exit 0
    }
    ;;

    # Java
    pom.xml) {
        cd "$dn"
        mvn package
        pen-pak
        exit 0
    }
    ;;

    psc-package.json) {
        cd "$dn"
        psc-package install
        pen-pak
        exit 0
    }
    ;;

    build.gradle) {
        cd "$dn"
        gradle -b "$fn"
        pen-pak
        exit 0
    }
    ;;

    gradlew) {
        cd "$dn"
        ./"$fn"
        pen-pak
        exit 0
    }
    ;;

    spago.dhall) {
        cd "$dn"
        spago install
        spago build
        pen-pak
        exit 0
    }
    ;;

    .travis.yml) {
        cd "$dn"
        {
            cat .travis.yml | yqy -r '(.before_install | join("\n")) + "\n" + (.install | join("\n"))' | sed 's/^travis_retry //' | awk 1
            cmd cd "$dn"
        } | pen-ds travis | bash -s -xv
        pen-pak
        exit 0
    }
    ;;

    meson.build) {
        cd "$dn"

        mkdir -p build
        cd build

        if test "$interactive" = "y"; then
            z-repl -E "meson ..; ninja"
        else
            meson ..
            # meson configure # list options
            # meson configure -D disable-mtab=true # set an option
            ninja
            pen-pak
        fi
        exit 0
    }
    ;;

    CMakeLists.txt) {
        cd "$dn"

        # mkdir -p build_debug;
        # cd build_debug;
        # cmake -DCMAKE_BUILD_TYPE=Debug ..;

        mkdir -p build
        cd build
        # This is the clean of cmake
        rm -f CMakeCache.txt

        if test "$interactive" = "y"; then
            z-repl -E "cmake -DCMAKE_BUILD_TYPE=Release ../ && make -j8"
            pen-yn "cmake make and install?" && z-repl -E "cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/local && cmake --build . --target install"
        else
            cmake ..
            # cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/local
            make
            pen-pak
        fi
        exit 0
    }
    ;;

    .aderc) {
        set -xv
        cd "$dn"

        if test -d "$NOTES/programs/adehome"; then
            ADE_HOME="$NOTES/programs/adehome"
        else
            ADE_HOME="$(pwd)"
        fi
        export ADE_HOME
        ! test "$RUN_ONLY" = y && {
            if pen-yn "Update?"; then
                ade start --update
            else
                ade start
            fi
        }
        ade enter
        # ade start -- --net=host --privileged
        pen-pak
        exit 0
    }
    ;;

    .Xresources) {
        cd "$dn"
        set -xv
        xrdb -merge ~/.Xresources
        xrdb -load ~/.Xresources
        # xmonad --restart
        # killall nautilus-desktop
        # restart-compton
        pen-pak
        exit 0
    }
    ;;

    *.ghci|.ghci*) {
        cd "$dn"
        babel-ghci "$fn"
        exit 0
    }
    ;;

    setup.py) {
        if yn "Create venv and build setup.py (y)? or install directly with setup.py (n)"; then
            python3 -m venv venv/

            x -sh bash -s '. venv/bin/activate' -c m \
                -s 'pip install -e .[dev,deploy]' -c m \
                -s 'pre-commit install' -c m -i
        else
            cd "$dn"
            wd="$(printf -- "%s" "$(pwd)" | slugify)"
            rm -f "$TMPDIR/$wd-files.txt"
            touch "$TMPDIR/$wd-files.txt"
            chmod 777 "$TMPDIR/$wd-files.txt"

            # set -xv
            if grep -q "extras_require={" "$fn" && pen-yn "Install extras?"; then

                # extras_require={"keyring": ["keyring >= 12.2.0"]},
                if grep -q -P "extras_require={.*}," "$fn"; then
                    extra_target="$(sed -n "/extras_require={/p" "$fn" | sed -n "s/^[^\"]\\+\"\\([^\"]\\+\\).*/\\1/p")"
                else
                    extra_target="$(sed -n -e "/extras_require={/,/},/p" "$fn" | sed -n "s/^\\s\\+[\"']\\([^\"']\\+\\).*/\\1/p" | pen-fzf)"
                fi

                if test -n "$extra_target"; then
                    # py pip install ".[$extra_target]"
                    mypy pen-i ".[$extra_target]"
                fi
            fi

            # py e setup.py build -b "$TMPDIR/$wd" install --record "$TMPDIR/$wd-files.txt"
            mpen-python setup.py build -b "$TMPDIR/$wd" install --record "$TMPDIR/$wd-files.txt"
        fi
        exit 0
    }
    ;;

    poetry.lock) {
        cd "$dn"
        poetry install
        poetry shell || pen-pak
        exit 0
    }
    ;;

    pyproject.toml) {
        cd "$dn"
        if pen-yn "Use poetry (y) or pip (n)?"; then
            poetry install
            poetry shell || pen-pak
        else
            python -m pip install .
            pen-pak
        fi
        exit 0
    }
    ;;

    Pipfile|Pipfile.lock) {
        cd "$dn"
        pipenv install ||
            pipenv install --dev ||
            pipenv3.5 install --dev

        # python -m pipenv install --dev

        pipenv shell
        pen-pak
        exit 0
    }
    ;;

    Caddyfile) {
        cd "$dn"
        caddy run
        pen-pak
        exit 0
    }
    ;;

    Rakefile) {
        cd "$dn"
        if ! is_tty; then
            bundle exec rake -t | strip-ansi
            # rake | strip-ansi
        else
            # rake
            bundle exec rake -t
        fi
        pen-pak
        exit 0
    }
    ;;

    package.yaml) {
        cd "$dn"
        set -xv

        # hpack will generate a cabal file

        build_file="$(hpack | pen-scrape ".*\\.cabal")"
        pen-cr "$build_file"

        # stack build --test

        pen-pak
        exit 0
    }
    ;;

    Setup.hs) {
        cd "$dn"
        set -xv

        if pen-yn "Use stack?"; then
            stack setup
            stack install
        elif pen-yn "Use runhaskell Setup.sh?"; then
            # runhaskell Setup.hs configure
            runhaskell Setup.hs configure --ghc

            # https://downloads.haskell.org/~ghc/7.0.4/docs/html/Cabal/builders.html
            # runhaskell Setup.hs configure --user
            runhaskell Setup.hs build

            # mrunhaskell Setup.hs install
            runhaskell Setup.hs install
        fi
        pen-pak
        exit 0
    }
    ;;

    pyproject.toml) {
        cd "$dn"
        # https://python-poetry.org/docs/basic-usage/

        source $HOME/.poetry/env

        poetry install
        exit 0
    }
    ;;

    make.jl) {
        cd "$dn"
        julia "$fn"

        exit 0
    }
    ;;

    Project.toml) {
        cd "$dn"
        package_name="$(p "$dnbn" | sed "s/\\..*//")"
        pen-x -sh julia -e ">" \
            -s 'using Pkg' -c m \
            -s "Pkg.add(\"$package_name\")" -c m \
            -s "using $package_name" -c m -i
        exit 0
    }
    ;;

    build.sbt) {
        cd "$dn"

        nvt sbt-console

        ## I do not think these commands are very standard
        #sbt build
        ## This may let you select from a list
        #sbt run
        ## sbt package # package up the project

        pen-pak
        exit 0
    }
    ;;

    dune-project) {
        cd "$dn"
        dune external-lib-deps --missing @install
        dune build @install
        dune install

        pen-pak
        exit 0
    }
    ;;

    mkfile) {
        cd "$dn"
        cat "$fn" | make-showschema | sed 's/:.*//' | pen-fzf | pen-xa unbuffer /usr/lib/plan9/bin/mk | less -rS +F

        pen-pak
        exit 0
    }
    ;;

    Makefile.PL) {
        cd "$dn"

        (
            set -xv
            perl "$fn"
            make
            make test
        )

        DO_SUDO="$(yn "Makefile.PL: Use sudo?" && p y)"
        if test "$DO_SUDO" = "y"; then
            make install
        else
            make install
        fi

        pen-pak
        exit 0
    }
    ;;

    Makefile|GNUmakefile) {
        cd "$dn"
        # /usr/bin/make -v | pager
        # cat "$fn" | make-showschema | sed 's/:.*//' | pen-fzf | pen-xa unbuffer make -v | less -rS +F
        # cat "$fn" | make-showschema | sed 's/:.*//' | pen-fzf | pen-xa unbuffer /usr/bin/make -v | less -rS +F
        # cat "$fn" | make-showschema | sed 's/:.*//' | pen-fzf | pen-xa unbuffer /usr/bin/make | less -rS +F

        # mwas needed to find the go binary/ toolchain

        # Lint for tabs
        # cat -e -t -v "$fn" | pen-pavs

        pwd | ns
        # This works
        {

            sel="$(cat "$fn" | make-showschema | sed 's/:.*//' | pen-fzf)"
            exec 2>&1
            set -xv

            # if test "$sel" = install; then

            if test -n "$sel"; then
                if pen-yn "sudo?"; then
                    # unbuffer make "$sel"
                    unbuffer mmake "$sel"
                else
                    unbuffer make "$sel"
                fi
            fi

            #else
            #    unbuffer make  "$sel"

            #    # unbuffer m"$sel"
            #fi

            echo "Finished."
        } | less -rS +F

        # Neither vim nor emacs has line chopping for term
        # I need the new version of tmux for this.
        # cat "$fn" | make-showschema | sed 's/:.*//' | pen-fzf | pen-xa e -sh make
        # cat "$fn" | make-showschema | sed 's/:.*//' | pen-fzf | pen-xa nvc make
        pen-pak
        exit 0
    }
    ;;

    glide.yaml) {
        echo "This is deprecated for go modules" 1>&2
        cd "$dn"
        glide install
        pen-pak
        exit 0
    }
    ;;

    stack.yaml) {
        cd "$dn"
        stack-build
        pen-pak
        exit 0
    }
    ;;

    # dir
    # TODO Ensure this works for yml files beneath
    .github) {
        if test -d "$fn"; then
            fns="$(pen-glob ".github/workflows/*.y*ml")"
            if test -n "$fns"; then
                if pen-yn "vim github workflow?"; then
                    fn="$(printf -- "%s\n" "$fns" | pen-fzf -1)"
                    if test -n "$fn"; then
                        v "$fn"

                        if pen-yn "v job commands?"; then
                            job="$(cat "$fn" | yq -r ".jobs | keys[]" | pen-fzf -1)"
                            if test -n "$job"; then
                                cat "$fn" | yq -r ".jobs.$job" | mnm-cmds | pen-sps v
                                cat "$fn" | yq -r ".jobs.$job.steps[].run // empty" | mnm-cmds | v
                            fi
                        fi
                    fi
                fi
            else
                echo No workflows found, viewing directory in ranger
                ranger .github
            fi

            if test -f ".github/CONTRIBUTING.md" && pen-yn "sp CONTRIBUTING.md?"; then
                sp ".github/CONTRIBUTING.md"
            fi

            # Sometimes, there may be a conf/ini file
            # pen-tm -d nw -args filter iiq "$rp"

            exit 0
        fi
    }
    ;;

    xmonad.hs|xmobarrc) {
        xmonad --recompile && xmonad --restart
        exit 0
    }
    ;;

    pl-flow-*) {
        file_type=json
    }
    ;;

    template) {
        :
    }
    ;;

    *.pl) {
        if pen-yn "prolog?"; then
            swipl-playground "$fp"
            exit $?
        fi
    }
    ;;

    # /etc/mail/sendmail.mc
    *.mc) {
        cd "$dn"
        m4 "$fp"
        exit "$?"
    }
    ;;

    *.cabal) {
        cd "$dn"
        cabal build
        # pet cabal repl
        pet nvt -2 cabal repl
        exit "$?"
    }
    ;;

    # This must come after all specs with .py
    __init__.py|*.py) {
        cd "$dn"
        if test "$dnbn" = "tests"; then
            cd ..
            # Do this in a split because pen-cr may be run from emacs
            # pen-sps sp-ic-x -cd -sn python-pytest-popup
            # This has history
            pen-sps python-eruntest
        else
            set -xv
            it="$(get-interpreter-for-file "$fp")"
            it=pen-python
            case "$it" in
                python3|python3.5) {
                    it="python3.6"
                }
                ;;

                *)
            esac
            zrepl -cm "$it" "$fp"
        fi
        exit 0
    }
    ;;

    *.ipynb) {
        cd "$dn"

        prog="$(qa -t tui-euporie -j gui-jupyter-notebook)"
        case "$prog" in
            tui-euporie) {
                euporie "$fp"
            }
            ;;

            gui-jupyter-notebook) {
                jupyter notebook "$fp"
            }
            ;;
            *)
        esac

        pen-pak
        exit 0
    }
    ;;

    *)
esac

case "$first_line" in
    '{') {
        file_type=json
    }
    ;;

    *)
esac

case "$file_type" in
    pen-pl) {
        # This could be perl or prolog
        # I should use a random forest to find out
        :
    }
    ;;

    *)
esac

case "$file_type" in
    hs) {
        if test "$interactive" = "y"; then
            if pen-yn "use interpreter?"; then
                # zrepl -cm runhaskell "$rp"
                if yn "cd into dir?"; then
                    cd "$dn"
                    zrepl -cm runhaskell "$fn"
                else
                    zrepl -cm runhaskell "$rp"
                fi
                pen-pak
            else
                cd "$td_cr"
                ln -s "$rp"

                # zrepl -cm ghc "./$fn" -o "$mant" \; ./"$mant"
                # Need to use -E to handle the ;.
                zrepl -cm -E "ghc \"./$fn\" -o \"$mant\" ; ./\"$mant\""

                # zrepl -cm -E "( ghc \"./$fn\" -o \"$mant\" && "./$mant" \"\\\$@\" )"
                bash
                # And here I could use my terminal automation script to pretype
                # the command
            fi
        else
            runhaskell "$rp"
        fi
        exit 0
    }
    ;;

    tex) {
        cd "$dn"
        pdflatex "$fn"

        mant="${fn%.*}"

        z "${mant}.pdf"
        exit 0
    }
    ;;

    ansi) {
        less -rS "$rp"
        exit 0
    }
    ;;

    nix) {
        cd "$dn"

        pwd
        basename "$rp"

        test -z "$NIX_PATH" && . $HOME/sh-source/nix.sh

        nix-build "$rp"
        nix-shell

        pen-pak
        exit 0
    }
    ;;

    tf) {
        cd "$dn"
        terraform init
        terraform apply
        pen-pak
        exit 0
    }
    ;;

    deb) {
        dpkg -c "$rp" | pa -vs
        exit 0
    }
    ;;

    docker) {
        cd "$td_cr"

        mkdir -p "shane/$mant"
        cd "shane/$mant"

        git init

        # Symlinks don't work
        # ln -s "$rp" Dockerfile
        cp -a "$rp" Dockerfile

        apply-inplace "awk 1" Dockerfile

        dockerfile_dir="$dn"

        pre_fp="$dockerfile_dir/${mant}.pre"
        if test -f "$pre_fp"; then
            # perl "$pre_fp" || bash "$pre_fp"
            bash "$pre_fp"
        fi

        # cmd ln -s / "$td_cr/root"
        # zcd

        # mkdir -p root
        # mount --bind / root
        # mount | grep root | pen-str field 3 | pen-xa umount

        entry_fp="$dockerfile_dir/${mant}.entrypoint"
        if ! test -f "$entry_fp"; then
            entry_fp=default-entrypoint.sh
        fi

        if test -f "$entry_fp"; then
            {
                cp -a "$entry_fp" entrypoint.sh
                echo "COPY entrypoint.sh /entrypoint.sh"
                echo "ENTRYPOINT [\"/entrypoint.sh\"]"
            } >> Dockerfile
        fi

        setup_fp="$dockerfile_dir/${mant}.setup"
        if ! test -f "$setup_fp"; then
            setup_fp=default-setup.sh
        fi

        if test -f "$setup_fp"; then
            {
                cp -a "$setup_fp" setup.sh
                echo "COPY setup.sh /setup.sh"
                echo "RUN [\"/setup.sh\"]"
            } >> Dockerfile
        fi

        set -xv

        # zcd .

        if pen-yn "Install?"; then
            # docker image build --network=host -t "$(dirslug | sed 's/^-*//' | tr -d '\n';)-$(pwd | hash-crc32 | tr -d '\n'):1.0" .

            # Do not put a hash in the tag
            docker image build --network=host -t "$(dirslug | sed 's/^-*//' | tr -d '\n';):latest" .
        else
            docker image build --network=host .
        fi

        pen-pak
        exit 0
    }
    ;;

    gv|dot) {
        if yn "ASCII?"; then
            use_ascii=y
        fi
        
        if test "$use_ascii" = "y"; then
            if pl "$rp" | grep -q -P '{'; then
                show-dot "$rp"
            else
                cat "$rp" | dot-digraph-ascii-lr
            fi
        else
            if pl "$rp" | grep -q -P '{'; then
                tf_dotgraph="$(0</dev/null tf png | cat || echo /dev/null)"
                cat "$rp" | dot-png "$tf_dotgraph"
            else
                cat "$rp" | dot-digraph-lr
            fi
        fi
        exit 0
    }
    ;;

    pen-pl) {
        eshell perl "$rp"
        exit 0
    }
    ;;

    egg) {
        unzip -l "$rp" | pen-pavs
        pen-pak
        exit 0
    }
    ;;

    # ansi
    ans) {
        cat "$rp" | less -rS
        exit 0
    }
    ;;

    make) {
        make -f "$rp"
        pen-pak
        exit 0
    }
    ;;

    xml) {
        view-xml "$rp"
        exit 0
    }
    ;;

    p6) {
        perl6 "$rp" | pen-pavs
        exit 0
    }
    ;;

    clj) {
        # https://stackoverflow.com/questions/7656523/how-can-i-run-a-clj-clojure-file-i-created

        dn="$(dirname "$rp")"
        cd "$dn"

        # check to see if babshka
        if test -f "$rp" && test "$(head -c 2 "$rp")" = "#!"; then
            cd "$dn"
            perl "$rp"
            pen-pak
            exit $?
        fi

        if dominating-file project.clj | pen-mnm 1>&2 && pen-yn "Use project.clj?"; then
            pen-cr project.clj;
            exit "$?"
        fi

        if ! test "$dn" = "$pwd"; then
            pen-yn "cd to $(cmd "${dn}")?" && cd "$dn"
        fi

        clojure "$rp"
        # clj "$rp"

        pen-pak
        exit 0
    }
    ;;

    tsv|csv) {
        if ! pen-pl "$rp" | grep -q -P '.csv' && test "$file_type" = csv; then
            cat "$rp" | pen-tf tsv | pen-xa fpvd
        elif ! pen-pl "$rp" | grep -q -P '.tsv' && test "$file_type" = tsv; then
            cat "$rp" | pen-tf tsv | pen-xa fpvd
        else
            fpvd "$rp"
        fi
        exit 0
    }
    ;;

    AppImage) {
        cd "$dn"
        chmod a+x "$bn"
        ./"$bn"
        exit 0
    }
    ;;

    groovy) {
        groovy "$rp"
        pen-pak
        exit 0
    }
    ;;

    hy) {
        hy "$rp"
        pen-pak
        exit 0
    }
    ;;

    html) {
        ff "$rp"
        exit 0
    }
    ;;

    cast) {
        asciicast2gif "$rp"
        pen-pak
        exit 0
    }
    ;;

    lfe) {
        lfescript "$rp"
        pen-pak
        exit 0
    }
    ;;

    # postscript
    ps) {
        evince "$rp"
        pen-pak
        exit 0
    }
    ;;

    sln) {
        cd "$dn"
        # apt install mono-devel
        msbuild "$fn"
        pen-pak
        exit 0
    }
    ;;

    cs) {
        cd "$dn"
        csc "$rp"
        mono "${mant}.exe"
        pen-pak
        exit 0
    }
    ;;

    scala) {
        sbt "$rp"
        pen-pak
        exit 0
    }
    ;;

    php) {
        php "$rp"
        pen-pak
        exit 0
    }
    ;;

    mermaid) {
        cd "$dn"
        set -xv
        mermaid-show "$rp"
        pen-pak
        exit 0
    }
    ;;

    prolog) {
        cd "$td_cr"

        fn=$(basename "$rp")
        dn=$(dirname "$rp")
        ext="${fn##*.}"
        mant="${fn%.*}"

        np="${mant}.pl"

        ln -s "$rp" "$np"

        CWD="$td_cr" exec pen-x -zsh -s "gprolog" -c m -s "[$mant]." -c m -a

        gprolog "$rp" | pen-pavs
        exit 0
    }
    ;;

    cpl) {
        # does it have a shebang? (For different problog invocations)
        if test -f "$rp" && test "$(head -c 2 "$rp")" = "#!"; then
            cd "$dn"
            perl "$rp" | pen-pavs
            exit $?
        else
            run-cpl "$rp"
        fi
        exit 0
    }
    ;;

    problog) {
        # does it have a shebang? (For different problog invocations)
        if test -f "$rp" && test "$(head -c 2 "$rp")" = "#!"; then
            cd "$dn"
            perl "$rp" | pen-pavs
            exit $?
        else
            problog "$rp" | pen-pavs
        fi
        exit 0
    }
    ;;

    jsonnet) {
        jsonnet "$rp" | pen-pavs
        # zrepl -cm -E "jsonnet $(cmd "$rp") | pa -vs"
        exit 0
    }
    ;;

    m3u) {
        cvlc "$rp"
        exit 0
    }
    ;;

    fmr) {
        racket "$rp" | pen-tf cpp | pen-xa vs
        exit 0
    }
    ;;

    r|R) {
        Rscript "$rp" "$@"
        pen-pak
        exit 0
    }
    ;;

    el) {
        if test "$(head -c 2 "$rp")" = "#!"; then
            $rp
        else
            emacs-script "$rp"
        fi
        pen-pak
        exit 0
    }
    ;;

    xsh) {
        xsh "$rp"
        pen-pak
        exit 0
    }
    ;;

    #go) {
    #    cd "$td_cr"
    #    ln -s "$rp"
    #    go build "$rp" 2>&1 | pen-mnm | nvpager

    #    fn=$(basename "$rp")
    #    ext="${fn##*.}"
    #    mant="${mant%.*}"

    #    ./"$mant"
    #    pen-pak
    #    exit 0
    #}
    #;;

    go) {
        # This is not good enough
        # Requires rp to have .go extension.

        # This method is good enough
        # $HOME/scripts/go-re-grep
        # $HOME/scripts/re-grep.go

        # go run "$rp"
        zrepl -cm go run "$rp" --

        pen-pak
        exit 0
    }
    ;;

    lisp) {
        cd "$dn"
        clisp "$rp"
        pen-pak
        exit 0
    }
    ;;

    md) {
        printf -- "%s\n" "$rp"
        ans="$(qa -. edit \
                  -o any2org \
                  -v vimglow \
                  -g glow)"

        case "$ans" in
            edit) { vs $rp; } ;;
            any2org) { any2org "$rp"; } ;;
            glow) { glow -f "$rp"; } ;;
            vimglow) { vimglow "$rp"; } ;;
            *) ;;
        esac

        # any2org "$rp"
        # pen-pak
        exit 0
    }
    ;;

    es) {
        ess "$rp"
        pen-pak
        exit 0
    }
    ;;

    js) {
        node "$rp" 2>&1 | pen-pavs
        # pen-pak
        exit 0
    }
    ;;

    purs) {
        node "$rp" 2>&1 | pen-pavs
        # pen-pak
        exit 0
    }
    ;;

    st) {
        nvt -E "gst \"$rp\"; pen-pak"
        exit 0
    }
    ;;

    plantuml|uml) {
        cd "$dn"
        # ni pen-cr plantuml
        if pen-yn "ascii?"; then
            cat "$rp" | plantuml | v
        else
            cat "$rp" | plantuml -w -svg | pen-tf svg | pen-xa win ie
        fi
        exit 0
    }
    ;;

    ttyrec) {
        ttyplay "$rp"
        pen-pak
        exit 0
    }
    ;;

    scss) {
        sass "$rp" | pen-pavs
        exit 0
    }
    ;;

    rkt) {
        echo racket "$rp"
        # nvt page racket "$rp"

        nvt -E "racket \"$rp\"; pen-pak"

        # pen-pak
        exit 0
    }
    ;;

    cabal) {
        cd "$dn"
        set -xv

        # cabal configure
        # cabal build

        cabal v2-build
        pen-pak
        exit 0
    }
    ;;

    ts|type) {
        cd "$td_cr"
        ext="${fn##*.}"
        mant="${fn%.*}"

        # The extension is sometimes (incorrectly) type
        ln -s "$rp" "${mant}.ts"

        tsc "${mant}.ts"
        pen-yn "Start vd?" && vd "${mant}.ts" "${mant}.js"
        pen-yn "Run?" && ts-node "${mant}.ts"
        exit 0
    }
    ;;

    rs) {
        cd "$td_cr"
        ln -s "$rp"
        # rustc "./$fn"
        rustc -g "./$fn"
        cd_run "$cd_cr"
        # And here I could use my terminal automation script to pretype
        # the command
        exit 0
    }
    ;;

    c) {
        cd "$td_cr"
        ln -s "$rp"
        #CWD="$td_cr" zrepl -cm gcc -g "./$fn" -lm -o "$mant" \; "./$fn"
        CWD="$td_cr" zrepl -cm -E "gcc -g \"./$fn\" -lm -o \"$mant\"; ./$mant"

        # cd_run "$cd_cr"
        # And here I could use my terminal automation script to pretype
        # the command
        exit 0
    }
    ;;

    rb) {
        cd "$td_cr"
        # ruby "$rp"

        # Load into an interpreter. That's more interesting
        irb -r "$rp"
        exit 0
    }
    ;;

    cairo) {
        cd "$td_cr"
        cairo-compile "$rp" --output ./test_compiled.json
        cairo-run --program=./test_compiled.json --print_output --print_info --relocate_prints
        pen-pak
        exit 0
    }
    ;;

    scrbl) {
        cd "$td_cr"
        scribble --pdf "$rp"
        scribble --html "$rp"
        if test -f "${mant}.html" && pen-yn "eww?"; then
            eww "${mant}.html"
        else
            cd_ls "$cd_cr"
        fi
        exit 0
    }
    ;;

    kt) {
        . $HOME/sh-source/sdkman.sh
        set -x

        cd "$dn"

        kotlinc **/*.kt
        kotlin "$mant"
        pen-pak

        exit 0
    }
    ;;

    java) {
        cd "$td_cr"
        ln -s "$rp"
        javac "./$fn"
        java "$mant"
        pen-pak
        exit 0
    }
    ;;

    cpp) {
        cd "$td_cr"
        ln -s "$rp"
        g++ -g -march=native -lm -pthread "./$fn" -o "$mant"
        cd_run "$cd_cr"
        # And here I could use my terminal automation script to pretype
        # the command
        exit 0
    }
    ;;

    py) {
        # I need python version detection
        cd "$dn"

        if pen-pl "$rp" | grep -q -P 'keras-idiomatic-programmer'; then
            conda-run python "$rp" 2>&1
        else
            pybin="$(get-python-interp "$rp")"
            : ${pybin:="python$(vermin "$rp")"}
            : ${pybin:="pen-python"}
            if test "$pybin" = "python3" ||
                test "$pybin" = "python3.5" ||
                test "$pybin" = "python3.6" ||
                test "$pybin" = "python3.7"; then
                # This is so ptpython works
                # pybin=python3.8
                pybin=pen-python
            fi
            "$pybin" "$rp" 2>&1
        fi

        echo "exit: $?" 1>&2
        pen-pak -k c
        exit 0
    }
    ;;

    [0-9]) {
        troff2man "$rp"
        exit 0
    }
    ;;

    toml) {
        filter toiq "$rp" 2>&1
        pen-pak -k c
        exit 0
    }
    ;;

    ini) {
        pen-tm -d nw -args filter iiq "$rp"
        exit 0
    }
    ;;

    prompt) {
        prog="$(qa -. edit -o openai-complete -p pen-pf -s symlink -c compile-yaml -q yiq)"
        case "$prog" in
            symlink) {
                (
                    cd "$SCRIPTS"
                    if ! test -f "$mant"; then
                        ln -s openai-complete "$mant"
                    fi
                )
                nw zrepl "$mant"
            }
            ;;

            openai-complete) {
                nw zrepl openai-complete "$fp"
            }
            ;;

            pen-pf) {
                titleslug="$(cat "$fp" | yq -r ".title" | slugify)"

                pf_name="pen-pf-$titleslug"

                cd "$SCRIPTS"

                ln -sf sp-ic "$pf_name"

                # nw zrepl "$pf_name"

                nw "$pf_name"
            }
            ;;

            compile-yaml|yiq) {
                pen-tm -d nw -args filter "$prog" "$fp"
            }
            ;;

            edit) {
                vim +/"yml|yaml|prompt" "$SCRIPTS/pen-cr"
            }
            ;;

            *)
        esac

        # I need python version detection

        # filter yiq "$rp" 2>&1
        # pen-pak -k c
        exit 0
    }
    ;;

    yml|yaml) {
        prog="$(qa -. edit -c compile-yaml -q yiq)"
        case "$prog" in
            compile-yaml|yiq) {
                pen-tm -d nw -args filter "$prog" "$fp"
            }
            ;;

            edit) {
                vim +/"yml|yaml" "$SCRIPTS/pen-cr"
            }
            ;;

            *)
        esac

        # I need python version detection

        # filter yiq "$rp" 2>&1
        # pen-pak -k c
        exit 0
    }
    ;;

    json) {
        pen-tm -d nw -args jiq "$rp"
        exit 0
    }
    ;;

    ti) {
        tic "$rp"
        exit $?
    }
    ;;

    apl) {
        apl -f "$rp"
        exit $?
    }
    ;;

    org) {
        cd "$dn"

        prog="$(qa -. edit -p org2pdf -h org2html)"

        fn=$(basename -- "$fp")
        dn=$(dirname "$fp")
        ext="${fn##*.}"
        mant="${fn%.*}"

        case "$prog" in
            edit) { vs $0; } ;;

            org2pdf) {
                "$prog" "$fn"

                z "${mant}.pdf"
            }
            ;;

            org2html) {
                # cmd "$prog" "$fn" | tv
                "$prog" "$fn"

                ff "${mant}.html"
            }
            ;;

            *)
        esac

        exit $?
   }
    ;;

    kotlin|kts) {
        np="${td_cr}/script.kts"
        ln -s "$rp" "$np"
        kotlinc -script "$np" -- $@
        exit $?
    }
    ;;

    template) {
        :
    }
    ;;

    sh) {
        if test "$(head -c 2 "$rp")" = "#!"; then
            perl "$rp"
            # nvc -w -2 $rp
            pen-pak
            exit $?
        else
            set -xv
            bash "$rp"
        fi
        pen-pak
        exit 0
    }
    ;;

    *) { # does it have a shebang?
        if test -f "$rp"; then
            if test "$(head -c 2 "$rp")" = "#!"; then
                cd "$dn"
                perl "$rp"
                # nvc -w -2 $rp
                pen-pak
                exit $?
            fi
        elif test -d "$rp"; then
            :
        fi
    }
    ;;

esac

pen-pl "no handler for $arg1" | less

exit 1
