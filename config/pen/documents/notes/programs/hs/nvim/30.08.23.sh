cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn\\n  (setq mode-line-format nil)\\n  (setq-default mode-line-format nil)\\n  (define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n  (define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n  (defun e/cat (&optional path input no_unminimise)\\n    \\\"cat out a file, or write to one\\\"\\n    (if (not no_unminimise)\\n        (setq path (pen-umn path)))\\n    (cond\\n     ((and (test-f path) input) (write-to-file input path))\\n     ((test-f path) (with-temp-buffer\\n                      (insert-file-contents path)\\n                      (buffer-string)))\\n     (t (error \\\"Bad path\\\"))))\\n \\n  (defun str (thing)\\n    \\\"Converts object or string to an unformatted string.\\\"\\n \\n    (if thing\\n        (if (stringp thing)\\n            (substring-no-properties thing)\\n          (progn\\n            (setq thing (format \\\"%s\\\" thing))\\n            (set-text-properties 0 (length thing) nil thing)\\n            thing))\\n      \\\"\\\"))\\n \\n  (defvar new-buffer-hooks '\\\''())\\n \\n  (defun my-new-buffer-frame (&optional contents bufname mode nodisplay)\\n    \\\"Create a new frame with a new empty buffer.\\\"\\n    (interactive)\\n    (if (not bufname)\\n        (setq bufname \\\"*untitled*\\\"))\\n    (let ((buffer (generate-new-buffer bufname)))\\n      (set-buffer-major-mode buffer)\\n      ;; (display-buffer buffer '\\\''(display-buffer-pop-up-frame . nil))\\n      (if (not nodisplay)\\n          (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n      (with-current-buffer buffer\\n        (if contents (insert (str contents)))\\n        (beginning-of-buffer)\\n        (run-hooks '\\\''new-buffer-hooks))\\n      buffer))\\n  (defalias '\\\''new-buffer-from-string '\\\''my-new-buffer-frame)\\n  (defalias '\\\''nbfs '\\\''my-new-buffer-frame)\\n\\n  (tool-bar-mode -1)\\n  (menu-bar-mode -1)\\n  (with-current-buffer (nbfs (e/cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n    (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n    (read-only-mode 1))\\n  (message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn\\n  (setq mode-line-format nil)\\n  (setq-default mode-line-format nil)\\n  (define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n  (define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n  (defun e/cat (&optional path input)\\n    \\\"cat out a file, or write to one\\\"\\n    (cond\\n     ((and (test-f path) input) (write-to-file input path))\\n     ((test-f path) (with-temp-buffer\\n                      (insert-file-contents path)\\n                      (buffer-string)))\\n     (t (error \\\"Bad path\\\"))))\\n \\n  (defun str (thing)\\n    \\\"Converts object or string to an unformatted string.\\\"\\n \\n    (if thing\\n        (if (stringp thing)\\n            (substring-no-properties thing)\\n          (progn\\n            (setq thing (format \\\"%s\\\" thing))\\n            (set-text-properties 0 (length thing) nil thing)\\n            thing))\\n      \\\"\\\"))\\n \\n  (defvar new-buffer-hooks '\\\''())\\n \\n  (defun my-new-buffer-frame (&optional contents bufname mode nodisplay)\\n    \\\"Create a new frame with a new empty buffer.\\\"\\n    (interactive)\\n    (if (not bufname)\\n        (setq bufname \\\"*untitled*\\\"))\\n    (let ((buffer (generate-new-buffer bufname)))\\n      (set-buffer-major-mode buffer)\\n      ;; (display-buffer buffer '\\\''(display-buffer-pop-up-frame . nil))\\n      (if (not nodisplay)\\n          (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n      (with-current-buffer buffer\\n        (if contents (insert (str contents)))\\n        (beginning-of-buffer)\\n        (run-hooks '\\\''new-buffer-hooks))\\n      buffer))\\n  (defalias '\\\''new-buffer-from-string '\\\''my-new-buffer-frame)\\n  (defalias '\\\''nbfs '\\\''my-new-buffer-frame)\\n\\n  (tool-bar-mode -1)\\n  (menu-bar-mode -1)\\n  (with-current-buffer (nbfs (e/cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n    (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n    (read-only-mode 1))\\n  (message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn\\n\\n  (defalias '\\\''test-z '\\\''string-empty-p)\\n  (defalias '\\\''test-f '\\\''file-exists-p)\\n \\n  (defun test-n (s)\\n    (not (string-empty-p s)))\\n\\n  (setq mode-line-format nil)\\n  (setq-default mode-line-format nil)\\n  (define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n  (define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n  (define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n  (defun e/cat (&optional path input)\\n    \\\"cat out a file, or write to one\\\"\\n    (cond\\n     ((and (test-f path) input) (write-to-file input path))\\n     ((test-f path) (with-temp-buffer\\n                      (insert-file-contents path)\\n                      (buffer-string)))\\n     (t (error \\\"Bad path\\\"))))\\n \\n  (defun str (thing)\\n    \\\"Converts object or string to an unformatted string.\\\"\\n \\n    (if thing\\n        (if (stringp thing)\\n            (substring-no-properties thing)\\n          (progn\\n            (setq thing (format \\\"%s\\\" thing))\\n            (set-text-properties 0 (length thing) nil thing)\\n            thing))\\n      \\\"\\\"))\\n \\n  (defvar new-buffer-hooks '\\\''())\\n \\n  (defun my-new-buffer-frame (&optional contents bufname mode nodisplay)\\n    \\\"Create a new frame with a new empty buffer.\\\"\\n    (interactive)\\n    (if (not bufname)\\n        (setq bufname \\\"*untitled*\\\"))\\n    (let ((buffer (generate-new-buffer bufname)))\\n      (set-buffer-major-mode buffer)\\n      ;; (display-buffer buffer '\\\''(display-buffer-pop-up-frame . nil))\\n      (if (not nodisplay)\\n          (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n      (with-current-buffer buffer\\n        (if contents (insert (str contents)))\\n        (beginning-of-buffer)\\n        (run-hooks '\\\''new-buffer-hooks))\\n      buffer))\\n  (defalias '\\\''new-buffer-from-string '\\\''my-new-buffer-frame)\\n  (defalias '\\\''nbfs '\\\''my-new-buffer-frame)\\n\\n  (tool-bar-mode -1)\\n  (menu-bar-mode -1)\\n  (with-current-buffer (nbfs (e/cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n    (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n    (read-only-mode 1))\\n  (message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn (defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun e/cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input) (write-to-file input path))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun my-new-buffer-frame (&optional contents bufname mode nodisplay)\\n  \\\"Create a new frame with a new empty buffer.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    ;; (display-buffer buffer '\\\''(display-buffer-pop-up-frame . nil))\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents (insert (str contents)))\\n      (beginning-of-buffer)\\n      (run-hooks '\\\''new-buffer-hooks))\\n    buffer))\\n(defalias '\\\''new-buffer-from-string '\\\''my-new-buffer-frame)\\n(defalias '\\\''nbfs '\\\''my-new-buffer-frame)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (e/cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn (defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun e/cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input) (write-to-file input path))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun my-new-buffer-frame (&optional contents bufname mode nodisplay)\\n  \\\"Create a new frame with a new empty buffer.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    ;; (display-buffer buffer '\\\''(display-buffer-pop-up-frame . nil))\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents (insert (str contents)))\\n      (beginning-of-buffer)\\n      (run-hooks '\\\''new-buffer-hooks))\\n    buffer))\\n(defalias '\\\''new-buffer-from-string '\\\''my-new-buffer-frame)\\n(defalias '\\\''nbfs '\\\''my-new-buffer-frame)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (e/cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn (defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun e/cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input) (write-to-file input path))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun my-new-buffer-frame (&optional contents bufname mode nodisplay)\\n  \\\"Create a new frame with a new empty buffer.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    ;; (display-buffer buffer '\\\''(display-buffer-pop-up-frame . nil))\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents (insert (str contents)))\\n      (beginning-of-buffer)\\n      (run-hooks '\\\''new-buffer-hooks))\\n    buffer))\\n(defalias '\\\''new-buffer-from-string '\\\''my-new-buffer-frame)\\n(defalias '\\\''nbfs '\\\''my-new-buffer-frame)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (e/cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/src;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_aa985d38dd.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempInT60vW.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/src;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_3a18b72d5a.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempTtJUg28.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_15bab8d94a.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempx33ip1e.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_0cf3e161de.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempfjgLtqo.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_870367fa7e.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempKQbKL7M.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_5ef239a9f0.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_templd0qG77.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_d28d250e43.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_temppl2mV7Y.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_ad874eb2e6.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempZX3p8sV.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_0b3a27285c.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempRcOeT3Q.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn (defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun e/cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input) (write-to-file input path))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (e/cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (f-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (lam-var-value-maybe '\\\''lam-sh-update)\\n               (>= (prefix-numeric-value current-global-prefix-arg) 16))\\n              (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (f-delete output_tf)\\n                   (f-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (f-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (lam-var-value-maybe '\\\''lam-sh-update)\\n               (>= (prefix-numeric-value current-global-prefix-arg) 16))\\n              (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (f-delete output_tf)\\n                   (f-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (f-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (lam-var-value-maybe '\\\''lam-sh-update)\\n               (>= (prefix-numeric-value current-global-prefix-arg) 16))\\n              (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (f-delete output_tf)\\n                   (f-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (f-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (lam-var-value-maybe '\\\''lam-sh-update)\\n               (>= (prefix-numeric-value current-global-prefix-arg) 16))\\n              (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (f-delete output_tf)\\n                   (f-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n(load \\\"/root/.emacs.d/elpa/f-20210624.1103/f.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (f-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (lam-var-value-maybe '\\\''lam-sh-update)\\n               (>= (prefix-numeric-value current-global-prefix-arg) 16))\\n              (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (f-delete output_tf)\\n                   (f-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (lam-var-value-maybe '\\\''lam-sh-update)\\n               (>= (prefix-numeric-value current-global-prefix-arg) 16))\\n              (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (lam-var-value-maybe '\\\''lam-sh-update)\\n               (>= (prefix-numeric-value current-global-prefix-arg) 16))\\n              (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (lam-q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun lam-var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun lam-get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun lam-sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer lam-chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (lam-get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''lam-sh-update)\\n                    (eval '\\\''lam-sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (lam-q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (lam-q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (lam-q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (lam-q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (lam-q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if lam-chomp\\n              (setq output (lam-chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun lam-snc (shell-cmd &optional stdin dir)\\n  \\\"sn lam-chomp\\\"\\n  (lam-chomp (lam-sn shell-cmd stdin dir)))\\n\\n(defun lam-chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun lam-q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (lam-snc (concat \\\"mktemp -p /tmp \\\" (lam-q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun new-buffer-from-string (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n(defalias '\\\''nbfs '\\\''new-buffer-from-string)\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_376a8fb9b7.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempny5t7MM.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_af3d822ab4.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_temp0unlQmJ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_b5568b0f86.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempU2jEfdD.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_ac6571b9ee.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempP459niM.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_1a2fb6603f.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempHqmGZyQ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_22980a52e1.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempcJOyLsZ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_54d5bc1f4e.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempMQV6Ecx.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_114944b785.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempYv4s85f.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_b64df96ee0.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempu04Xbs4.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_27b32e8f2a.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempQTOydhi.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_6c2ab54b5a.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempPS1r6m0.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_0ae5a246bf.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempsfxFDIJ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_e3fef0da8b.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempCxxDxt3.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_fe6025cb01.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempvd6j8qv.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_26d7ea0f3a.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_temp6LolXto.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_731053897e.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempHnEGEgS.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_924b4ee0ca.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempsjM9RiO.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_6e2fb956a3.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempBeyz17y.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_9b76f52493.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempfxDk2sj.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_49ad56c574.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempysbLYC7.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_a53384cd59.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempobORlOJ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_1567a45443.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempFhJFakQ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_c6eb7169ce.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempd2cBXw4.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_f283f21aa3.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempS6FsyGZ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_6c37b711e2.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempGFMMYcp.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_7d6d9ad829.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_temp9a90o3E.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_e0a616c120.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempfiEnIJ8.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  cat '/tmp/tf_temp_0916d80d44.txt' | 'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  cat '/tmp/tf_temp_c7560768b0.txt' | 'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  cat '/tmp/tf_temp_682a2faaab.txt' | 'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  cat '/tmp/tf_temp_bfd1183643.txt' | 'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  cat '/tmp/tf_temp_72d14ae444.txt' | 'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (find-file \\\"/tmp/tf_temp_2cc91d6110.txt\\\")\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (find-file \\\"/tmp/tf_temp_8bad2f9f04.txt\\\")\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' '/tmp/KKbv6F0ofY'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_8c1ddefab1.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempSSh0i44.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_7059f47239.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_temp2Q2VIIJ.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_fb7dfcb9eb.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempdanlx2p.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_0c3d12f057.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempxtr1s05.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/scripts;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_78e8bf4616.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempOBcJNcO.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (find-file \\\"/tmp/tf_temp_dd4e02c7cc.txt\\\")\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (find-file \\\"/tmp/tf_temp_c9a890138f.txt\\\")\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(load \\\"/root/.emacs.d/host/pen.el/src/pen-translation-map.el\\\")\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(defmacro df (name &rest body)\\n  \\\"Named interactive lambda with no arguments\\\"\\n  \\\`(defun ,name ()\\n     (interactive)\\n     ,@body))\\n\\n(load \\\"/root/.emacs.d/host/pen.el/src/pen-translation-map.el\\\")\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'emacs' '-nw' '-q' '--eval' '(progn ;; Used by:\\n;; /root/.emacs.d/host/pen.el/scripts/lambda-emacs\\n\\n(defmacro df (name &rest body)\\n  \\\"Named interactive lambda with no arguments\\\"\\n  \\\`(defun ,name ()\\n     (interactive)\\n     ,@body))\\n\\n(load \\\"/root/.emacs.d/host/pen.el/src/pen-translation-map.el\\\")\\n(define-key global-map (kbd \\\"C-h\\\") (kbd \\\"DEL\\\"))\\n\\n(load \\\"/root/.emacs.d/elpa/shut-up-20210403.1249/shut-up.el\\\")\\n\\n(defmacro defset (symbol value &optional documentation)\\n  \\\"Instead of doing a defvar and a setq, do this. [[http://ergoemacs.org/emacs/elisp_defvar_problem.html][ergoemacs.org/emacs/elisp_defvar_problem.html]]\\\"\\n\\n  \\\`(progn (defvar ,symbol ,documentation)\\n          (setq ,symbol ,value)))\\n\\n(defun sh-construct-exports (varval-tuples)\\n  (concat\\n   \\\"export \\\"\\n   (sh-construct-envs varval-tuples)))\\n\\n(defun -filter (pred list)\\n  \\\"Return a new list of the items in LIST for which PRED returns non-nil.\\n\\\"\\n  (let\\n      (result)\\n    (let\\n        ((list list)\\n         (i 0)\\n         it it-index)\\n      (ignore it it-index)\\n      (while list\\n        (setq it\\n              (car-safe\\n               (prog1 list\\n                 (setq list\\n                       (cdr list))))\\n              it-index i i\\n              (1+ i))\\n        (if\\n            (funcall pred it)\\n            (progn\\n              (setq result\\n                    (cons it result))))))\\n    (nreverse result)))\\n\\n(defun s-join (separator strings)\\n  \\\"Join all the strings in STRINGS with SEPARATOR in between.\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (mapconcat '\\\''identity strings separator))\\n\\n(defun sh-construct-envs (varval-tuples)\\n  (s-join\\n   \\\" \\\"\\n   (-filter\\n    '\\\''identity\\n    (cl-loop for tp in varval-tuples\\n             collect\\n             (let ((lhs (car tp))\\n                   (rhs (cadr tp)))\\n               (if tp\\n                   (concat\\n                    lhs\\n                    \\\"=\\\"\\n                    (if rhs\\n                        (if (booleanp rhs)\\n                            \\\"y\\\"\\n                          (q rhs))\\n                      \\\"\\\"))))))))\\n\\n(defun var-value-maybe (sym)\\n  \\\"This function gets the value of the symbol\\\"\\n  (cond\\n   ((symbolp sym) (if (variable-p sym)\\n                      (eval sym)))\\n   ((numberp sym) sym)\\n   ((stringp sym) sym)\\n   (t sym)))\\n\\n(defmacro shut-up-c (&rest body)\\n  \\\"This works for c functions where shut-up does not.\\\"\\n  \\\`(progn (let* ((inhibit-message t))\\n            ,@body)))\\n\\n(defun cwd ()\\n  \\\"Gets the current working directory\\\"\\n  (interactive)\\n  (let ((c (shut-up-c (pwd))))\\n    (if c\\n        (expand-file-name (substring c 10))\\n      default-directory)))\\n\\n(defun s-blank? (s)\\n  \\\"Is S nil or the empty string?\\\"\\n  (declare (pure t) (side-effect-free t))\\n  (or (null s) (string= \\\"\\\" s)))\\n\\n(defun get-dir (&optional dont-clean-tramp)\\n  \\\"Gets the directory of the current buffer'\\\''s file. But this could be different from emacs'\\\'' working directory.\\nTakes into account the current file name.\\\"\\n  (shut-up-c\\n   (let* ((filedir (if buffer-file-name\\n                       (file-name-directory buffer-file-name)\\n                     (file-name-directory (cwd))))\\n          (dir\\n           (if (s-blank? filedir)\\n               (cwd)\\n             filedir)))\\n     dir)))\\n\\n(defun file-delete (path &optional force)\\n  \\\"Delete PATH, which can be file or directory.\\\"\\n  (if (or (file-regular-p path) (not (not (file-symlink-p path))))\\n      (delete-file path)\\n    (delete-directory path force)))\\n\\n(defun variable-p (s)\\n  (and (not (eq s nil))\\n       (boundp s)))\\n\\n(defun sn (shell-cmd &optional stdin dir exit_code_var detach b_no_unminimise output_buffer b_unbuffer chomp b_output-return-code)\\n  \\\"Runs command in shell and return the result.\\nThis appears to strip ansi codes.\\n\\\(sh) does not.\\nThis also exports PEN_PROMPTS_DIR, so lm-complete knows where to find the .prompt files\\\"\\n  (interactive)\\n\\n  (let ((output)\\n        (output_tf)\\n        (input_tf))\\n    (if (not shell-cmd)\\n        (setq shell-cmd \\\"false\\\"))\\n\\n    ;; sn must never contain a tramp path\\n    (if (not dir)\\n        (let ((cand-dir (get-dir)))\\n          (if (file-directory-p cand-dir)\\n              (setq dir cand-dir)\\n            (setq dir \\\"/\\\"))))\\n\\n    ;; If the dir is a tramp path, just use root\\n    (if (string-match \\\"/[^:]+:\\\" dir)\\n        (setq dir \\\"/\\\"))\\n\\n    (let ((default-directory dir))\\n      (if b_unbuffer\\n          (setq shell-cmd (concat \\\"unbuffer -p \\\" shell-cmd)))\\n\\n      (if (or (or\\n               (and (variable-p '\\\''sh-update)\\n                    (eval '\\\''sh-update))\\n               (>= (prefix-numeric-value current-prefix-arg) 16)))\\n          (setq shell-cmd (concat \\\"export UPDATE=y; \\\" shell-cmd)))\\n\\n      (setq shell-cmd (concat \\\". /root/.shellrc; \\\" shell-cmd))\\n\\n      (setq output_tf (make-temp-file \\\"elisp_bash\\\"))\\n      (setq tf_exit_code (make-temp-file \\\"elisp_bash_exit_code\\\"))\\n\\n      (let ((exps\\n             (sh-construct-exports\\n              (-filter '\\\''identity\\n                       (list (list \\\"DISPLAY\\\" \\\":0\\\")\\n                             (list \\\"PATH\\\" (getenv \\\"PATH\\\"))\\n                             (list \\\"TMUX\\\" \\\"\\\")\\n                             (list \\\"TMUX_PANE\\\" \\\"\\\"))))))\\n\\n        (if (and detach\\n                 stdin)\\n            (progn\\n              (setq input_tf (make-temp-file \\\"elisp_bash_input\\\"))\\n              (cat input_tf stdin)\\n              (setq shell-cmd (concat \\\"exec < <(cat \\\" (q input_tf) \\\"); \\\" shell-cmd))))\\n\\n        (if (not (string-match \\\"[&;]$\\\" shell-cmd))\\n            (setq shell-cmd (concat shell-cmd \\\";\\\")))\\n\\n        (if (and detach\\n                 stdin)\\n            (setq final_cmd (concat final_cmd \\\" rm -f \\\" (q input_tf) \\\";\\\")))\\n\\n        ;; I need a log level here. This will be too verbose\\n        (setq final_cmd (concat exps \\\"; ( cd \\\" (q dir) \\\"; \\\" shell-cmd \\\" echo -n 0 > \\\" tf_exit_code \\\" ) > \\\" output_tf)))\\n\\n      (if detach\\n          (if stdin\\n              (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; bash -c \\\" (q final_cmd) \\\" &\\\"))\\n            (setq final_cmd (concat \\\"trap '\\\'''\\\'' HUP; unbuffer bash -c \\\" (q final_cmd) \\\" &\\\"))))\\n\\n      (shut-up-c\\n       (if (or\\n            (not stdin)\\n            detach)\\n           (shell-command final_cmd output_buffer \\\"*pen-sn-stderr*\\\")\\n         (with-temp-buffer\\n           (insert stdin)\\n           (shell-command-on-region (point-min) (point-max) final_cmd output_buffer nil \\\"*pen-sn-stderr*\\\"))))\\n\\n      (if detach\\n          t\\n        (progn\\n          (setq output (cat output_tf))\\n          (if chomp\\n              (setq output (chomp output)))\\n          (progn\\n            (defset b_exit_code (cat tf_exit_code)))\\n\\n          (if b_output-return-code\\n              (setq output (str b_exit_code)))\\n          (ignore-errors\\n            (progn (file-delete output_tf)\\n                   (file-delete tf_exit_code)))\\n          output)))))\\n\\n(defun snc (shell-cmd &optional stdin dir)\\n  \\\"sn chomp\\\"\\n  (chomp (sn shell-cmd stdin dir)))\\n\\n(defun chomp (str)\\n  \\\"Chomp (remove tailing newline from) STR.\\\"\\n  (replace-regexp-in-string \\\"\\\n\\\\\\'\\\''\\\" \\\"\\\" str))\\n\\n(defun prin1-to-string-safe (s)\\n  (if s\\n      (prin1-to-string s)\\n    \\\"\\\\\\\\\"\\\\\\\\\"\\\"))\\n\\n(defun q (&rest strings)\\n  (let ((print-escape-newlines t))\\n    (mapconcat '\\\''identity (mapcar '\\\''prin1-to-string-safe strings) \\\" \\\")))\\n\\n(defun string-empty-or-nil-p (s)\\n  (or (not s)\\n      (string-empty-p s)))\\n\\n(defun string-not-empty-nor-nil-p (s)\\n  (not (string-empty-or-nil-p s)))\\n\\n(defun sor (&rest ss)\\n  \\\"Get the first non-nil string.\\\"\\n  (let ((result))\\n    (catch '\\\''bbb\\n      (dolist (p ss)\\n        (if (string-not-empty-nor-nil-p p)\\n            (progn\\n              (setq result p)\\n              (throw '\\\''bbb result)))))\\n    result))\\n\\n(defun pen-tf (template &optional input ext)\\n  \\\"Create a temporary file.\\\"\\n  (setq ext (or ext \\\"txt\\\"))\\n  (let ((fp (snc (concat \\\"mktemp -p /tmp \\\" (q (concat \\\"XXXX\\\" (slugify template) \\\".\\\" ext))))))\\n    (if (and (sor fp)\\n             (sor input))\\n        (shut-up (cat fp input)))\\n    fp))\\n\\n(defalias '\\\''test-z '\\\''string-empty-p)\\n(defalias '\\\''test-f '\\\''file-exists-p)\\n\\n(defun test-n (s)\\n  (not (string-empty-p s)))\\n\\n(setq mode-line-format nil)\\n(setq-default mode-line-format nil)\\n(define-key global-map (kbd \\\"q\\\") #'\\\''save-buffers-kill-terminal)\\n\\n(define-key key-translation-map (kbd \\\"C-M-k\\\") (kbd \\\"<up>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-j\\\") (kbd \\\"<down>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-h\\\") (kbd \\\"<left>\\\"))\\n(define-key key-translation-map (kbd \\\"C-M-l\\\") (kbd \\\"<right>\\\"))\\n\\n(defun cat (&optional path input)\\n  \\\"cat out a file, or write to one\\\"\\n  (cond\\n   ((and (test-f path) input)\\n    (ignore-errors (with-temp-buffer\\n                   (insert input)\\n                   (delete-file path)\\n                   (write-file path))))\\n   ((test-f path) (with-temp-buffer\\n                    (insert-file-contents path)\\n                    (buffer-string)))\\n   (t (error \\\"Bad path\\\"))))\\n\\n(defun str (thing)\\n  \\\"Converts object or string to an unformatted string.\\\"\\n\\n  (if thing\\n      (if (stringp thing)\\n          (substring-no-properties thing)\\n        (progn\\n          (setq thing (format \\\"%s\\\" thing))\\n          (set-text-properties 0 (length thing) nil thing)\\n          thing))\\n    \\\"\\\"))\\n\\n(defvar new-buffer-hooks '\\\''())\\n\\n(defun nbfs (&optional contents bufname mode nodisplay)\\n  \\\"Create a new untitled buffer from a string.\\\"\\n  (interactive)\\n  (if (not bufname)\\n      (setq bufname \\\"*untitled*\\\"))\\n  (let ((buffer (generate-new-buffer bufname)))\\n    (set-buffer-major-mode buffer)\\n    (if (not nodisplay)\\n        (display-buffer buffer '\\\''(display-buffer-same-window . nil)))\\n    (with-current-buffer buffer\\n      (if contents\\n          (if (stringp contents)\\n              (insert contents)\\n            (insert (str contents))))\\n      (beginning-of-buffer)\\n      (if mode (funcall mode))\\n      ;; This may not be available\\n      (ignore-errors (pen-add-ink-change-hook)))\\n    buffer))\\n\\n(tool-bar-mode -1)\\n(menu-bar-mode -1)\\n(with-current-buffer (nbfs (cat \\\"/root/.emacs.d/host/pen.el/scripts/lambda-emacs\\\"))\\n  (local-set-key \\\"q\\\" '\\\''save-buffers-kill-terminal)\\n  (read-only-mode 1))\\n(message \\\"\\\"))'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_7eb80d1fea.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempg68p1D5.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/elpa/lsp-ui-20211009.1545;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' 'lsp-ui.el'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" 'sp' 'directories.org'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/elpa/lsp-ui-20211009.1545;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' '-m' 'lsp-ui.el'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/elpa/lsp-ui-20211009.1545;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' '-m' 'lsp-ui.el'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" 'hide-cursor' 'tmux-choose-window' '-t' '1693383857'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/src;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' '-m' 'pen-ink.el'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/src;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' '-m' 'pen-ink.el'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/src;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' '-m' '-Y' 'disabled' 'pen-ink.el'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/.emacs.d/host/pen.el/src;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" '/bin/nano' '-m' 'pen-ink.el'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" 'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_9096ffa94d.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_4edc502ef9.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" \\\"zsh\\\"\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root;  "nvim" "#" "<==" "zsh"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'v'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'bash'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'v'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'v'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'v'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_3a18640908.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_0f9b1d50f0.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_1133164fcb.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'v'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_35cdf9eed0.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_ad07d4f04b.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_8cf8956580.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_c061323d92.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_1779292131.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_aca6522033.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_e431a60909.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_36fc7df38c.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempacipFm2.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_78705728c0.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempHqWUg1e.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_b2359d86e0.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  'pen-v' '-c' 'syntax off | set nohlsearch | set t_Co=0 | set foldcolumn=0 ls=0 | call EasyMotion#WB(0,2) | q\!' '/tmp/tf_temp_2a7bdfd902.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  tmux attach -t 20607b76-4724-11ee-bad5-9b8f318d80d4:\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "bash"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\"export TERM=screen-2color;  tmux attach -t 2992af20-4724-11ee-9178-1b201f528e9d:\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "bash"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_81199b5ac5.txt' | 'fzf' '--algo=v2' '-m' '+s' '--reverse' '--preview=p {} | pen-umn | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempmDQV0Fj.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" eval 'sh-source | pen-ds -s source-to-source'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_086d5eba30.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempuumsGDk.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_cd8a2e656e.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempz1DaIX8.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_0f92c5e15d.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempSgAu50M.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_a632378238.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempVxCgI61.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_fc01f735c4.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempNKp7p6S.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_3e3b7b49b3.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempMpKa3FU.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
cd /root/notes;  "nvim" "-u" "/root/.nvimrc" "-c" "call TermAndQuit(\" cat '/tmp/tf_temp_4415d278b8.txt' | 'fzf' '--algo=v2' '-m' '--reverse' '--preview=p {} | pen-fzf-scope' '--preview-window=up:30%:hidden' > '/tmp/tf_tempvgYvBF4.txt'\")" "-c" "call GeneralSyntax()" "-c" "call NumberSyntax()" "-c" "normal\! i" "#" "<==" "pen-nvc"
