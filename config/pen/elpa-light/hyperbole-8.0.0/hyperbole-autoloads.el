;;; hyperbole-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))



;;; Generated autoloads from hact.el

(register-definition-prefixes "hact" '("act" "defact" "hact" "hrule:action" "htype:" "sym"))


;;; Generated autoloads from hactypes.el

(register-definition-prefixes "hactypes" '("annot-bib" "completion" "display-" "eval-elisp" "exec-" "hactypes:link-to-file-interactively" "hyp-" "link-to-" "man-show" "rfc-toc" "text-toc"))


;;; Generated autoloads from hargs.el

(register-definition-prefixes "hargs" '("hargs:"))


;;; Generated autoloads from hbdata.el

(register-definition-prefixes "hbdata" '("hbdata:"))


;;; Generated autoloads from hbmap.el

(register-definition-prefixes "hbmap" '("hbmap:"))


;;; Generated autoloads from hbut.el

(autoload 'hbut:modify-syntax "hbut" "\
Modify syntactic character pairs in hbut:syntax-table and help-mode-syntax-table for use with implicit button activations.")
(register-definition-prefixes "hbut" '("defal" "defi" "ebut:" "gbut:" "hattr:" "hbut:" "ibtype:" "ibut:" "map-"))


;;; Generated autoloads from hgnus.el

(autoload 'Gnus-init "hgnus" "\
Initialize Hyperbole support for Gnus Usenet news reading." t)
(register-definition-prefixes "hgnus" '("lnews:to" "rnews:"))


;;; Generated autoloads from hhist.el

(register-definition-prefixes "hhist" '("*hhist*" "hhist:"))


;;; Generated autoloads from hib-debbugs.el

(register-definition-prefixes "hib-debbugs" '("debbugs-" "smart-debbugs-gnu"))


;;; Generated autoloads from hib-doc-id.el

(register-definition-prefixes "hib-doc-id" '("doc-id" "link-to-doc"))


;;; Generated autoloads from hib-kbd.el

(register-definition-prefixes "hib-kbd" '("kbd-key"))


;;; Generated autoloads from hib-social.el

(register-definition-prefixes "hib-social" '("git" "hibtypes-" "social-reference"))


;;; Generated autoloads from hibtypes.el

(register-definition-prefixes "hibtypes" '("Info-node" "action" "annot-bib" "completion" "cscope" "ctags" "debugger-source" "dir-summary" "eli" "etags" "glink" "gnus-push-button" "grep-msg" "hib-python-traceback" "hlink" "hyp-" "id-cflow" "ilink" "ipython-stack-frame" "mail-address" "man-apropos" "markdown-" "org-link-outside-org-mode" "python-tb-previous-line" "rfc" "ripgrep-msg" "tex"))


;;; Generated autoloads from hinit.el

(autoload 'hyperb:init-menubar "hinit" "\
Add a pulldown menu for Hyperbole after Emacs is initialized." t)
(autoload 'hui-menu-remove "hinit" "\
Remove MENU-SYM menu from any menubars generated by optional KEYMAP or the `global-map'.

(fn MENU-SYM &optional KEYMAP)" nil t)
(register-definition-prefixes "hinit" '("hyperb:"))


;;; Generated autoloads from hload-path.el

(register-definition-prefixes "hload-path" '("hyperb:dir"))


;;; Generated autoloads from hmail.el

(autoload 'hmail:compose "hmail" "\
Compose mail with ADDRESS and evaluation of EXPR.
Optional SUBJECT and HELP message may also be given.

(fn ADDRESS EXPR &optional SUBJECT HELP)" t)
(autoload 'hmail:msg-narrow "hmail" "\
Narrows buffer to displayable part of current message.
Its displayable part begins at optional MSG-START and ends at or before
MSG-END.

(fn &optional MSG-START MSG-END)")
(register-definition-prefixes "hmail" '("hmail:" "hnews:" "rmail:"))


;;; Generated autoloads from hmh.el

(autoload 'Mh-init "hmh" "\
Initialize Hyperbole support for Mh mail reading." t)
(register-definition-prefixes "hmh" '("Mh-"))


;;; Generated autoloads from hmoccur.el

(register-definition-prefixes "hmoccur" '("moccur"))


;;; Generated autoloads from hmouse-drv.el

(autoload 'hkey-ace-window-setup "hmouse-drv" "\
Bind optional keyboard KEY and setup display of items in windows specified by short ids.

The ace-window package, (see \"https://elpa.gnu.org/packages/ace-window.html\"),
assigns short ids to each Emacs window and lets you jump to or
operate upqon a specific window by giving its letter.  Hyperbole
can insert an operation into ace-window that allows you to
display items such as dired or buffer menu items in a specific
window.

To enable this feature, in your Emacs initialization file after
Hyperbole is initialized, if you already have a key bound for
ace-window, then call:

 (hkey-ace-window-setup)

otherwise, choose a binding like {M-o} and send it to the same
function to bind it:

 (hkey-ace-window-setup \"\357\")

Then whenever point is on an item you want displayed in another
window, use {M-o i <id-of-window-to-display-item-in>} and watch the
magic happen.

(fn &optional KEY)")
(autoload 'hkey-drag "hmouse-drv" "\
Emulate Smart Mouse Key drag from the selected window to RELEASE-WINDOW, interactively chosen via ace-window.
The drag action determines the final selected window.

Optional prefix arg non-nil means emulate Assist Key rather than the
Action Key.

Works only when running under a window system, not from a dumb terminal.

(fn RELEASE-WINDOW)" t)
(autoload 'hkey-drag-stay "hmouse-drv" "\
Emulate Smart Mouse Key drag from selected window to RELEASE-WINDOW, interactively chosen via ace-window.
After the drag, the selected window remains the same as it was before
the drag.

Works only when running under a window system, not from a dumb terminal.

(fn RELEASE-WINDOW)")
(autoload 'hkey-drag-item "hmouse-drv" "\
Emulate Smart Mouse Key drag from an item in a selected window to RELEASE-WINDOW, interactively chosen via ace-window.
RELEASE-WINDOW is left selected unless point is not on an item, in
which case, an error is signalled.

Optional prefix arg non-nil means emulate Assist Key rather than the
Action Key.

Works only when running under a window system, not from a dumb terminal.

(fn RELEASE-WINDOW)" t)
(autoload 'hkey-drag-to "hmouse-drv" "\
Emulate Smart Mouse Key drag from a selected window to RELEASE-WINDOW, interactively chosen via ace-window.
If an item is dragged to RELEASE-WINDOW, then RELEASE-WINDOW is selected;
otherwise, the drag action determines the selected window.  If no drag
has taken place, then the selected window's buffer is displayed in
RELEASE-WINDOW and that becomes the selected window.

Optional prefix arg non-nil means emulate Assist Key rather than the
Action Key.

Works only when running under a window system, not from a dumb terminal.

(fn RELEASE-WINDOW)" t)
(autoload 'hkey-replace "hmouse-drv" "\
Grab the buffer from RELEASE-WINDOW, interactively chosen via ace-window, and place it into the current window.
The selected window does not change.

(fn RELEASE-WINDOW)" t)
(autoload 'hkey-swap "hmouse-drv" "\
Swap the buffer from the selected window with that of TO-WINDOW, interactively chosen via ace-window.
Leave TO-WINDOW as the selected window.

(fn TO-WINDOW)" t)
(autoload 'hkey-throw "hmouse-drv" "\
Throw one of: the active (highlighted) region, a displayable item at point or the current buffer for display in RELEASE-WINDOW.
With optional prefix arg THROW-REGION-FLAG, throw the current region
even if not active.
The selected window does not change.

(fn RELEASE-WINDOW &optional THROW-REGION-FLAG)" t)
(autoload 'hkey-window-link "hmouse-drv" "\
Create a new Hyperbole explicit link button in the selected window, linked to point in RELEASE-WINDOW, interactively chosen via ace-window.
The selected window does not change.

(fn RELEASE-WINDOW)" t)
(autoload 'hkey-buffer-to "hmouse-drv" "\
Use ace-window to choose a FROM-WINDOW whose buffer will also be displayed in the chosen TO-WINDOW.
The selected window does not change.

(fn FROM-WINDOW TO-WINDOW)" t)
(autoload 'hkey-swap-buffers "hmouse-drv" "\
Use ace-window to choose a FROM-WINDOW whose buffer is swapped with the buffer of the chosen TO-WINDOW.
Leave TO-WINDOW as the selected window.

(fn FROM-WINDOW TO-WINDOW)" t)
(autoload 'hmouse-click-to-drag "hmouse-drv" "\
Mouse click on start and end windows for use with `hkey-drag'.
Emulate Smart Mouse Key drag from start window to end window.
The drag action determines the final selected window." t)
(autoload 'hmouse-click-to-drag-stay "hmouse-drv" "\
Mouse click on start and end windows for use with `hkey-drag-stay'.
Emulate Smart Mouse Key drag from start window to end window.
The selected window does not change." t)
(autoload 'hmouse-click-to-drag-item "hmouse-drv" "\
Mouse click on start and end windows for use with `hkey-drag-item'.
Emulate {M-o i} from start window to end window.
After the drag, the end window is the selected window." t)
(autoload 'hmouse-click-to-drag-to "hmouse-drv" "\
Mouse click on start and end windows for use with `hkey-drag-to'.
Emulate Smart Mouse Key drag from start window to end window.
After the drag, the end window is the selected window." t)
(autoload 'hmouse-click-to-replace "hmouse-drv" "\
Mouse click on start and end windows for use with `hkey-replace'.
Replace the buffer in start window with the buffer in end window.
The selected window does not change." t)
(autoload 'hmouse-click-to-swap "hmouse-drv" "\
Mouse click on start and end windows for use with `hkey-swap'.
Swap the buffer in start window with the buffer in end window.
Leave the end window selected." t)
(autoload 'hmouse-click-to-throw "hmouse-drv" "\
Mouse click on start and end windows for use with `hkey-throw'.
Throw either a displayable item at start window's point or its current
buffer to the end window.  The selected window does not change." t)
(autoload 'hkey-buffer-move-left "hmouse-drv" "\
Swap the current buffer with the one on its left, if any; otherwise, do nothing." t)
(autoload 'hkey-buffer-move-right "hmouse-drv" "\
Swap the current buffer with the one on its right, if any; otherwise, do nothing." t)
(autoload 'hkey-buffer-move-down "hmouse-drv" "\
Swap the current buffer with the one below it, if any; otherwise, do nothing." t)
(autoload 'hkey-buffer-move-up "hmouse-drv" "\
Swap the current buffer with the one on above it, if any; otherwise, do nothing." t)
(autoload 'hkey-help-hide "hmouse-drv" "\
Optionally KILL current buffer (default is bury) and quit WINDOW.
Restore frame to configuration prior to help buffer display.
Point must be in a help buffer.  See `hkey-quit-window' for additional
details.

(fn &optional KILL WINDOW)" t)
(autoload 'hkey-help-show "hmouse-drv" "\
Save prior window configuration if BUFFER displays help.  Display BUFFER.

With optional second arg CURRENT-WINDOW non-nil, force display of buffer within
the current window.  By default, it is displayed according to the setting of
`hpath:display-where'.

(fn &optional BUFFER CURRENT-WINDOW)")
(register-definition-prefixes "hmouse-drv" '("action-" "assist-" "hkey-" "hmouse-" "mouse-drag-mode-line" "quit-window" "smart-scroll-"))


;;; Generated autoloads from hmouse-info.el

(autoload 'Info-read-index-item-name "hmouse-info" "\
Read an Info index item name with completion, prompting with PROMPT.
An index item name can have the form \"itemname\", referring to an index
item in the current Info file, or \"(filename)itemname\", referring to
an item in filename.  \"(filename)\" is a short format to go to
the Top node in filename.  Signal an error if a filename without an
index is given.

(fn PROMPT)")
(autoload 'smart-info "hmouse-info" "\
Walks through Info documentation networks using one key or mouse key.

If key is pressed within:
 (1) the first line of an Info Menu Entry or Cross Reference, the desired node
       is found;
 (2) the Up, Next, or Previous entries of a Node Header (first line),
       the desired node is found;
 (3) the File entry of a Node Header (first line),
       the `Top' node within that file is found;
 (4) at the end of the current node, the Next node is found (this will
       descend subtrees if the function `Info-global-next' is bound);
 (5) anywhere else (e.g. at the end of a line), the current node entry is
       scrolled up one windowful.

Returns t if key is pressed within an Info Node Header, Cross Reference,
or a Menu; otherwise returns nil." t)
(autoload 'smart-info-assist "hmouse-info" "\
Walk through Info documentation networks using one assist-key or mouse assist-key.

If assist-key is pressed within:
 (1) the first line of an Info Menu Entry or Cross Reference, the desired node
       is found;
 (2) the Up, Next, or Previous entries of a Node Header (first line),
       the last node in the history list is found;
 (3) the File entry of a Node Header (first line),
       the `DIR' root-level node is found;
 (4) at the end of the current node, the Previous node is found (this will
       return from subtrees if the function 'Info-global-prev is bound);
 (5) anywhere else (e.g. at the end of a line), the current node entry is
       scrolled down one windowful.

Returns t if assist-key is pressed within an Info Node Header, Cross Reference,
or a Menu; otherwise returns nil." t)
(autoload 'Info-handle-in-note "hmouse-info" "\
Follows an Info cross-reference.
If point is within the first line of an Info note (cross-reference), follows
cross-reference and returns t; otherwise returns nil.")
(autoload 'Info-current-filename-sans-extension "hmouse-info" "\
Return the filename for the current Info node, if any, without directory or file extension.
This works regardless of the current buffer.")
(autoload 'Info-menu-item-at-p "hmouse-info" "\
Return the name of the Info menu item at point, or nil if none.")
(autoload 'Info-note-at-p "hmouse-info" "\
Return the name of the Info cross-reference note at point, or nil if none.")
(register-definition-prefixes "hmouse-info" '("Info-"))


;;; Generated autoloads from hmouse-key.el

(register-definition-prefixes "hmouse-key" '("hmouse-"))


;;; Generated autoloads from hmouse-mod.el

(defvar hmouse-mod-mode nil "\
Non-nil if Hmouse-Mod mode is enabled.
See the `hmouse-mod-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `hmouse-mod-mode'.")
(custom-autoload 'hmouse-mod-mode "hmouse-mod" nil)
(autoload 'hmouse-mod-mode "hmouse-mod" "\
Toggle use of the Smart Keys as Control- and Meta- modifiers (Hmouse Modifier mode).
With a prefix argument ARG, enable Hmouse Mod mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

If the Action Key is held down while alpha characters are typed,
they are translated into Control keys instead.  The Assist Key
translates them into Meta keys.  When both Smart Keys are depressed,
Control-Meta keys are produced.  The commands bound to the
characters produced are then run.

Hmouse Modifier mode is a global minor mode.  It does not affect
unmodified keys.  Normal Smart Key operations work with this
mode, if no other key is pressed while a Smart Key is depressed.

(fn &optional ARG)" t)
(register-definition-prefixes "hmouse-mod" '("hmouse-mod-"))


;;; Generated autoloads from hmouse-sh.el

(register-definition-prefixes "hmouse-sh" '("hmouse-"))


;;; Generated autoloads from hmouse-tag.el

(autoload 'smart-asm-at-tag-p "hmouse-tag" "\
Return assembly tag name that point is within, else nil.

(fn &optional NO-FLASH)")
(autoload 'smart-c++ "hmouse-tag" "\
Jumps to the definition of optional C++ IDENTIFIER or the one at point.
Optional second arg NEXT means jump to next matching C++ tag.

It assumes that its caller has already checked that the key was pressed in an
appropriate buffer and has moved the cursor to the selected buffer.

See the documentation for `c++-to-definition' for the behavior of this
function when the OO-Browser has been loaded.
Otherwise:
 (1) on a `#include' statement, the include file is displayed;
     Look for include file in directory lists `smart-c-cpp-include-path'
     and `smart-c-include-path';
 (2) on a C++ identifier, the identifier definition is displayed,
     assuming the identifier is found within an `etags' generated tag file
     in the current directory or any of its ancestor directories;
 (3) if `smart-c-use-lib-man' is non-nil, the C++ identifier is
     recognized as a library symbol, and a man page is found for the
     identifier, then the man page is displayed.

(fn &optional IDENTIFIER NEXT)" t)
(autoload 'smart-c++-tag "hmouse-tag" "\


(fn &optional IDENTIFIER NEXT)")
(autoload 'smart-c-at-tag-p "hmouse-tag" "\
Return C tag name that point is within, else nil.

(fn &optional NO-FLASH)")
(autoload 'smart-cc-mode-initialize "hmouse-tag" "\
Load and initialize cc-mode if possible and always return nil.")
(autoload 'smart-fortran-at-tag-p "hmouse-tag" "\
Return Fortran tag name that point is within, else nil.

(fn &optional NO-FLASH)")
(autoload 'smart-java "hmouse-tag" "\
Jumps to the definition of optional Java IDENTIFIER or the one at point.
Optional second arg NEXT means jump to next matching Java tag.

It assumes that its caller has already checked that the key was pressed in an
appropriate buffer and has moved the cursor to the selected buffer.

See the documentation for `smart-java-oo-browser' for the behavior of this
function when the OO-Browser has been loaded.
Otherwise:
 (1) within a commented @see cross-reference, the referent is displayed;
 (2) on a `package' or `import' statement, the referent is displayed;
     Look for referent files in the directory list `smart-java-package-path';
 (3) on a Java identifier, the identifier definition is displayed,
     assuming the identifier is found within an `etags' generated tag file
     in the current directory or any of its ancestor directories.

(fn &optional IDENTIFIER NEXT)" t)
(autoload 'smart-java-tag "hmouse-tag" "\


(fn &optional IDENTIFIER NEXT)")
(autoload 'smart-java-at-tag-p "hmouse-tag" "\
Return Java tag name that point is within, else nil.

(fn &optional NO-FLASH)")
(autoload 'smart-javascript "hmouse-tag" "\
Jump to the definition of optional JavaScript IDENTIFIER or the one at point.
Optional second arg NEXT means jump to next matching JavaScript tag.

It assumes that its caller has already checked that the key was pressed in an
appropriate buffer and has moved the cursor to the selected buffer.

If on a JavaScript identifier, the identifier definition is displayed,
assuming the identifier is found within an `etags' generated tag file
in the current directory or any of its ancestor directories.

(fn &optional IDENTIFIER NEXT)" t)
(autoload 'smart-javascript-at-tag-p "hmouse-tag" "\
Return JavaScript tag name that point is within, else nil.

(fn &optional NO-FLASH)")
(defconst smart-lisp-identifier-first-char-regexp "[-<>*a-zA-Z]" "\
Regexp matching the first character of a Lisp identifier, including the square brackets.")
(defconst smart-lisp-identifier-chars "-_:/*+=%$&?!<>a-zA-Z0-9~^" "\
Regexp matching a valid character in any part of a Lisp identifier other than the first character.
Excludes character matching square brackets, so may be used with skip-characters-forward/backward.")
(defconst smart-lisp-identifier (concat smart-lisp-identifier-first-char-regexp "[" smart-lisp-identifier-chars "]*") "\
Regexp matching a Lisp identifier.")
(autoload 'smart-lisp-mode-p "hmouse-tag" "\
Return t if in a mode which use Lisp symbols.")
(autoload 'smart-objc "hmouse-tag" "\
Jump to the definition of optional Objective-C IDENTIFIER or the one at point.
Optional second arg NEXT means jump to next matching Objective-C tag.

It assumes that its caller has already checked that the key was pressed in an
appropriate buffer and has moved the cursor to the selected buffer.

See the documentation for `smart-objc-oo-browser' for the behavior of this
function when the OO-Browser has been loaded.
Otherwise:
 (1) on a `#include' statement, the include file is displayed;
     Look for include file in directory lists `objc-cpp-include-path' and
     `objc-include-path';
 (2) on an Objective-C identifier, the identifier definition is displayed,
     assuming the identifier is found within an `etags' generated tag file
     in the current directory or any of its ancestor directories;
 (3) if `smart-c-use-lib-man' is non-nil, the Objective-C identifier is
     recognized as a library symbol, and a man page is found for the
     identifier, then the man page is displayed.

(fn &optional IDENTIFIER NEXT)" t)
(autoload 'smart-objc-tag "hmouse-tag" "\


(fn &optional IDENTIFIER NEXT)")
(autoload 'smart-python "hmouse-tag" "\
Jumps to the definition of optional Python IDENTIFIER or the one at point.
Optional second arg NEXT means jump to next matching Python tag.

It assumes that its caller has already checked that the key was pressed in an
appropriate buffer and has moved the cursor to the selected buffer.

See the documentation for `smart-python-jedi-to-definition-p' for the
behavior when the Jedi python identifier server is in use.

See the documentation for `smart-python-oo-browser' for the behavior of this
function when the OO-Browser has been loaded.

Otherwise, on a Python identifier, the identifier definition is displayed,
assuming the identifier is found within an `etags' generated tag file
in the current directory or any of its ancestor directories.

(fn &optional IDENTIFIER NEXT)" t)
(autoload 'smart-python-tag "hmouse-tag" "\


(fn &optional IDENTIFIER NEXT)")
(autoload 'smart-python-at-tag-p "hmouse-tag" "\
Return Python tag name that point is within, else nil.

(fn &optional NO-FLASH)")
(autoload 'smart-tags-file-path "hmouse-tag" "\
Expand relative FILE name by looking it up within appropriate tags files.
Return FILE unchanged if it exists relative to the current directory or
cannot be expanded via a tags file.

(fn FILE)")
(autoload 'smart-tags-file-list "hmouse-tag" "\
Return appropriate tag files list for optional CURR-DIR-OR-FILENAME or for `default-directory'.
Optional NAME-OF-TAGS-FILE is the literal filename (no directory) for which
to look.  If no tags file is found, an error is signaled.

(fn &optional CURR-DIR-OR-FILENAME NAME-OF-TAGS-FILE)")
(register-definition-prefixes "hmouse-tag" '("smart-"))


;;; Generated autoloads from hpath.el

(defvar hpath:posix-mount-point-to-mswindows-alist nil "\
Automatically set alist of (posix-mount-point . window-path-prefix) elements.
Used to expand posix mount points to Windows UNC paths during posix-to-mswindows conversion.")
(autoload 'hpath:mswindows-to-posix "hpath" "\
Convert a recognizable MSWindows PATH to a Posix-style path or return the path unchanged.
If path begins with an MSWindows drive letter, prefix the converted path with the value of 'hpath:mswindows-mount-prefix'.

(fn PATH)" t)
(autoload 'hpath:posix-to-mswindows "hpath" "\
Convert and return a Posix-style PATH to an MSWindows path or return the path unchanged.
If path begins with an optional mount prefix, 'hpath:mswindows-mount-prefix', followed by an MSWindows drive letter, remove the mount prefix.

(fn PATH)" t)
(autoload 'hpath:substitute-posix-or-mswindows-at-point "hpath" "\
If point is within a recognizable Posix or MSWindows path, change the path to the other type of path." t)
(autoload 'hpath:substitute-posix-or-mswindows "hpath" "\
Change a recognizable Posix or MSWindows PATH to the other type of path.

(fn PATH)")
(autoload 'hpath:cache-mswindows-mount-points "hpath" "\
Cache valid MSWindows mount points in 'directory-abbrev-alist' when under a non-MSWindows operating system, e.g. WSL.
Call this function manually if mount points change after Hyperbole is loaded." t)
(autoload 'hpath:display-buffer "hpath" "\
Display and select BUFFER at optional DISPLAY-WHERE location or at `hpath:display-where'.
BUFFER must be a buffer or a buffer name.

See the documentation of `hpath:display-buffer-alist' for valid
values of DISPLAY-WHERE.  Return the window in which the buffer
is displayed or nil if not displayed because BUFFER is invalid.

(fn BUFFER &optional DISPLAY-WHERE)" t)
(autoload 'hpath:find-file-urls-mode "hpath" "\
Toggle enabling/disabling the use of ftp and www Urls as arguments to `find-file' commands.
With optional prefix ARG, enable this feature if ARG is positive or turn it
off otherwise.

(fn &optional ARG)" t)
(register-definition-prefixes "hpath" '("hpath:" "hyperb:substitute-in-file-name" "substitute-in-file-name"))


;;; Generated autoloads from hrmail.el

(autoload 'Rmail-init "hrmail" "\
Initialize Hyperbole support for Rmail mail reading." t)
(register-definition-prefixes "hrmail" '("Rmail-" "rmail-"))


;;; Generated autoloads from hsettings.el

(autoload 'hyperbole-toggle-messaging "hsettings" "\
Toggle Hyperbole support for explicit buttons in mail and news buffers.
Toggle the boolean variable `inhibit-hyperbole-messaging’ and either
add hooks (nil value) or remove them (t value).

With optional prefix ARG > 0, enable support.  If ARG <= 0,
disable/inhibit support.

(fn &optional ARG)" t)
(register-definition-prefixes "hsettings" '("hkey-always-display-menu" "hmouse-middle-flag" "hui:but-flash" "hyperbole-" "inhibit-hyperbole-messaging" "smart-scroll-proportional"))


;;; Generated autoloads from hsmail.el

(register-definition-prefixes "hsmail" '("mail-yank-original" "message--yank-original-internal" "smail:"))


;;; Generated autoloads from hsys-org.el

(autoload 'hsys-org-meta-return-shared-p "hsys-org" "\
Return non-nil iff hyperbole-mode is active and it shares the org-meta-return key binding.")
(defvar hsys-org-enable-smart-keys 'unset "\
This option applies only in Org major/minor modes when hyperbole-mode is active.
If set to 'unset prior to loading Hyperbole, then Hyperbole
initialization will set its value.

The following table shows what the Smart Keys do in various contexts
with different settings of this option.  For example, a nil value makes
{M-RET} operate as it normally does within Org mode contexts.

|---------------------+-------------------+------------------+----------+------------------|
| This Option Setting | Smart Key Context | Hyperbole Button | Org Link | Fallback Command |
|---------------------+-------------------+------------------+----------+------------------|
| buttons             | Ignore            | Activate         | Activate | org-meta-return  |
| nil                 | Ignore            | Ignore           | Ignore   | org-meta-return  |
| t                   | Activate          | Activate         | Activate | None             |
|---------------------+-------------------+------------------+----------+------------------|")
(custom-autoload 'hsys-org-enable-smart-keys "hsys-org" t)
(defvar hsys-org-mode-function #'hsys-org-mode-p "\
*Boolean function of no arguments that determines whether point is in an Org mode-related buffer or not.")
(register-definition-prefixes "hsys-org" '("hsys-org-" "org-"))


;;; Generated autoloads from hsys-www.el

(autoload 'www-url-expand-file-name "hsys-www" "\
Expand and return  non-url and non-remote PATH in DIR.
Return http urls unchanged.  Normalize remote paths.

(fn PATH &optional DIR)")
(autoload 'www-url-find-file-noselect "hsys-www" "\
Find PATH without selecting its buffer.  Handle http urls.

(fn PATH &rest ARGS)")
(register-definition-prefixes "hsys-www" '("www-url"))


;;; Generated autoloads from htz.el

(register-definition-prefixes "htz" '("htz:"))


;;; Generated autoloads from hui.el

(autoload 'hui-copy-to-register "hui" "\
Copy region or thing into register REGISTER.
With prefix arg, delete as well.
Called from program, takes five args: REGISTER, START, END, DELETE-FLAG,
and REGION.  START and END are buffer positions indicating what to copy.
The optional argument REGION if non-nil, indicates that we're not just
copying some text between START and END, but we're copying the region.

Interactively, reads the register using `register-read-with-preview'.

If called interactively, `transient-mark-mode' is non-nil, and
there is no active region, copy any delimited selectable thing at
point; see `hui:delimited-selectable-thing'.

(fn REGISTER START END &optional DELETE-FLAG REGION)" t)
(autoload 'hui-kill-ring-save "hui" "\
Save the active region as if killed, but don't kill it.
In Transient Mark mode, deactivate the mark.
If `interprogram-cut-function' is non-nil, also save the text for a window
system cut and paste.

If called interactively, `transient-mark-mode' is non-nil, and
there is no active region, copy any delimited selectable thing at
point; see `hui:delimited-selectable-thing'.

If you want to append the killed region to the last killed text,
use \\[append-next-kill] before \\[kill-ring-save].

The copied text is filtered by `filter-buffer-substring' before it is
saved in the kill ring, so the actual saved text might be different
from what was in the buffer.

When called from Lisp, save in the kill ring the stretch of text
between BEG and END, unless the optional argument REGION is
non-nil, in which case ignore BEG and END, and save the current
region instead.

This command is similar to `copy-region-as-kill', except that it gives
visual feedback indicating the extent of the region being copied.

(fn BEG END &optional REGION)" t)
(register-definition-prefixes "hui" '("hui:"))


;;; Generated autoloads from hui-dired-sidebar.el

(autoload 'smart-dired-sidebar "hui-dired-sidebar" "\
Use a single key or mouse key to manipulate directory entries.

Invoked via a key press when in dired-sidebar-mode.  It assumes
that its caller has already checked that the key was pressed in
an appropriate buffer and has moved the cursor there.

If key is pressed:
 (1) within an entry line, the item is displayed for editing,
     normally in another window, or if it is a directory and
     `dired-sidebar-cycle-subtree-on-click' is t it will expand
     and collapse the entry
 (2) at the end of an entry line: invoke `action-key-eol-function',
     typically to scroll up proportionally, if an Action Key press; invoke
     `assist-key-eol-function', typically to scroll down proportionally,
     if an Asisst Key press;
 (3) on the first line of the buffer (other than the end of line),
     dired is run on the current directory of this dired-sidebar;
 (4) at the end of the first or last line of the buffer,
     this dired-sidebar invocation is hidden." t)


;;; Generated autoloads from hui-em-but.el

(register-definition-prefixes "hui-em-but" '("hproperty:"))


;;; Generated autoloads from hui-jmenu.el

(autoload 'hui-menu-of-buffers "hui-jmenu")
(autoload 'hui-menu-screen-commands "hui-jmenu" "\
Popup a menu of buffers, frames, and windows, allowing user to jump to one." t)
(autoload 'hui-menu-jump-to-buffer "hui-jmenu" "\
Popup a menu of existing buffers categorized by mode name.  Jump to chosen buffer." t)
(autoload 'hui-menu-jump-to-frame "hui-jmenu" "\
Popup a menu of existing frames.  Jump to chosen frame." t)
(autoload 'hui-menu-jump-to-window "hui-jmenu" "\
Popup a menu of existing frames.  Jump to chosen frame." t)
(register-definition-prefixes "hui-jmenu" '("hui-menu-"))


;;; Generated autoloads from hui-menu.el

(register-definition-prefixes "hui-menu" '("hui-menu-" "hyperbole-" "infodock-hyperbole-menu"))


;;; Generated autoloads from hui-mini.el

(autoload 'hyperbole "hui-mini" "\
Invoke the Hyperbole minibuffer menu when not already active.
\\[hyperbole] runs this.  Non-interactively, return t if a menu is
displayed by this call, else nil (e.g. when already in a Hyperbole
mini-menu).

Two optional arguments may be given to invoke alternative menus.
MENU (a symbol) specifies the menu to invoke from MENU-LIST, (a
Hyperbole menu list structure).  MENU defaults to 'hyperbole and MENU-LIST
to `hui:menus'.  See `hui:menus' definition for the format of the menu list
structure.

Two additional optional arguments may be given when documentation for
a menu item should be shown rather than display of a menu.  DOC-FLAG
non-nil means show documentation for any item that is selected by the
user.  HELP-STRING-FLAG non-nil means show only the first line of the
documentation, not the full text.

(fn &optional MENU MENU-LIST DOC-FLAG HELP-STRING-FLAG)" t)
(autoload 'hyperbole-demo "hui-mini" "\
Display the Hyperbole FAST-DEMO.
With a prefix arg, display the older, more extensive DEMO file.

(fn &optional ARG)" t)
(autoload 'hyperbole-set-key "hui-mini" "\
In KEYMAP, bind KEY to Hyperbole minibuffer BINDING.
If KEYMAP is nil, use the value of (global-key-map).

KEY is a key sequence; noninteractively, it is a string or vector
of characters or event types, and non-ASCII characters with codes
above 127 (such as ISO Latin-1) can be included if you use a vector.

BINDING is one of:
  nil     - immediately remove key binding from keymap
  string  - upon key press, execute the BINDING string as a key series
  command - upon key press, run the command interactively.

Note that other local or minor mode bindings may shadow/override any
binding made with this function.

(fn KEYMAP KEY BINDING)" t)
(register-definition-prefixes "hui-mini" '("hui" "hyperbole-minibuffer-menu"))


;;; Generated autoloads from hui-mouse.el

(register-definition-prefixes "hui-mouse" '("action-key-" "assist-key-" "first-line-p" "hkey-" "hmouse-" "last-line-p" "smart-"))


;;; Generated autoloads from hui-select.el

(autoload 'hui-select-at-p "hui-select" "\
Return non-nil if the character after optional POS (or point) matches a syntax entry in `hui-select-syntax-alist'.
The non-nil value returned is the function to call to select that syntactic unit.

(fn &optional POS)" t)
(autoload 'hui-select-goto-matching-delimiter "hui-select" "\
Jump back and forth between the start and end delimiters of a thing." t)
(autoload 'hui-select-initialize "hui-select" "\
Initialize the hui-select mode on a double click of the left mouse key.
Also, add language-specific syntax setups to aid in thing selection." t)
(autoload 'hui-select-get-thing "hui-select" "\
Return the thing at point that `hui-select-thing' would select.")
(autoload 'hui-select-thing "hui-select" "\
Select a region based on the syntax of the thing at point.
If invoked repeatedly, this selects bigger and bigger things.
If `hui-select-display-type' is non-nil and this is called
interactively, the type of selection is displayed in the minibuffer." t)
(autoload 'hui-select-thing-with-mouse "hui-select" "\
Select a region based on the syntax of the character from a mouse click EVENT.
If the click occurs at the same point as the last click, select
the next larger syntactic structure.  If `hui-select-display-type' is
non-nil and this is called interactively, the type of selection is
displayed in the minibuffer.

(fn EVENT)" t)
(autoload 'hui-select-goto-matching-tag "hui-select" "\
If in a major mode listed in `hui-select-markup-modes,' move point to the start of the tag paired with the closest tag that point is within or precedes.
Returns t if point is moved, else nil.
Signals an error if no tag is found following point or if the closing tag
does not have a `>' terminator character." t)
(autoload 'hui-select-and-copy-thing "hui-select" "\
Copy the region surrounding the syntactical unit at point to the kill ring." t)
(autoload 'hui-select-and-kill-thing "hui-select" "\
Kill the region surrounding the syntactical unit at point." t)
(autoload 'hui-select-double-click-hook "hui-select" "\
Select a region based on the syntax of the character wherever the mouse is double-clicked.
If the double-click occurs at the same point as the last double-click, select
the next larger syntactic structure.  If `hui-select-display-type' is non-nil,
the type of selection is displayed in the minibuffer.

(fn EVENT CLICK-COUNT)")
(register-definition-prefixes "hui-select" '("hui-select-"))


;;; Generated autoloads from hui-treemacs.el

(autoload 'smart-treemacs "hui-treemacs" "\
Use a single key or mouse key to manipulate directory entries.

Invoked via a key press when in treemacs-mode.  It assumes that its
caller has already checked that the key was pressed in an appropriate buffer
and has moved the cursor there.

If key is pressed:
 (1) on an entry icon, the treemacs TAB command is run to expand and
     collapse the entry;
 (2) elsewhere within an entry line, the item is displayed for editing,
     normally in another window;
 (3) at the end of an entry line: invoke `action-key-eol-function',
     typically to scroll up proportionally, if an Action Key press; invoke
     `assist-key-eol-function', typically to scroll down proportionally,
     if an Asisst Key press;
 (4) on the first line of the buffer (other than the end of line),
     dired is run on the current directory of this Treemacs;
 (5) at the end of the first or last line of the buffer,
     this Treemacs invocation is quit." t)
(autoload 'smart-treemacs-modeline "hui-treemacs" "\
Toggle display of Treemacs file viewer based on Smart Action Key click on a modeline.

When pressed on the Treemacs buffer modeline or Treemacs is displaying
the default directory of the buffer modeline clicked upon, then
quit/hide the Treemacs window.  Otherwise, display the Treemacs window
with the default directory of the buffer modeline clicked upon.

Suitable for use as a value of `action-key-modeline-buffer-id-function'.")


;;; Generated autoloads from hui-window.el

(register-definition-prefixes "hui-window" '("action-key-m" "assist-key-m" "hmouse-" "smart-"))


;;; Generated autoloads from hvar.el

(autoload 'var:add-and-run-hook "hvar" "\
Add to HOOK (a symbol ending with -hook) HOOK-FUNCTION and then call HOOK-FUNCTION in every buffer with the matching major mode based on HOOK's name.

(fn HOOK HOOK-FUNCTION)")
(autoload 'var:append "hvar" "\
Append to value held by VAR-SYMBOL, LIST-TO-ADD.  Return new value.
If VAR-SYMBOL is unbound, it is set to LIST-TO-ADD.
Use to append to hook variables.  Store all values for later removal.
Do nothing when `inhibit-hyperbole-messaging' is non-nil.

(fn VAR-SYMBOL LIST-TO-ADD)")
(register-definition-prefixes "hvar" '("var:"))


;;; Generated autoloads from hversion.el

(defvar hyperb:microsoft-os-p (memq system-type '(ms-windows windows-nt ms-dos win32)) "\
Non-nil iff Hyperbole is running under a Microsoft OS but not under Windows Subsystem for Linux (WSL).
Use `hyperb:wsl-os-p' to test if running under WSL.")
(defvar hyperb:wsl-os-p (and (eq system-type 'gnu/linux) (executable-find "wsl.exe") t) "\
T iff Hyperbole is running under Microsoft Windows Subsystem for Linux (WSL).")
(defvar hyperb:mouse-buttons (if (or (and hyperb:microsoft-os-p (not (memq window-system '(w32 w64 x)))) (memq window-system '(ns dps))) 2 3) "\
Number of live buttons available on the mouse.
Override this if the system-computed default is incorrect for your specific mouse.")
(register-definition-prefixes "hversion" '("hyperb:" "id-"))


;;; Generated autoloads from hvm.el

(autoload 'Vm-init "hvm" "\
Initialize Hyperbole support for Vm mail reading." t)
(register-definition-prefixes "hvm" '("Vm-" "vm-"))


;;; Generated autoloads from hycontrol.el

(eval-after-load "buff-menu" '(define-key Buffer-menu-mode-map "@" 'hycontrol-windows-grid))
(eval-after-load "ibuffer" '(define-key ibuffer-mode-map "@" 'hycontrol-windows-grid))
(eval-after-load "dired" '(define-key dired-mode-map "@" 'hycontrol-windows-grid))
(autoload 'hycontrol-enable-frames-mode "hycontrol" "\
Globally enable HyControl Frames mode for rapid Emacs frame control.

  Interactively delete, jump to, move, replicate, and resize frames.
With optional numeric prefix ARG, move and resize by ARG (an
integer) units.  If ARG is < 1, it is set to 1.  If it is >
`hycontrol-maximum-units', it is set to `hycontrol-maximum-units'.

(fn &optional ARG)" t)
(autoload 'hycontrol-enable-windows-mode "hycontrol" "\
Globally enable HyControl Windows mode for rapid Emacs window control.

Interactively delete, jump to, rebalance, resize, and split windows.
Optional non-negative numeric prefix ARG is used as the number of
units for commands issued while the mode is active.  If ARG is < 1, it
is set to 1.  If it is > `hycontrol-maximum-units', it is set to
`hycontrol-maximum-units'.

(fn &optional ARG)" t)
(put 'hycontrol-frames-mode 'globalized-minor-mode t)
(defvar hycontrol-frames-mode nil "\
Non-nil if Hycontrol-Frames mode is enabled.
See the `hycontrol-frames-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `hycontrol-frames-mode'.")
(custom-autoload 'hycontrol-frames-mode "hycontrol" nil)
(autoload 'hycontrol-frames-mode "hycontrol" "\
Toggle Hycontrol-Local-Frames mode in all buffers.
With prefix ARG, enable Hycontrol-Frames mode if ARG is positive; otherwise,
disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Hycontrol-Local-Frames mode is enabled in all buffers where `(lambda nil
(hycontrol-local-frames-mode 1))' would do it.

See `hycontrol-local-frames-mode' for more information on Hycontrol-Local-Frames
mode.

(fn &optional ARG)" t)
(defvar hycontrol-local-frames-mode nil "\
Non-nil if Hycontrol-Local-Frames mode is enabled.
See the `hycontrol-local-frames-mode' command
for a description of this minor mode.")
(custom-autoload 'hycontrol-local-frames-mode "hycontrol" nil)
(autoload 'hycontrol-local-frames-mode "hycontrol" "\
Toggle Hyperbole Frames control minor mode in the current buffer.

This is a global minor mode.  If called interactively, toggle the
`Hycontrol-Local-Frames mode' mode.  If the prefix argument is
positive, enable the mode,  and if it is zero or negative,
disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='hycontrol-local-frames-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(put 'hycontrol-windows-mode 'globalized-minor-mode t)
(defvar hycontrol-windows-mode nil "\
Non-nil if Hycontrol-Windows mode is enabled.
See the `hycontrol-windows-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `hycontrol-windows-mode'.")
(custom-autoload 'hycontrol-windows-mode "hycontrol" nil)
(autoload 'hycontrol-windows-mode "hycontrol" "\
Toggle Hycontrol-Local-Windows mode in all buffers.
With prefix ARG, enable Hycontrol-Windows mode if ARG is positive; otherwise,
disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Hycontrol-Local-Windows mode is enabled in all buffers where `(lambda nil
(hycontrol-local-windows-mode 1))' would do it.

See `hycontrol-local-windows-mode' for more information on
Hycontrol-Local-Windows mode.

(fn &optional ARG)" t)
(defvar hycontrol-local-windows-mode nil "\
Non-nil if Hycontrol-Local-Windows mode is enabled.
See the `hycontrol-local-windows-mode' command
for a description of this minor mode.")
(custom-autoload 'hycontrol-local-windows-mode "hycontrol" nil)
(autoload 'hycontrol-local-windows-mode "hycontrol" "\
Toggle Hyperbole Windows control minor mode in the current buffer.

This is a global minor mode.  If called interactively, toggle the
`Hycontrol-Local-Windows mode' mode.  If the prefix argument is
positive, enable the mode,  and if it is zero or negative,
disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='hycontrol-local-windows-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(autoload 'hycontrol-frame-adjust-widths "hycontrol" "\
Cycle through different common width adjustments of a frame.
Widths are given in screen percentages by the list
`hycontrol-frame-widths' and typically go from widest to narrowest." t)
(autoload 'hycontrol-frame-adjust-widths-full-height "hycontrol" "\
Cycle through different common widths adjustments of a frame after fixing its height full-screen.
Widths are given in screen percentages by the list
`hycontrol-frame-widths' and typically go from widest to narrowest." t)
(autoload 'hycontrol-frame-adjust-heights "hycontrol" "\
Cycle through different common height adjustments of a frame.
Heights are given in screen percentages by the list
`hycontrol-frame-heights' and typically go from tallest to shortest." t)
(autoload 'hycontrol-frame-adjust-heights-full-width "hycontrol" "\
Cycle through different common height adjustments of a frame after fixing its width full-screen.
Heights are given in screen percentages by the list
`hycontrol-frame-heights' and typically go from tallest to shortest." t)
(autoload 'hycontrol-windows-grid "hycontrol" "\
Display a grid of windows in the selected frame, sized according to prefix ARG.
Left digit of ARG is the number of grid rows and the right digit is
the number of grid columns.  Use {C-h h h} to restore the prior frame
configuration after a grid is displayed.

If ARG is 0, prompt for a major mode whose buffers should be
displayed in the grid windows, then prompt for the grid size.

If ARG is < 0, prompt for a glob-type file pattern and display
files that match the pattern in an auto-sized windows grid.

Otherwise, prompt for the grid size if ARG is an invalid size
(positive and more than two digits).

With a current buffer in Dired, Buffer Menu or IBuffer mode that
contains marked items, the buffers associated with those items
are displayed in the grid (unless ARG is 0).

By default, the most recently used buffers are displayed in each window,
first selecting only those buffers which match any of the
predicate expressions in `hycontrol-display-buffer-predicate-list'.
(The default predicate list chooses buffers with attached files).
Then, if there are not enough buffers for all windows, the buffers
that failed to match to any predicate are used.  In all cases, buffers
whose names start with a space are ignored.

When done, this resets the persistent HyControl prefix argument to 1
to prevent following commands from using the often large grid size
argument.

(fn ARG)" t)
(autoload 'hycontrol-windows-grid-by-file-pattern "hycontrol" "\
Display an automatically sized window grid showing files found from glob PATTERN.
Use absolute file paths if optional FULL is non-nil.

(fn PATTERN &optional FULL)" t)
(autoload 'hycontrol-windows-grid-by-major-mode "hycontrol" "\
Display a grid of windows in the selected frame, sized according to prefix ARG, with buffers of major MODE.
Left digit of ARG is the number of grid rows and the right digit is
the number of grid columns.

See documentation of `hycontrol-windows-grid' for further details.

(fn ARG MODE)" t)
(autoload 'hycontrol-windows-grid-repeatedly "hycontrol" "\
Repeatedly display different window grid layouts according to prefix ARG prompted for each time.
Left digit of ARG is the number of grid rows and the right digit is
the number of grid columns. 

See documentation of `hycontrol-windows-grid' for further details.

(fn &optional ARG)" t)
(autoload 'hycontrol-window-to-new-frame "hycontrol" "\
Create a new frame sized to match the selected window with the same buffer.
If there is only one window in the source frame or if `hycontrol-keep-window-flag'
is non-nil, leave the original window and just clone it into the new frame;
otherwise, delete the original window." t)
(autoload 'hycontrol-clone-window-to-new-frame "hycontrol" "\
Create a new frame sized to match the selected window with the same buffer." t)
(register-definition-prefixes "hycontrol" '("hycontrol-"))


;;; Generated autoloads from hypb.el

(autoload 'hypb:configuration "hypb" "\
Insert Emacs configuration information at the end of optional OUT-BUF or the current buffer.

(fn &optional OUT-BUF)")
(autoload 'hypb:def-to-buffer "hypb" "\
Copy next optional ARG (default = 1) code definitions to the start of BUFFER (default = *scratch*) and leave point at the start of the inserted text.

(fn &optional ARG BUFFER)" t)
(autoload 'hypb:locate "hypb" "\
Find file name match anywhere, calling the value of `locate-command', and putting results in the `*Locate*' buffer.
Pass it SEARCH-STRING as argument.  Interactively, prompt for SEARCH-STRING.
With prefix arg ARG, prompt for the exact shell command to run instead.

This program searches for those file names in a database that match
SEARCH-STRING and normally outputs all matching absolute file names,
one per line.  The database normally consists of all files on your
system, or of all files that you have access to.  Consult the
documentation of the program for the details about how it determines
which file names match SEARCH-STRING.  (Those details vary highly with
the version.)

You can specify another program for this command to run by customizing
the variables `locate-command' or `locate-make-command-line'.

The main use of FILTER is to implement `locate-with-filter'.  See
the docstring of that function for its meaning.

After preparing the results buffer, this runs `dired-mode-hook' and
then `locate-post-command-hook'.

(fn SEARCH-STRING &optional FILTER ARG)" t)
(autoload 'hypb:map-plist "hypb" "\
Return result of applying FUNC of two args, key and value, to key-value pairs in PLIST, a property list.

(fn FUNC PLIST)")
(autoload 'hypb:rgrep "hypb" "\
Recursively grep with symbol at point or PATTERN over all non-backup and non-autosave files in the current directory tree.
If in an Emacs Lisp mode buffer and no PREFX-ARG is given, limit search to only .el and .el.gz files.

(fn PATTERN &optional PREFX-ARG)" t)
(autoload 'hypb:display-file-with-logo "hypb" "\
Display a text FILE in help mode with the Hyperbole banner prepended.
If FILE is not an absolute path, expand it relative to `hyperb:dir'.

(fn FILE)")
(register-definition-prefixes "hypb" '("hypb:"))


;;; Generated autoloads from hypb-ert.el

(register-definition-prefixes "hypb-ert" '("hyp"))


;;; Generated autoloads from hypb-maintenance.el

(register-definition-prefixes "hypb-maintenance" '("hypb:"))


;;; Generated autoloads from hyperbole.el

(defvar hyperbole-mode nil "\
Non-nil if Hyperbole mode is enabled.
See the `hyperbole-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `hyperbole-mode'.")
(custom-autoload 'hyperbole-mode "hyperbole" nil)
(autoload 'hyperbole-mode "hyperbole" "\
Toggle Hyperbole global minor mode, the Everyday Hypertextual Information Manager.

When Hyperbole mode is enabled, the `hyperbole-mode' variable
is non-nil, Hyperbole menus are enabled, as are Hyperbole keys.

Invoke the Hyperbole minibuffer menu with \\[hyperbole].  See the
Info documentation at \"(hyperbole)Top\".

\\{hyperbole-mode-map}

This is a global minor mode.  If called interactively, toggle the
`Hyperbole mode' mode.  If the prefix argument is positive,
enable the mode,  and if it is zero or negative, disable the
mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='hyperbole-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

(fn &optional ARG)" t)
(register-definition-prefixes "hyperbole" '("hkey-" "hyperb"))


;;; Generated autoloads from hyrolo.el

(autoload 'hyrolo-initialize-file-list "hyrolo" "\
Initialize the list of files used for HyRolo search." t)
(autoload 'hyrolo-add "hyrolo" "\
Add a new entry in personal rolo for NAME.
Last name first is best, e.g. \"Smith, John\".
With prefix argument, prompts for optional FILE to add entry within.
NAME may be of the form: parent/child to insert child below a parent
entry which begins with the parent string.

(fn NAME &optional FILE)" t)
(autoload 'hyrolo-display-matches "hyrolo" "\
Display optional DISPLAY-BUF buffer of previously found rolo matches.
If DISPLAY-BUF is nil, use the value in `hyrolo-display-buffer'.
Second arg RETURN-TO-BUFFER is the buffer to leave point within after the display.

(fn &optional DISPLAY-BUF RETURN-TO-BUFFER)" t)
(autoload 'hyrolo-edit "hyrolo" "\
Edit a rolo entry given by optional NAME within `hyrolo-file-list'.
With prefix argument, prompts for optional FILE to locate entry within.
With no NAME arg, simply displays FILE or first entry in `hyrolo-file-list' in an
editable mode.  NAME may be of the form: parent/child to edit child below a
parent entry which begins with the parent string.

(fn &optional NAME FILE)" t)
(autoload 'hyrolo-fgrep "hyrolo" "\
Display rolo entries matching STRING (or a logical match expression) and return count of matches.
To a maximum of optional prefix arg MAX-MATCHES, in file(s) from optional
HYROLO-FILE or `hyrolo-file-list'.  Default is to find all matching entries.
Each entry is displayed with all of its sub-entries.  Optional COUNT-ONLY
non-nil means don't retrieve and don't display matching entries.  Optional
NO-DISPLAY non-nil means retrieve entries but don't display.

Nil value of MAX-MATCHES means find all matches, t value means find all
matches but omit file headers, negative values mean find up to the inverse of
that number of entries and omit file headers.

Return number of entries matched.  See also documentation for the variable
`hyrolo-file-list' and the function `hyrolo-fgrep-logical' for documentation on
the logical expression matching.

(fn STRING &optional MAX-MATCHES HYROLO-FILE COUNT-ONLY NO-DISPLAY)" t)
(autoload 'hyrolo-find-file "hyrolo" "\
Select and edit a file in `hyrolo-file-list', defaulting to the first listed file when not given a prefix arg.

(fn &optional FILE)" t)
(autoload 'hyrolo-grep "hyrolo" "\
Display rolo entries matching REGEXP and return count of matches.
To a maximum of prefix arg MAX-MATCHES, in buffer(s) from optional HYROLO-FILE-OR-BUFS or
hyrolo-file-list.  Default is to find all matching entries.  Each entry is
displayed with all of its sub-entries.  Optional COUNT-ONLY non-nil means don't
retrieve and don't display matching entries.  Optional NO-DISPLAY non-nil
means retrieve entries but don't display.

Nil value of MAX-MATCHES means find all matches, t value means find all matches
but omit file headers, negative values mean find up to the inverse of that
number of entries and omit file headers.

Return number of entries matched.  See also documentation for the variable
`hyrolo-file-list'.

(fn REGEXP &optional MAX-MATCHES HYROLO-FILE-OR-BUFS COUNT-ONLY NO-DISPLAY)" t)
(autoload 'hyrolo-grep-or-fgrep "hyrolo" "\
Grep over `hyrolo-file-list' and display the results as rolo entries.
With optional prefix ARG, do an fgrep string match instead of a regexp match.

(fn &optional ARG)" t)
(autoload 'hyrolo-kill "hyrolo" "\
Kill a rolo entry given by NAME within `hyrolo-file-list'.
With prefix argument, prompts for optional FILE to locate entry within.
NAME may be of the form: parent/child to kill child below a parent entry
which begins with the parent string.
Return t if entry is killed, nil otherwise.

(fn NAME &optional FILE)" t)
(autoload 'hyrolo-sort "hyrolo" "\
Sort up to 14 levels of entries in HYROLO-FILE (default is personal rolo).
Assume entries are delimited by one or more `*'characters.
Return list of number of groupings at each entry level.

(fn &optional HYROLO-FILE)" t)
(autoload 'hyrolo-toggle-datestamps "hyrolo" "\
Toggle whether datestamps are updated when rolo entries are modified.
With optional ARG, turn them on iff ARG is positive.

(fn &optional ARG)" t)
(autoload 'hyrolo-word "hyrolo" "\
Display rolo entries with whole word match for STRING.
To a maximum of optional prefix arg MAX-MATCHES, in file(s) from optional
HYROLO-FILE or hyrolo-file-list.  Default is to find all matching entries.  Each
entry is displayed with all of its sub-entries.  Optional COUNT-ONLY non-nil
means don't retrieve and don't display matching entries.  Optional NO-DISPLAY
non-nil means retrieve entries but don't display.

Nil value of MAX-MATCHES means find all matches, t value means find all matches
but omit file headers, negative values mean find up to the inverse of that
number of entries and omit file headers.

Return number of entries matched.  See also documentation for the variable
hyrolo-file-list.

(fn STRING &optional MAX-MATCHES HYROLO-FILE COUNT-ONLY NO-DISPLAY)" t)
(autoload 'hyrolo-yank "hyrolo" "\
Insert at point the first rolo entry matching NAME.
With optional prefix arg, REGEXP-P, treats NAME as a regular expression instead
of a string.

(fn NAME &optional REGEXP-P)" t)
(autoload 'hyrolo-bbdb-fgrep "hyrolo" "\
Fgrep over a bbdb database and format the results as rolo entries.
With optional prefix ARG, do a grep regexp match instead of a string match.

(fn &optional ARG)" t)
(autoload 'hyrolo-bbdb-grep "hyrolo" "\
Grep over a bbdb database and format the results as rolo entries.
With optional prefix ARG, do an fgrep string match instead of a regexp match.

Output looks like so:
======================================================================
@loc> \".bbdb\"
======================================================================
* Jones     Tom                <tj@groovycat.org>
* Sera      Kate               <uptown@singular.net>
* Yako      Maso               <ym@destination.ny>

(fn &optional ARG)" t)
(autoload 'hyrolo-google-contacts-fgrep "hyrolo" "\
Fgrep over a buffer of Google Contacts and format the results as rolo entries.
With optional prefix ARG, do a grep regexp match instead of a string match.

(fn &optional ARG)" t)
(autoload 'hyrolo-google-contacts-grep "hyrolo" "\
Grep over a buffer of Google Contacts and format the results as rolo entries.
With optional prefix ARG, do an fgrep string match instead of a regexp match.

Output looks like so:
======================================================================
@loc> <buffer *Google Contacts*>
======================================================================
* Jones     Tom
* Sera      Kate
* Yako      Maso

(fn &optional ARG)" t)
(register-definition-prefixes "hyrolo" '("hyrolo-"))


;;; Generated autoloads from hyrolo-demo.el

(autoload 'hyrolo-demo-fgrep "hyrolo-demo" "\
Display rolo entries in \"DEMO-ROLO.otl\" matching STRING (or a logical match expression).
Display to a maximum of optional prefix arg MAX-MATCHES.
Each entry is displayed with all of its sub-entries.

Nil value of MAX-MATCHES means find all matches, t value means find all
matches but omit file headers, negative values mean find up to the inverse of
that number of entries and omit file headers.

Returns number of entries matched.  See also documentation for
the function `hyrolo-demo-fgrep-logical' for documentation on the
logical expression matching.

(fn STRING &optional MAX-MATCHES)" t)
(autoload 'hyrolo-demo-fgrep-logical "hyrolo-demo" "\
Display rolo entries in \"DEMO-ROLO.otl\" matching EXPR which may contain prefix logical operators.
If optional COUNT-ONLY is non-nil, don't display entries, return
count of matching entries only.  If optional INCLUDE-SUB-ENTRIES
flag is non-nil, SEXP will be applied across all sub-entries at
once.  Default is to apply SEXP to each entry and sub-entry
separately.  Entries are displayed with all of their sub-entries
unless INCLUDE-SUB-ENTRIES is nil and optional NO-SUB-ENTRIES-OUT
flag is non-nil.

A complex example of EXPR might be:
  (and (or (not time card) (xor (french balloons) spanish)) teacher pet)
which means:
  Match neither `time' nor `card'
    or
  Matches exactly one of `french balloons' or `spanish'
    and
  Matches `teacher' and `pet'.

Either double quotes or parentheses may be used to group multiple words as a
single argument.

(fn EXPR &optional COUNT-ONLY INCLUDE-SUB-ENTRIES NO-SUB-ENTRIES-OUT)" t)
(register-definition-prefixes "hyrolo-demo" '("hyrolo-demo-"))


;;; Generated autoloads from hyrolo-logic.el

(autoload 'hyrolo-fgrep-logical "hyrolo-logic" "\
Display rolo entries matching EXPR, a string, which may contain prefix logical operators.
If optional COUNT-ONLY is non-nil, don't display entries, return
count of matching entries only.  If optional INCLUDE-SUB-ENTRIES
flag is non-nil, SEXP will be applied across all sub-entries at
once.  Default is to apply SEXP to each entry and sub-entry
separately.  Entries are displayed with all of their sub-entries
unless INCLUDE-SUB-ENTRIES is nil and optional NO-SUB-ENTRIES-OUT
flag is non-nil.

A complex example of EXPR might be:
  (and (or (not time card) (xor (and french balloons) spanish)) teacher pet)
which means:
  Match neither `time' nor `card'
    or
  Match exactly one of `french balloons' or `spanish'
    and
  Match `teacher' and `pet'.

Either double quotes or parentheses may be used to group multiple words as a
single argument.

(fn EXPR &optional COUNT-ONLY INCLUDE-SUB-ENTRIES NO-SUB-ENTRIES-OUT)" t)
(register-definition-prefixes "hyrolo-logic" '("hyrolo-"))


;;; Generated autoloads from hyrolo-menu.el

(register-definition-prefixes "hyrolo-menu" '("hyrolo-" "id-" "infodock-hyrolo-menu"))


;;; Generated autoloads from hywconfig.el

(autoload 'hywconfig-add-by-name "hywconfig" "\
Save the current window configuration under the string NAME.
When called interactively and a window configuration already exists under
NAME, confirms whether or not to replace it.

(fn NAME)" t)
(autoload 'hywconfig-delete-by-name "hywconfig" "\
Deletes frame-specific window configuration saved under NAME.

(fn NAME)" t)
(autoload 'hywconfig-restore-by-name "hywconfig" "\
Restore frame-specific window configuration saved under NAME.

(fn NAME)" t)
(autoload 'hywconfig-delete-pop "hywconfig" "\
Replace the current frame's window configuration with the one most recently saved to the ring.
Then deletes this new configuration from the ring." t)
(autoload 'hywconfig-ring-empty-p "hywconfig" "\
Return t if the wconfig ring for the current frame is empty; nil otherwise.")
(autoload 'hywconfig-ring-save "hywconfig" "\
Save the current frame's window configuration onto the save ring.
Use {\\[hywconfig-yank-pop]} to restore it at a later time." t)
(autoload 'hywconfig-yank-pop "hywconfig" "\
Replace the current frame's window configuration with the prefix arg Nth prior one in save ring.
Interactively, default value of N = 1, means the last saved window
configuration is displayed.

The sequence of window configurations wraps around, so that after the
oldest one comes the newest one.

(fn N)" t)
(register-definition-prefixes "hywconfig" '("hywconfig-"))


;;; Generated autoloads from set.el

(autoload 'set:create "set" "\
Return a new set created from any number of ELEMENTS.
If no ELEMENTS are given, return the empty set.  Uses `set:equal-op'
for comparison.

(fn &rest ELEMENTS)")
(register-definition-prefixes "set" '("set:"))

;;; End of scraped data

(provide 'hyperbole-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; hyperbole-autoloads.el ends here
