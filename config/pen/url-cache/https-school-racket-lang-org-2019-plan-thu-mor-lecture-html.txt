HTTP/1.1 200 OK
Date: Wed, 27 Nov 2024 02:54:47 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive
x-amz-id-2: VKWd//0xUwj+HsHgU0Xzl/tMKkQvB3Ad9ZMfLlrLPXWo9UTf6N6c4FUj9dvenJ0IdnBD2VQZnvE=
x-amz-request-id: SK27246DDN5XKDN0
Cache-Control: max-age=0, no-cache
Last-Modified: Sat, 27 Jul 2019 23:29:19 GMT
x-amz-storage-class: REDUCED_REDUNDANCY
cf-cache-status: DYNAMIC
vary: accept-encoding
Report-To: {"endpoints":[{"url":"https:\/\/a.nel.cloudflare.com\/report\/v4?s=7xTwafwlUKBubgz4zAF7sr7B4%2F9k3diOR%2BtG2eupjGvpjMmRMwzIVcTEoqUmrmuk01Z0k9v2yi7KIwbgpXetXKSu1%2FjsEqIa6wh7MJzJjFqGCHJRDCXubY07qXHokXnQjJAq9a2dn2WO"}],"group":"cf-nel","max_age":604800}
NEL: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}
Server: cloudflare
CF-RAY: 8e8ed5eafeb1a7ef-SYD
alt-svc: h3=":443"; ma=86400
server-timing: cfL4;desc="?proto=TCP&rtt=67339&sent=91&recv=26&lost=0&retrans=9&sent_bytes=70161&recv_bytes=1996&delivery_rate=367053&cwnd=161&unsent_bytes=0&cid=7d2157471387f880&ts=417911&x=0"

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>13&nbsp;Types and Type Checking</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Racket School 2019:<span class="mywbr"> &nbsp;</span> <br/>
<span class="Smaller">The &#8220;How to Design Languages&#8221; Track</span></a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="mon-mor-lecture.html" class="tocviewlink" data-pltdoc="x">Language-<wbr></wbr>Oriented Programming</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="mon-mor-lab.html" class="tocviewlink" data-pltdoc="x">Macro Expansion</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="mon-aft-lecture.html" class="tocviewlink" data-pltdoc="x">Language Extensions via Macros</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="mon-aft-lab.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Simple Macros</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="tue-mor-lecture.html" class="tocviewlink" data-pltdoc="x">Advanced Racket Macros</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="tue-mor-lab.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Syntax Patterns &amp; Classes</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="tue-aft-lecture.html" class="tocviewlink" data-pltdoc="x">Lexical Scope, (Un)Hygienic Macros</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="tue-aft-lab.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Comfortable Macros</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="wed-mor-lecture.html" class="tocviewlink" data-pltdoc="x">Modules, Macros, Languages</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="wed-mor-lab.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Languages via Macros</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="wed-aft-lecture.html" class="tocviewlink" data-pltdoc="x">More Language Variations</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="wed-aft-lab.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> Languages and Readers</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Types and Type Checking</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="thu-aft-lecture.html" class="tocviewlink" data-pltdoc="x">Typed Languages with Turnstile</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="thu-aft-lab.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Lab</span> My First Turnstile Language</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="fri-mor-lecture.html" class="tocviewlink" data-pltdoc="x">Two Techniques</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="fri-mor-lab.html" class="tocviewlink" data-pltdoc="x"><span style="font-weight: bold">Extended Lab</span> Regexps</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="fri-aft-lecture.html" class="tocviewlink" data-pltdoc="x">Some Language Gems</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="fri-aft-lab.html" class="tocviewlink" data-pltdoc="x">Closure</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>13&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Types and Type Checking</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">13.1&nbsp;</td><td><a href="#%28part._.An_.Arithmetic_.Expression_.Language%29" class="tocviewlink" data-pltdoc="x">An Arithmetic Expression Language</a></td></tr><tr><td align="right">13.2&nbsp;</td><td><a href="#%28part._.Adding_.Types%29" class="tocviewlink" data-pltdoc="x">Adding Types</a></td></tr><tr><td align="right">13.3&nbsp;</td><td><a href="#%28part._.Typing_.More_.Language_.Features%29" class="tocviewlink" data-pltdoc="x">Typing More Language Features</a></td></tr><tr><td align="right">13.4&nbsp;</td><td><a href="#%28part._bi-di-ti%29" class="tocviewlink" data-pltdoc="x">Bidirectional Type Inference</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">13.1<tt>&nbsp;</tt></span><a href="#%28part._.An_.Arithmetic_.Expression_.Language%29" class="tocsubseclink" data-pltdoc="x">An Arithmetic Expression Language</a></td></tr><tr><td><span class="tocsublinknumber">13.2<tt>&nbsp;</tt></span><a href="#%28part._.Adding_.Types%29" class="tocsubseclink" data-pltdoc="x">Adding Types</a></td></tr><tr><td><span class="tocsublinknumber">13.3<tt>&nbsp;</tt></span><a href="#%28part._.Typing_.More_.Language_.Features%29" class="tocsubseclink" data-pltdoc="x">Typing More Language Features</a></td></tr><tr><td><span class="tocsublinknumber">13.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Variables%29" class="tocsubseclink" data-pltdoc="x">Variables</a></td></tr><tr><td><span class="tocsublinknumber">13.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Functions%29" class="tocsubseclink" data-pltdoc="x">Functions</a></td></tr><tr><td><span class="tocsublinknumber">13.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Recursion%29" class="tocsubseclink" data-pltdoc="x">Recursion</a></td></tr><tr><td><span class="tocsublinknumber">13.4<tt>&nbsp;</tt></span><a href="#%28part._bi-di-ti%29" class="tocsubseclink" data-pltdoc="x">Bidirectional Type Inference</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.4.0.4</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="wed-aft-lab.html" title="backward to &quot;12 Lab Languages and Readers&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Racket School 2019: 

The “How to Design Languages” Track&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="thu-aft-lecture.html" title="forward to &quot;14 Typed Languages with Turnstile&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>13<tt>&nbsp;</tt><a name="(part._thu-mor-lecture)"></a>Types and Type Checking</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Jesse Tov</p></span></div><p><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><p><span style="font-weight: bold">Goals</span></p></td></tr><tr><td><p> &#8212;<wbr></wbr> why we might want a type system</p></td></tr><tr><td><p> &#8212;<wbr></wbr> how we can write a one down as rules</p></td></tr><tr><td><p> &#8212;<wbr></wbr> how to think about designing those rules</p></td></tr><tr><td><p> &#8212;<wbr></wbr> how to turn the rules into an algorithm</p></td></tr><tr><td><p> &#8212;<wbr></wbr> how and why to make the algorithm <span style="font-style: italic">bidirectional</span></p></td></tr></table></p><h4>13.1<tt>&nbsp;</tt><a name="(part._.An_.Arithmetic_.Expression_.Language)"></a>An Arithmetic Expression Language</h4><p>We&rsquo;re going to start with the simplest language that can demonstrate
all the phenomena we care about. It&rsquo;s a language of arithmetic expressions
with integers and Booleans. Call it <span class="stt">ZB</span>:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_34.svg" type="image/svg+xml"/></p></blockquote><p>Except for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_35.svg" type="image/svg+xml"/>, we can understand this language as a subset
of Racket. Like Racket, it has integer literals, boolean literals,
addition, division, less-than-or-equal comparison, and <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_36.svg" type="image/svg+xml"/>.</p><p>What is <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_37.svg" type="image/svg+xml"/>? A single integer, provided from outside
the program. You can think of a program in this language as a function
that takes a single, integer-valued argument named <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_38.svg" type="image/svg+xml"/>.
Without <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_39.svg" type="image/svg+xml"/>, the result of every expression can be known
immediately; we include it so that what follows won&rsquo;t be trivial.</p><blockquote class="SubFlow"><p><a name="(counter._(exercise._zb-errors))"></a><span style="font-weight: bold">Exercise</span>&nbsp;33. Enumerate and characterize the potential errors in a
<span class="stt">ZB</span> program. <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_40.svg" type="image/svg+xml"/></p></blockquote><blockquote class="SubFlow"><p><a name="(counter._(exercise._zb-error-analysis))"></a><span style="font-weight: bold">Exercise</span>&nbsp;34. Some <span class="stt">ZB</span> programs, like <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_41.svg" type="image/svg+xml"/> and <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_42.svg" type="image/svg+xml"/>,
always have errors, regardless of the input.
Some, like <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_43.svg" type="image/svg+xml"/> and <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_44.svg" type="image/svg+xml"/>
never have errors, regardless of the input.
Find a program that errors on some inputs and not others. <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_45.svg" type="image/svg+xml"/></p></blockquote><h4>13.2<tt>&nbsp;</tt><a name="(part._.Adding_.Types)"></a>Adding Types</h4><p>There are a variety of ways we could statically check a <span class="stt">ZB</span> program for
errors. The strongest analysis we could do would tell us the set of
inputs that produce an error&#8212;<wbr></wbr>the set may be a finite subset of the
integers or the complement of a finite set (cofinite). However, that
kind of analysis is only tractable because <span class="stt">ZB</span> is extremely weak. This
morning, we&rsquo;re going to learn about analyses that are, by definition,
tractable: type systems.</p><p>Here&rsquo;s a simple recipe for designing a type system:</p><ul><li><p>First, classify the values of our language in some way; call these
classes types.</p></li><li><p>Second, classify expressions in your language by the types
of values that they compute. Do this compositionally, meaning that
the type of each expression can be computed from the types of its
subexpressions.
(Typically, if you can&rsquo;t figure it out for a particular program then
you give up and reject that program.)</p></li></ul><p>When we design a type system, we have a choice
for the granularity of the classifications. We need
to think about what&rsquo;s relevant to our language&rsquo;s operations. For example,
to know that <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_46.svg" type="image/svg+xml"/> will succeed, we need to know that
<img style="vertical-align: -3.75px; margin: -3px -3px -3px -3px;" src="pict_47.svg" type="image/svg+xml"/> and <img style="vertical-align: -3.75px; margin: -3px -3px -3px -3px;" src="pict_48.svg" type="image/svg+xml"/> both evaluate to integers, so it would be helpful
to have a type for that; we&rsquo;ll call it <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_49.svg" type="image/svg+xml"/>. And we need some other
type for the result of <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_50.svg" type="image/svg+xml"/> to prevent Booleans from flowing into
additions; we&rsquo;ll call that type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_51.svg" type="image/svg+xml"/>. So, we define just two
types <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_52.svg" type="image/svg+xml"/> for <span class="stt">ZB</span>:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_53.svg" type="image/svg+xml"/></p></blockquote><p>(We could increase the granularity by considering more operations and
sets of values&#8212;<wbr></wbr>for example, it might be interesting to give non-zero
integers their own type&#8212;<wbr></wbr>but that quickly causes the system&rsquo;s
complexity to explode. <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_54.svg" type="image/svg+xml"/> is a simple choice that works
well.)</p><p>That&rsquo;s step one. Step two is to figure out how to classify
<span class="stt">ZB</span> expressions by types. We do this by defining a <span style="font-style: italic">judgment</span>, a relation that connects expressions to types.
The notation will be <img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_55.svg" type="image/svg+xml"/>, which we read as
&ldquo;expression <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_56.svg" type="image/svg+xml"/> has type <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_57.svg" type="image/svg+xml"/>.&rdquo; For example, we
would say that <img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_58.svg" type="image/svg+xml"/> and
<img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_59.svg" type="image/svg+xml"/>, but it would be wrong to
say <img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_60.svg" type="image/svg+xml"/>.</p><blockquote class="SubFlow"><p><div class="SIntrapara"><a name="(counter._(exercise._zb-judgment))"></a><span style="font-weight: bold">Exercise</span>&nbsp;35. What, <span style="font-weight: bold">if anything,</span> do you think <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_61.svg" type="image/svg+xml"/> should
be in each of these judgments
</div><div class="SIntrapara"><ul><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_62.svg" type="image/svg+xml"/></p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_63.svg" type="image/svg+xml"/></p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_64.svg" type="image/svg+xml"/></p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_65.svg" type="image/svg+xml"/></p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_66.svg" type="image/svg+xml"/></p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_67.svg" type="image/svg+xml"/></p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_68.svg" type="image/svg+xml"/></p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_69.svg" type="image/svg+xml"/></p></li></ul></div><div class="SIntrapara"><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_70.svg" type="image/svg+xml"/></div></p></blockquote><p>The usual way to define a typing judgment like
<img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_71.svg" type="image/svg+xml"/> is using logical inference rules. A
logical inference rule says that a particular conclusion can
be derived from some premisses. The conclusion&#8212;<wbr></wbr>a
judgment&ndash;is written below a horizontal line; a sequence of
<span style="font-style: italic">premisses</span>&#8212;<wbr></wbr>more judgments and the occasional logical
expression, sufficient to reach the conclusion&#8212;<wbr></wbr>are written
above the line. Our first two rules let us conclude that the
type of any integer literal is <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_72.svg" type="image/svg+xml"/> and the type of
any Boolean literal is <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_73.svg" type="image/svg+xml"/>:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_74.svg" type="image/svg+xml"/></p></blockquote><p>Note that there are no premisses above the lines because these judgments are
true for every literal of the right form. Similarly, we conclude that
<img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_75.svg" type="image/svg+xml"/> has type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_76.svg" type="image/svg+xml"/>:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_77.svg" type="image/svg+xml"/></p></blockquote><p>The remaining rules require premisses. For example, successful addition
expression always produces an integer, but that depends on its
subexpressions producing integers. So we have a rule that says that
an expression <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_78.svg" type="image/svg+xml"/> has type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_79.svg" type="image/svg+xml"/> whenever both
of its subexpressions have type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_80.svg" type="image/svg+xml"/> (and likewise for division):</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_81.svg" type="image/svg+xml"/></p></blockquote><p>Yes, you read this correctly: according to the typing rule,
division always produces an <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_82.svg" type="image/svg+xml"/>. That&rsquo;s okay, because
if a program actually divides by 0, it gets terminated,
rendering the type of the division expression irrelevant.</p><p>Finally, we give two rules for typing conditionals:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_83.svg" type="image/svg+xml"/></p></blockquote><blockquote class="SubFlow"><p><a name="(counter._(exercise._zb-discuss-if))"></a><span style="font-weight: bold">Exercise</span>&nbsp;36. Articulate the <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_84.svg" type="image/svg+xml"/> rules in English.
Do they make sense? Is there a better way to write the rules? <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_85.svg" type="image/svg+xml"/></p></blockquote><blockquote class="SubFlow"><p><a name="(counter._(exercise._zb-type-cmp))"></a><span style="font-weight: bold">Exercise</span>&nbsp;37. Write a type inference rule for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_86.svg" type="image/svg+xml"/>. <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_87.svg" type="image/svg+xml"/></p></blockquote><h4>13.3<tt>&nbsp;</tt><a name="(part._.Typing_.More_.Language_.Features)"></a>Typing More Language Features</h4><p>Most programming languages have more features than ZB, such as:</p><ul><li><p>More base types, such as strings and inexact numbers</p></li><li><p>Variables</p></li><li><p>Functions</p></li><li><p>Recursion and/or Loops</p></li><li><p>More compound types, such as tuples or records</p></li></ul><p>The first of these can be done with what you&rsquo;ve already seen, and the
last we will save for exercises. For others, however, we&rsquo;ll need a few
more ideas. In the next three subsections we&rsquo;ll see how our type system
can handle variables, functions, and recursion.</p><h5>13.3.1<tt>&nbsp;</tt><a name="(part._.Variables)"></a>Variables</h5><p>In order to extend our typed language with variables, we need a way
to keep track of their types. We&rsquo;ll use a type environment, which
is a mapping from the currently bound variable names to their types.
You can think of it like a partial function from names to types, but
we&rsquo;re going to define it syntactically:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_88.svg" type="image/svg+xml"/></p></blockquote><p>We write <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_89.svg" type="image/svg+xml"/> for the type environment whose domain is empty,
and <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_90.svg" type="image/svg+xml"/> for a type environment that is the same as
<img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_91.svg" type="image/svg+xml"/> except for all the <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_92.svg" type="image/svg+xml"/>s, which it maps to their
corresponding <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_93.svg" type="image/svg+xml"/>s instead.</p><p>For example, the type environment
<img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_94.svg" type="image/svg+xml"/>
that variable <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_95.svg" type="image/svg+xml"/> has type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_96.svg" type="image/svg+xml"/> and variable <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_97.svg" type="image/svg+xml"/> has
type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_98.svg" type="image/svg+xml"/>.</p><p>Then we can extending <span class="stt">ZB</span> with variables and single-variable
<img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_99.svg" type="image/svg+xml"/> expressions:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.75px; margin: -3px -3px -3px -3px;" src="pict_100.svg" type="image/svg+xml"/></p></blockquote><p>How does the type system work? The typing judgment now keeps track
of variables and their types using a type environment. We&rsquo;ll write
<img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_101.svg" type="image/svg+xml"/> to mean that expression <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_102.svg" type="image/svg+xml"/> has type
<img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_103.svg" type="image/svg+xml"/> given the variables in <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_104.svg" type="image/svg+xml"/> have the types listed there.
Thus, binders (like <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_105.svg" type="image/svg+xml"/>) and variable occurences communicate
via <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_106.svg" type="image/svg+xml"/>. The type of a variable must given by the type
environment:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_107.svg" type="image/svg+xml"/></p></blockquote><p>The rule for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_108.svg" type="image/svg+xml"/> is more complicated:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_109.svg" type="image/svg+xml"/></p></blockquote><p>For an expression <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_110.svg" type="image/svg+xml"/> to be well
typed in some type environment <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_111.svg" type="image/svg+xml"/>, the sub-expression <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_112.svg" type="image/svg+xml"/>
must have a type in the same type environment. But the sub-expression
<img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_113.svg" type="image/svg+xml"/> has access to an environment where <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_114.svg" type="image/svg+xml"/> is extended
with <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_115.svg" type="image/svg+xml"/>, which has the same type that <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_116.svg" type="image/svg+xml"/> has. And in
that case,
the whole expression has the same type that <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_117.svg" type="image/svg+xml"/> has.</p><p>The remaining rules are the same as for <span class="stt">ZB</span>, but they pass the type
environment through. For example:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_118.svg" type="image/svg+xml"/></p></blockquote><h5>13.3.2<tt>&nbsp;</tt><a name="(part._.Functions)"></a>Functions</h5><p>The next feature we&rsquo;d like to add is functions. As with local variables,
the new syntax comes in pairs&#8212;<wbr></wbr>we need a way to create a function and
a way to use one. So we&rsquo;ll use Racket&rsquo;s syntax for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_119.svg" type="image/svg+xml"/> and
function application:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_120.svg" type="image/svg+xml"/></p></blockquote><p>Now our language has values that it didn&rsquo;t have before, and that are neither
integers nor Booleans, which means we need a new type. The simplest choice
is to extend our type syntax to include arrow types:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_121.svg" type="image/svg+xml"/></p></blockquote><p>We want to say that a value has type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_122.svg" type="image/svg+xml"/> when
1) it&rsquo;s a procedure whose arity is <span style="font-style: italic">k</span>, and
and 2) if applied to <span style="font-style: italic">k</span> values of type are <img style="vertical-align: -3.75px; margin: -3px -3px -3px -3px;" src="pict_123.svg" type="image/svg+xml"/> through
<img style="vertical-align: -3.75px; margin: -3px -3px -3px -3px;" src="pict_124.svg" type="image/svg+xml"/>, the result (if any!) will be a value of type <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_125.svg" type="image/svg+xml"/>.
The typing rule for applications extends this intuition from values
to expressions:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_126.svg" type="image/svg+xml"/></p></blockquote><p>Since a <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_127.svg" type="image/svg+xml"/> expression produces a function, it should have an arrow
type that matches its arity. Furthermore, the body of the <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_128.svg" type="image/svg+xml"/> can
see both the <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_129.svg" type="image/svg+xml"/>&rsquo;s surrounding context and its formal parameters, so
the body is typed in a type environment where the formal parameters have
types matching the domains of the arrow type. The result type of the body
must, of course, match the codomain of the arrow type. Like this:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_130.svg" type="image/svg+xml"/></p></blockquote><p>The above rule is great! It&rsquo;s true, it&rsquo;s correct, and it will never
lead you wrong. The problem, however, is that it might not lead you
anyplace at all. Up until now, I&rsquo;ve presented the type system from
a logical perspective&#8212;<wbr></wbr>it&rsquo;s a three-way relation&#8212;<wbr></wbr>but I haven&rsquo;t
actually given you an algorithm. But in fact, the typing judgment
(<img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_131.svg" type="image/svg+xml"/>) before we added the rule for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_132.svg" type="image/svg+xml"/> has an
easy algorithm if you read it as a function from two arguments (<img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_133.svg" type="image/svg+xml"/>
and <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_134.svg" type="image/svg+xml"/>) to one result <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_135.svg" type="image/svg+xml"/>.</p><p>Adding the above <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_136.svg" type="image/svg+xml"/> rule breaks that property, because you need
to know the <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_137.svg" type="image/svg+xml"/>s to check <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_138.svg" type="image/svg+xml"/> in the premiss, but the <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_139.svg" type="image/svg+xml"/>s
only appear in an &ldquo;out&rdquo; position of the conclusion of the rule.</p><p>We&rsquo;ll adopt two complementary strategies to solve this problem. In this
section, we enrich the syntax of <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_140.svg" type="image/svg+xml"/> expressions (diverging from
Racket) to contain the information that we need. Then, in
<a href="#%28part._bi-di-ti%29" data-pltdoc="x">Bidirectional Type Inference</a>, we will modify our typing relation so that the
context can provide a &ldquo;hint&rdquo; to an unnannotated a <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_141.svg" type="image/svg+xml"/> expression
about what its type should be.</p><p>In the first approach, we add require that each of a <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_142.svg" type="image/svg+xml"/>&rsquo;s formal
parameters have a type annotation:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_143.svg" type="image/svg+xml"/></p></blockquote><p>Then, we just use the type annotations as the types of the formal
parameters for checking the body:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_144.svg" type="image/svg+xml"/></p></blockquote><p>This rule, for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_145.svg" type="image/svg+xml"/> with type annotations, means that our typing
relation again gives us an algorithm. Next, I&rsquo;ll show you how a
slightly more sophisticated algorithm can take advantage of contextual
information to let you omit some type annotations.</p><h5>13.3.3<tt>&nbsp;</tt><a name="(part._.Recursion)"></a>Recursion</h5><p>In an untyped, higher-order language (like Racket or the &#955; calculus),
it&rsquo;s possible to do recursion using a fixpoint combinator (like Y)
even if you don&rsquo;t include any recursive binding forms. But many type
systems, including the one we&rsquo;re working with, can&rsquo;t give the Y
combinator a type. Instead, recursion must be built-in somehow.</p><p>One way is with a recursive binding form. For example, we might add
an expression form <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_146.svg" type="image/svg+xml"/> that evaluates <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_147.svg" type="image/svg+xml"/> so that
uses of <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_148.svg" type="image/svg+xml"/> inside of <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_149.svg" type="image/svg+xml"/> are bound to the
value of <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_150.svg" type="image/svg+xml"/>. (This means those uses have to be delayed,
typically under a &#955;, so that the value of <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_151.svg" type="image/svg+xml"/> isn&rsquo;t needed before
it&rsquo;s ready. The Racket equivalent is <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_152.svg" type="image/svg+xml"/>.)</p><blockquote class="SubFlow"><p><a name="(counter._(exercise._typing-rec-rule))"></a><span style="font-weight: bold">Exercise</span>&nbsp;38. Using the techniques we&rsquo;ve seen so far, it&rsquo;s possible to write a typing
rule for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_153.svg" type="image/svg+xml"/>, but like the rule above for unannotated
&#955;, that doesn&rsquo;t give an algorithm. Write the rule and see that
it needs to &ldquo;guess&rdquo; the type of <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_154.svg" type="image/svg+xml"/> in order to figure out
the type of <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_155.svg" type="image/svg+xml"/>. <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_156.svg" type="image/svg+xml"/></p></blockquote><blockquote class="SubFlow"><p><a name="(counter._(exercise._typing-rec-algo))"></a><span style="font-weight: bold">Exercise</span>&nbsp;39. Show that adding a type annotation to the <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_157.svg" type="image/svg+xml"/> form makes it
possible to write an algorithmic rule that doesn&rsquo;t have to guess. <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_158.svg" type="image/svg+xml"/></p></blockquote><h4>13.4<tt>&nbsp;</tt><a name="(part._bi-di-ti)"></a>Bidirectional Type Inference</h4><p>Above we saw how to type <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_159.svg" type="image/svg+xml"/> by adding type annotations
to its formal parameters. Our goal going forward is to
<span style="font-style: italic">reduce</span> the number of mandatory type annotations.
Often, the information provided by a type annotation can be
acquired from the context instead, and if we can do that, it
can help make our language more pleasant to use.</p><p>We can think of types in the type system above as flowing in
one direction: upward, to each expression from its sub-expressions.
In birectional type inference, we define a second relation by which
the type flows downward, from an expression to (some of) its
subexpressions. Thus, the new system will be <span style="font-style: italic">bidirectional</span>.</p><p>In particular, we will define the type system as a pair of
mutually-recursive relations having different <span style="font-style: italic">modes</span>:</p><ul><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_160.svg" type="image/svg+xml"/>
<span style="font-style: italic">infers</span> type <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_161.svg" type="image/svg+xml"/> from the given <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_162.svg" type="image/svg+xml"/> and <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_163.svg" type="image/svg+xml"/>.</p></li><li><p><img style="vertical-align: -4.064453125px; margin: -3px -3px -3px -3px;" src="pict_164.svg" type="image/svg+xml"/>
<span style="font-style: italic">checks</span> the given <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_165.svg" type="image/svg+xml"/>, <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_166.svg" type="image/svg+xml"/>, and <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_167.svg" type="image/svg+xml"/>.</p></li></ul><p>Before presenting the algorithm, let&rsquo;s simplify and restate our
language. Now that we have functions and variables, we can specify
many operations as primitive functions in some initial environment
<img style="vertical-align: -3.75px; margin: -3px -3px -3px -3px;" src="pict_168.svg" type="image/svg+xml"/>:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_169.svg" type="image/svg+xml"/></p></blockquote><p>Here is our new language, <span class="stt">&#955;</span><span style="vertical-align: sub; font-size: 80%">ZB&#8594;</span>, in full:</p><blockquote class="SCentered"><p><img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_170.svg" type="image/svg+xml"/></p></blockquote><p>It has one new form, <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_171.svg" type="image/svg+xml"/>, which has type <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_172.svg" type="image/svg+xml"/>
when <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_173.svg" type="image/svg+xml"/> also has type <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_174.svg" type="image/svg+xml"/>. This new form isn&rsquo;t strictly
needed, but as we will see, <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_175.svg" type="image/svg+xml"/> provides a convenient bridge
between inferring and checking.</p><p>Now let&rsquo;s see the type system, starting with the inference (upward)
direction. Some of the rules are the same as before, so let&rsquo;s get
through those first:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_176.svg" type="image/svg+xml"/></p></blockquote><p>The remaining compute-mode rules, on the other hand, have
premisses that switch to check mode. The compute-mode
rule for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_177.svg" type="image/svg+xml"/> <span style="font-style: italic">checks</span> that condition has type
<img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_178.svg" type="image/svg+xml"/> and <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_179.svg" type="image/svg+xml"/> types for the two branches,
succeeding only when they agree:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_180.svg" type="image/svg+xml"/></p></blockquote><p>The final two compute-mode rules are the most interesting, as
they can push (non-trivial) expected types into check-mode
premisses:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_181.svg" type="image/svg+xml"/></p></blockquote><p>The rule for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_182.svg" type="image/svg+xml"/> <span style="font-style: italic">checks</span> that <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_183.svg" type="image/svg+xml"/> has type <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_184.svg" type="image/svg+xml"/>.
The rule for application first <span style="font-style: italic">infers</span> a type for the operator
(<img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_185.svg" type="image/svg+xml"/>), which must be an arrow type whose arity matches the
number of operands (<img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_186.svg" type="image/svg+xml"/>). Then the rule <span style="font-style: italic">checks</span> each of
the operands against the corresponding type <img style="vertical-align: -3.603515625px; margin: -3px -3px -3px -3px;" src="pict_187.svg" type="image/svg+xml"/>.</p><p>That completes the rules for the compute-mode judgment. For the
check mode judgment, let&rsquo;s see the most interesting rule first,
which can check a <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_188.svg" type="image/svg+xml"/> without argument type annotations based
on the type it&rsquo;s expected to have:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_189.svg" type="image/svg+xml"/></p></blockquote><p>We also want rules for propagating an expected type (or
parts thereof) into subexpressions where that might let us
omit some type annotations. For example, if we know the
expected type of a <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_190.svg" type="image/svg+xml"/> expression, then we know the
expected type of its body:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_191.svg" type="image/svg+xml"/></p></blockquote><p>Other expression forms, such as <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_192.svg" type="image/svg+xml"/>, can benefit from
check-mode rules&#8212;<wbr></wbr>we&rsquo;ll leave those cases for exercises.
However, many forms don&rsquo;t benefit from their own
check-mode rule, because it&rsquo;s just as good to delegate
back to compute mode:</p><blockquote class="SCentered"><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_193.svg" type="image/svg+xml"/></p></blockquote><p>Unlike other rules we&rsquo;ve seen, this delegation rule isn&rsquo;t
limited to a particular syntactic form for the expression in
its conclusion, which means that it can apply to any form of
expression, including those covered by the other
check-mode rules. From a logical perspective, it isn&rsquo;t
harmful (if we&rsquo;ve been careful) because in every case where
compute mode can succeed (via the delegation), the
check-mode rules give the same result. Algorithmically,
this means that we can avoid considering the delegation rule
for expression forms that are covered by more specific
check-mode rules.</p><blockquote class="SubFlow"><p><a name="(counter._(exercise._type-if-check))"></a><span style="font-weight: bold">Exercise</span>&nbsp;40. Write the missing check-mode rule for <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_194.svg" type="image/svg+xml"/> expressions. <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_195.svg" type="image/svg+xml"/></p></blockquote><blockquote class="SubFlow"><p><a name="(counter._(exercise._type-strings))"></a><span style="font-weight: bold">Exercise</span>&nbsp;41. Add string literals and a string type to the language and type
system. Then give types for these primitive functions:
<img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_196.svg" type="image/svg+xml"/>, <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_197.svg" type="image/svg+xml"/>, and <img style="vertical-align: -3.974609375px; margin: -3px -3px -3px -3px;" src="pict_198.svg" type="image/svg+xml"/>. <img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_199.svg" type="image/svg+xml"/></p></blockquote><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="wed-aft-lab.html" title="backward to &quot;12 Lab Languages and Readers&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Racket School 2019: 

The “How to Design Languages” Track&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="thu-aft-lecture.html" title="forward to &quot;14 Typed Languages with Turnstile&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>
