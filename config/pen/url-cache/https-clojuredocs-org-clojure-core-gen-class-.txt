HTTP/1.1 200 OK
Date: Sat, 10 Sep 2022 00:26:58 GMT
Content-Type: text/html;charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive
Set-Cookie: ring-session=ndzrU%2BjX3AghCfIegmCB5KJHxmPw5Zuq2KLkNo9zSXfeNSUPiASpY8s5xal%2Bh1UThJTYjgqQMLIOE50EOtBM4JwtlQgzVWj8fIe0bymXu2xCnGTqCrQt6yVKsk%2FbpbL4--tUP0UIqPUXetYpybThwog82VvZtjkSSOzqlqNXI5p3Q%3D;Path=/;HttpOnly
CF-Cache-Status: DYNAMIC
Report-To: {"endpoints":[{"url":"https:\/\/a.nel.cloudflare.com\/report\/v3?s=iAZpIwhUqDootl%2BBA5lWsaOw1QKnCe8GG3btE2qKxL9s4MOeMPUYNGHNQ7ABsSbAp2TFO9ozipmcbaeayEdXzi4e8rPLJuO5PS4X6vHvkPBUIf3IzTd7AFHdOlv65TaOFzIoYBAJzSfp79IsPqk%3D"}],"group":"cf-nel","max_age":604800}
NEL: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}
Server: cloudflare
CF-RAY: 74840903ab51a87c-SYD
alt-svc: h3=":443"; ma=86400, h3-29=":443"; ma=86400

<!DOCTYPE html>
<html><head><meta content="width=device-width, maximum-scale=1.0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="default" name="apple-mobile-web-app-status-bar-style"><meta content="ClojureDocs" name="apple-mobile-web-app-title"><meta content="XjzqkjEPtcgtLjhnqAvtnVSeveEccs-O_unFGGlbk4g" name="google-site-verification"><title>gen-class - clojure.core | ClojureDocs - Community-Powered Clojure Documentation and Examples</title><link href="/opensearch.xml" rel="search" title="ClojureDocs" type="application/opensearchdescription+xml"><link href="/css/font-awesome.min.css?bbfef9385083d307ad2692c0cf99f611" rel="stylesheet"><link href="/css/bootstrap.min.css?385b964b68acb68d23cb43a5218fade9" rel="stylesheet"><link href="/css/app.css?9e9d4de52804fa9bff22ecaa7badf8f9" rel="stylesheet"><script>// <![CDATA[
window.PAGE_DATA="{:examples [{:var {:library-url \"https://github.com/clojure/clojure\", :name \"gen-class\", :ns \"clojure.core\"}, :author {:login \"devijvers\", :account-source \"clojuredocs\", :avatar-url \"https://www.gravatar.com/avatar/81018e4231ac1ce8b7a9e6d377092656?r=PG&default=identicon\"}, :editors [{:login \"devijvers\", :account-source \"clojuredocs\", :avatar-url \"https://www.gravatar.com/avatar/81018e4231ac1ce8b7a9e6d377092656?r=PG&default=identicon\"} {:login \"devijvers\", :account-source \"clojuredocs\", :avatar-url \"https://www.gravatar.com/avatar/81018e4231ac1ce8b7a9e6d377092656?r=PG&default=identicon\"} {:login \"jafingerhut\", :account-source \"github\", :avatar-url \"https://avatars.githubusercontent.com/u/109629?v=3\"}], :body \"(gen-class\\n\\t:name \\\"some.package.RefMap\\\"\\n\\t:implements [java.util.Map]\\n\\t:state \\\"state\\\"\\n\\t:init \\\"init\\\"\\n\\t:constructors {[] []}\\n\\t:prefix \\\"ref-map-\\\")\\n\\n(defn ref-map-init []\\n\\t[[] (ref {})])\\n\\n(defn ref-map-size [this]\\n\\t(let [state (.state this)] (.size @state)))\\n\\t\\n(defn ref-map-isEmpty [this]\\n\\t(let [state (.state this)] (.isEmpty @state)))\\n\\n(defn ref-map-containsKey [this o]\\n\\t(let [state (.state this)] (.containsKey @state o)))\\n\\t\\n(defn ref-map-containsValue [this o]\\n\\t(let [state (.state this)] (.containsValue @state o)))\\n\\t\\n(defn ref-map-get [this o]\\n\\t(let [state (.state this)] (.get @state o)))\\n\\t\\n(defn ref-map-keySet [this]\\n\\t(let [state (.state this)] (.keySet @state)))\\n\\t\\n(defn ref-map-values [this]\\n\\t(let [state (.state this)] (.values @state)))\\n\\t\\n(defn ref-map-entrySet [this]\\n\\t(let [state (.state this)] (.entrySet @state)))\\n\\t\\n(defn ref-map-equals [this o]\\n\\t(let [state (.state this)] (.equals @state o)))\\n\\t\\n(defn ref-map-hashCode [this]\\n\\t(let [state (.state this)] (.hashCode @state)))\\n\\t\\n(defn ref-map-put [this k v]\\n\\t(let [state (.state this)] \\n\\t\\t(dosync (alter state assoc k v)) v))\\n\\t\\n(defn ref-map-putAll [this m]\\n\\t(let [state (.state this)]\\n\\t\\t(doseq [[k v] (map identity m)] (.put this k v))))\\n\\t\\t\\n(defn ref-map-remove [this o]\\n\\t(let [state (.state this) v (get @state o)] \\n\\t\\t(dosync (alter state dissoc o)) v))\\n\\t\\n(defn ref-map-clear [this]\\n\\t(let [state (.state this)] \\n\\t\\t(dosync (ref-set state {}))))\\n\\t\\n(defn ref-map-toString [this]\\n\\t(let [state (.state this)] (.toString @state)))\", :created-at 1279770352000, :updated-at 1332952789000, :_id \"542692cec026201cdc326dab\", :user nil} {:var {:library-url \"https://github.com/clojure/clojure\", :name \"gen-class\", :ns \"clojure.core\"}, :author {:login \"daviddurand\", :account-source \"github\", :avatar-url \"https://avatars.githubusercontent.com/u/1316941?v=2\"}, :editors [], :body \";; I found managing state a bit confusing at first.\\n;; here's a dumb little class with a getter and setter for a \\\"location\\\" field.\\n\\n(ns com.example )\\n\\n(gen-class\\n      :name com.example.Demo\\n      :state state\\n      :init init\\n      :prefix \\\"-\\\"\\n      :main false\\n      ;; declare only new methods, not superclass methods\\n      :methods [[setLocation [String] void]\\n                [getLocation [] String]])\\n\\n;; when we are created we can set defaults if we want.\\n(defn -init []\\n  \\\"store our fields as a hash\\\"\\n  [[] (atom {:location \\\"default\\\"})])\\n\\n;; little functions to safely set the fields.\\n(defn setfield\\n  [this key value]\\n      (swap! (.state this) into {key value}))\\n\\n(defn getfield\\n  [this key]\\n  (@(.state this) key))\\n\\n;; \\\"this\\\" is just a parameter, not a keyword\\n(defn -setLocation [this loc]\\n  (setfield this :location loc))\\n\\n(defn  -getLocation\\n  [this]\\n  (getfield this :location))\\n\\n;; running it -- you must compile and put output on the classpath\\n;; create a Demo, check the default value, then set it and check again.\\nuser=> (def ex (com.example.Demo.))\\n#'user/ex\\nuser=> (.getLocation ex)\\n\\\"default\\\"\\nuser=> (.setLocation ex \\\"time\\\")\\nnil\\nuser=> (.getLocation ex)\\n\\\"time\\\"\\n\", :created-at 1325884685000, :updated-at 1325884685000, :_id \"542692d3c026201cdc326fbb\", :user nil} {:editors [{:login \"mars0i\", :account-source \"github\", :avatar-url \"https://avatars0.githubusercontent.com/u/1836941?v=4\"}], :var {:ns \"clojure.core\", :name \"gen-class\", :library-url \"https://github.com/clojure/clojure\"}, :body \";; This example illustrates the syntax intended by the docstring's remark that \\n;; \\\"Static methods can be specified with ^{:static true} in the signature's \\n;; metadata\\\", and notes a case in which you might not think that you need to use\\n;; :methods.\\n\\n;; The docs say, about :methods, \\\"Do not repeat superclass/interface\\n;; signatures here.\\\"  That applies to non-static methods.  If you want to\\n;; define a static method to hide a static method in the superclass, you\\n;; are not overriding the superclass method (the behavior is different).\\n;; You are simply defining a new method with the same name.  In this case,\\n;; you should add a signature to :methods if you want your function to be\\n;; visible to Java, with metadata indicating that it is static placed\\n;; before the signature vector:\\n\\n(ns \\n  ...\\n  (:gen-class \\n    ...\\n    :methods [[...] ...\\n              ^{:static true} [name [] java.lang.String]\\n              [...] ...]\\n    ...))\\n\\n(defn -name [] \\\"My name is Foo\\\")\\n\\n;; Also note that you can replace \\\"^{:static true}\\\" with \\\"^:static\\\".\", :author {:avatar-url \"https://avatars0.githubusercontent.com/u/1836941?v=4\", :account-source \"github\", :login \"mars0i\"}, :created-at 1554533983608, :updated-at 1554575687135, :_id \"5ca84e5fe4b0ca44402ef6fe\", :user nil} {:updated-at 1558971581245, :created-at 1558971581245, :author {:login \"holyjak\", :account-source \"github\", :avatar-url \"https://avatars1.githubusercontent.com/u/624958?v=4\"}, :body \";; It is possible to attach Java annotations to the class,\\n;; constructors, and methods \\n;; Source: https://github.com/clojure/clojure/blob/8af7e9a92570eb28c58b15481ae9c271d891c028/test/clojure/test_clojure/genclass/examples.clj#L34\\n(gen-class :name ^{Deprecated {}\\n                   SuppressWarnings [\\\"Warning1\\\"] ; discarded\\n                   java.lang.annotation.Target []}\\n                 clojure.test_clojure.genclass.examples.ExampleAnnotationClass\\n           :prefix \\\"annot-\\\"\\n           :methods [[^{Deprecated {}\\n                        Override {}} ;discarded\\n                      foo [^{java.lang.annotation.Retention java.lang.annotation.RetentionPolicy/SOURCE\\n                             java.lang.annotation.Target    [java.lang.annotation.ElementType/TYPE\\n                                                             java.lang.annotation.ElementType/PARAMETER]}\\n                           String] void]])\\n\", :var {:library-url \"https://github.com/clojure/clojure\", :name \"gen-class\", :ns \"clojure.core\"}, :_id \"5cec04bde4b0ca44402ef72b\", :user nil} {:updated-at 1625726462164, :created-at 1625726462164, :author {:login \"mattiuusitalo\", :account-source \"github\", :avatar-url \"https://avatars.githubusercontent.com/u/47240847?v=4\"}, :body \";; Defining a custom constructor which calls a superclass constructor:\\n(ns my.CustomException\\n  (:gen-class\\n   :implements [clojure.lang.IExceptionInfo]\\n   :extends java.lang.RuntimeException\\n   :constructors {[String Throwable clojure.lang.IPersistentMap] [String Throwable]} ; mapping of my-constructor -> superclass constuctor\\n   :init init\\n   :state state ; name for the var that holds your internal state\\n   :main false\\n   :prefix \\\"my-ex-\\\"))\\n\\n(defn my-ex-init [msg t context]\\n  ;; first element of vector contains parameters for the superclass constructor\\n  ;; Second element will be your internal state \\n  [[msg t] context]) \\n\\n(defn my-ex-getData [this]\\n  (.state this)) ; accessing the internal state\\n\", :var {:library-url \"https://github.com/clojure/clojure\", :name \"gen-class\", :ns \"clojure.core\"}, :_id \"60e69dfee4b0b1e3652d7513\", :user nil}], :var {:added \"1.0\", :ns \"clojure.core\", :name \"gen-class\", :file \"clojure/genclass.clj\", :type \"macro\", :keywords \"gen-class gen class\", :column 1, :line 507, :macro true, :arglists (\"& options\"), :doc \"When compiling, generates compiled bytecode for a class with the\\n  given package-qualified :name (which, as all names in these\\n  parameters, can be a string or symbol), and writes the .class file\\n  to the *compile-path* directory.  When not compiling, does\\n  nothing. The gen-class construct contains no implementation, as the\\n  implementation will be dynamically sought by the generated class in\\n  functions in an implementing Clojure namespace. Given a generated\\n  class org.mydomain.MyClass with a method named mymethod, gen-class\\n  will generate an implementation that looks for a function named by \\n  (str prefix mymethod) (default prefix: \\\"-\\\") in a\\n  Clojure namespace specified by :impl-ns\\n  (defaults to the current namespace). All inherited methods,\\n  generated methods, and init and main functions (see :methods, :init,\\n  and :main below) will be found similarly prefixed. By default, the\\n  static initializer for the generated class will attempt to load the\\n  Clojure support code for the class as a resource from the classpath,\\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\\n  behavior can be controlled by :load-impl-ns\\n\\n  Note that methods with a maximum of 18 parameters are supported.\\n\\n  In all subsequent sections taking types, the primitive types can be\\n  referred to by their Java names (int, float etc), and classes in the\\n  java.lang package can be used without a package qualifier. All other\\n  classes must be fully qualified.\\n\\n  Options should be a set of key/value pairs, all except for :name are optional:\\n\\n  :name aname\\n\\n  The package-qualified name of the class to be generated\\n\\n  :extends aclass\\n\\n  Specifies the superclass, the non-private methods of which will be\\n  overridden by the class. If not provided, defaults to Object.\\n\\n  :implements [interface ...]\\n\\n  One or more interfaces, the methods of which will be implemented by the class.\\n\\n  :init name\\n\\n  If supplied, names a function that will be called with the arguments\\n  to the constructor. Must return [ [superclass-constructor-args] state] \\n  If not supplied, the constructor args are passed directly to\\n  the superclass constructor and the state will be nil\\n\\n  :constructors {[param-types] [super-param-types], ...}\\n\\n  By default, constructors are created for the generated class which\\n  match the signature(s) of the constructors for the superclass. This\\n  parameter may be used to explicitly specify constructors, each entry\\n  providing a mapping from a constructor signature to a superclass\\n  constructor signature. When you supply this, you must supply an :init\\n  specifier. \\n\\n  :post-init name\\n\\n  If supplied, names a function that will be called with the object as\\n  the first argument, followed by the arguments to the constructor.\\n  It will be called every time an object of this class is created,\\n  immediately after all the inherited constructors have completed.\\n  Its return value is ignored.\\n\\n  :methods [ [name [param-types] return-type], ...]\\n\\n  The generated class automatically defines all of the non-private\\n  methods of its superclasses/interfaces. This parameter can be used\\n  to specify the signatures of additional methods of the generated\\n  class. Static methods can be specified with ^{:static true} in the\\n  signature's metadata. Do not repeat superclass/interface signatures\\n  here.\\n\\n  :main boolean\\n\\n  If supplied and true, a static public main function will be generated. It will\\n  pass each string of the String[] argument as a separate argument to\\n  a function called (str prefix main).\\n\\n  :factory name\\n\\n  If supplied, a (set of) public static factory function(s) will be\\n  created with the given name, and the same signature(s) as the\\n  constructor(s).\\n  \\n  :state name\\n\\n  If supplied, a public final instance field with the given name will be\\n  created. You must supply an :init function in order to provide a\\n  value for the state. Note that, though final, the state can be a ref\\n  or agent, supporting the creation of Java objects with transactional\\n  or asynchronous mutation semantics.\\n\\n  :exposes {protected-field-name {:get name :set name}, ...}\\n\\n  Since the implementations of the methods of the generated class\\n  occur in Clojure functions, they have no access to the inherited\\n  protected fields of the superclass. This parameter can be used to\\n  generate public getter/setter methods exposing the protected field(s)\\n  for use in the implementation.\\n\\n  :exposes-methods {super-method-name exposed-name, ...}\\n\\n  It is sometimes necessary to call the superclass' implementation of an\\n  overridden method.  Those methods may be exposed and referred in \\n  the new method implementation by a local name.\\n\\n  :prefix string\\n\\n  Default: \\\"-\\\" Methods called e.g. Foo will be looked up in vars called\\n  prefixFoo in the implementing ns.\\n\\n  :impl-ns name\\n\\n  Default: the name of the current ns. Implementations of methods will be \\n  looked up in this namespace.\\n\\n  :load-impl-ns boolean\\n\\n  Default: true. Causes the static initializer for the generated class\\n  to reference the load code for the implementing namespace. Should be\\n  true when implementing-ns is the default, false if you intend to\\n  load the code via some other method.\", :library-url \"https://github.com/clojure/clojure\", :href \"/clojure.core/gen-class\"}, :notes [{:updated-at 1280115806000, :var {:library-url \"https://github.com/clojure/clojure\", :ns \"clojure.core\", :name \"gen-class\"}, :body \"When implementing interface methods with `gen-class` (when using `:implements`) watch out for primitive return types in interface methods.\\r\\n\\r\\nWhen you get weird `NullPointerException`s or `ClassPathException`s then make sure whether the value returned by your functions can be converted by Clojure to the primitive return type defined in the interface for that method.\\r\\n\\r\\nExample:\\r\\n\\r\\nGiven:\\r\\n\\r\\n<pre>\\r\\ninterface Test {\\r\\n   boolean isTest();\\r\\n}\\r\\n</pre>\\r\\n\\r\\nClojure implementation:\\r\\n\\r\\n<pre>\\r\\n(gen-class :name \\\"MyTest\\\" :implements [Test])\\r\\n\\r\\n; Will throw NPE when executed, \\r\\n; can't be converted to boolean\\r\\n(defn -isTest [this] nil) \\r\\n</pre>\\r\\n\\r\\n<pre>\\r\\n(gen-class :name \\\"MyTest\\\" :implements [Test])\\r\\n\\r\\n; Will throw ClassCastExcpetion when executed, \\r\\n; can't be converted to boolean\\r\\n(defn -isTest [this] (Object.)) \\r\\n</pre>\", :created-at 1280115806000, :author {:login \"devijvers\", :account-source \"clojuredocs\", :avatar-url \"https://www.gravatar.com/avatar/81018e4231ac1ce8b7a9e6d377092656?r=PG&default=identicon\"}, :_id \"542692ecf6e94c6970521f8a\", :can-delete? false, :can-edit? false} {:updated-at 1311325790000, :var {:library-url \"https://github.com/clojure/clojure\", :ns \"clojure.core\", :name \"gen-class\"}, :body \"When implementing an interface or extending an abstract class that implements an interface, be careful to implement all methods in the implemented interfaces.  Note: The abstract class is not required to implement all methods in the interface. The clojure compiler does not throw compiler errors if you do not implement a method. A runtime error will be thrown when someone tries to use the function.  The documentation suggests that you will receive UnsupportedOperationException, however in the case of the abstract class a java.lang.AbstractMethodError is thrown. \\r\\n\\r\\n**example:**\\r\\n\\r\\nLog4j appender - Extending AppenderSkeleton will fail with runtime error\\r\\n<pre>(gen-class :name clj.TestAppender :extends  org.apache.log4j.AppenderSkeleton)\\r\\n\\r\\n(defn -append [this event]\\r\\n  (println (.getMessage event)))\\r\\n</pre>\\r\\n\\r\\n\\r\\nNeed to implement close and requireLayout. These are not in AppenderSkeleton but are required by the interface Appender.\\r\\n<pre>(gen-class :name TstAppender :extends org.apache.log4j.AppenderSkeleton)\\r\\n\\r\\n(defn -append [this event]\\r\\n  (println (.getMessage event)))\\r\\n\\r\\n(defn -close [this]) ;nothing to clean up\\r\\n\\r\\n(defn -requireLayout [this] false)\\r\\n\\r\\n</pre>\\r\\n\\r\\n\\r\\n\", :created-at 1306791528000, :author {:login \"ckirkendall\", :account-source \"clojuredocs\", :avatar-url \"https://www.gravatar.com/avatar/c29cd3a5f182e6de85cbd172fb9b5ab8?r=PG&default=identicon\"}, :_id \"542692ecf6e94c6970521fbf\", :can-delete? false, :can-edit? false} {:body \"If your namespace has dashes in it, then the class name will be mangled so the dashes become underscores, unless you have a <code>:name</code> directive. Your naive instantiation will fail with ClassNotFoundException.\\n\\n    (ns my-project.MyClass\\n      (:gen-class))\\n\\n    (my-project.MyClass.) ;;=> java.lang.ClassNotFoundException\\n    (my_project.MyClass.) ;;=> #<MyClass ...>\", :var {:library-url \"https://github.com/clojure/clojure\", :name \"gen-class\", :ns \"clojure.core\"}, :created-at 1418209544515, :updated-at 1418209661100, :author {:login \"alilee\", :account-source \"github\", :avatar-url \"https://avatars.githubusercontent.com/u/16739?v=3\"}, :_id \"54882908e4b04e93c519ffa1\", :can-delete? false, :can-edit? false} {:author {:login \"staypufd\", :account-source \"github\", :avatar-url \"https://avatars1.githubusercontent.com/u/10730?v=4\"}, :updated-at 1518392816391, :created-at 1518392816391, :body \"Note:  If you are using :extends you must use the fully qualified class name even if the class is in the :import list for the namespace. \", :var {:library-url \"https://github.com/clojure/clojure\", :name \"gen-class\", :ns \"clojure.core\"}, :_id \"5a80d5f0e4b0316c0f44f8b8\", :can-delete? false, :can-edit? false} {:author {:login \"mars0i\", :account-source \"github\", :avatar-url \"https://avatars0.githubusercontent.com/u/1836941?v=4\"}, :updated-at 1554575508996, :created-at 1554575508996, :body \"Not strictly speaking a `gen-class` issue, but if you need to override a Java method that's overloaded by specifying different classes for its arguments, this can be done by incorporating the class names into Clojure function names.  See:\\n\\nhttps://groups.google.com/forum/#!topic/clojure/TVRsy4Gnf70\\n\\nhttps://puredanger.github.io/tech.puredanger.com/2011/08/12/subclassing-in-clojure\\n\\nhttp://stackoverflow.com/questions/32773861/clojure-gen-class-for-overloaded-and-overridden-methods\\n\\nhttp://dishevelled.net/Tricky-uses-of-Clojure-gen-class-and-AOT-compilation.html\\n\", :var {:library-url \"https://github.com/clojure/clojure\", :name \"gen-class\", :ns \"clojure.core\"}, :_id \"5ca8f094e4b0ca44402ef705\", :can-delete? false, :can-edit? false}], :see-alsos [{:created-at 1360270663000, :author {:login \"AtKaaZ\", :account-source \"clojuredocs\", :avatar-url \"https://www.gravatar.com/avatar/9e10dfa345f44b0fe72bbe081fd51b83?r=PG&default=identicon\"}, :to-var {:ns \"clojure.core\", :name \"proxy\", :library-url \"https://github.com/clojure/clojure\"}, :from-var {:ns \"clojure.core\", :name \"gen-class\", :library-url \"https://github.com/clojure/clojure\"}, :_id \"542692eaf6e94c6970521bd7\", :doc \"class-and-interfaces - a vector of class names\\n\\n  args - a (possibly empty) vector of arguments to the superclass\\n  constructor.\\n\\n  f => (name [params*] body) or\\n  (name ([params*] body) ([params+] body) ...)\\n\\n  Expands to code which creates a instance of a proxy class that\\n  implements the named class/interface(s) by calling the supplied\\n  fns. A single class, if provided, must be first. If not provided it\\n  defaults to Object.\\n\\n  The interfaces names must be valid interface types. If a method fn\\n  is not provided for a class method, the superclass method will be\\n  called. If a method fn is not provided for an interface method, an\\n  UnsupportedOperationException will be thrown should it be\\n  called. Method fns are closures and can capture the environment in\\n  which proxy is called. Each method fn takes an additional implicit\\n  first arg, which is bound to 'this. Note that while method fns can\\n  be provided to override protected methods, they have no other access\\n  to protected members, nor to super, as these capabilities cannot be\\n  proxied.\", :can-delete? false, :user nil} {:created-at 1360270670000, :author {:login \"AtKaaZ\", :account-source \"clojuredocs\", :avatar-url \"https://www.gravatar.com/avatar/9e10dfa345f44b0fe72bbe081fd51b83?r=PG&default=identicon\"}, :to-var {:ns \"clojure.core\", :name \"gen-interface\", :library-url \"https://github.com/clojure/clojure\"}, :from-var {:ns \"clojure.core\", :name \"gen-class\", :library-url \"https://github.com/clojure/clojure\"}, :_id \"542692eaf6e94c6970521bd8\", :doc \"When compiling, generates compiled bytecode for an interface with\\n  the given package-qualified :name (which, as all names in these\\n  parameters, can be a string or symbol), and writes the .class file\\n  to the *compile-path* directory.  When not compiling, does nothing.\\n \\n  In all subsequent sections taking types, the primitive types can be\\n  referred to by their Java names (int, float etc), and classes in the\\n  java.lang package can be used without a package qualifier. All other\\n  classes must be fully qualified.\\n \\n  Options should be a set of key/value pairs, all except for :name are\\n  optional:\\n\\n  :name aname\\n\\n  The package-qualified name of the class to be generated\\n\\n  :extends [interface ...]\\n\\n  One or more interfaces, which will be extended by this interface.\\n\\n  :methods [ [name [param-types] return-type], ...]\\n\\n  This parameter is used to specify the signatures of the methods of\\n  the generated interface.  Do not repeat superinterface signatures\\n  here.\", :can-delete? false, :user nil}], :user nil}";
//]]></script></head><body class="var-page"><div class="mobile-nav-menu"><section><h4><i class="fa fa-rocket"></i>ClojureDocs</h4><ul class="navbar-nav mobile-navbar-nav nav"><li><a href="/core-library">Core Library<span class="clojure-version">(1.10.1)</span></a></li><li><a href="/quickref">Quick Reference</a></li><li><a href="https://github.com/login/oauth/authorize?client_id=d0242c22610efb54ebbe&amp;redirect_uri=http%3A%2F%2Fclojuredocs.org%2Fgh-callback%2Fclojure.core%2Fgen-class&amp;scope="><i class="fa fa-github-square"></i>Log In</a></li></ul></section><section><h4>Nav</h4><ul class="navbar-nav mobile-navbar-nav nav"><li><a data-animate-buffer="70" data-animate-scroll="true" href="#">Top</a></li><li><a data-animate-buffer="70" data-animate-scroll="true" href="#examples">Examples <span class="examples-count"><span class="badge">5</span></span></a></li><li><a data-animate-buffer="70" data-animate-scroll="true" href="#see-also">See Also <span class="badge">2</span></a></li><li><a data-animate-buffer="70" data-animate-scroll="true" href="#notes">Notes <span class="badge">5</span></a></li></ul></section><section><h4>Namespaces</h4><ul class="navbar-nav mobile-navbar-nav nav"><li><a href="/clojure.core">clojure.core</a></li><li><a href="/clojure.core.async">clojure.core.async</a></li><li><a href="/clojure.core.logic">clojure.core.logic</a></li><li><a href="/clojure.core.logic.fd">clojure.core.logic.fd</a></li><li><a href="/clojure.core.logic.pldb">clojure.core.logic.pldb</a></li><li><a href="/clojure.core.protocols">clojure.core.protocols</a></li><li><a href="/clojure.core.reducers">clojure.core.reducers</a></li><li><a href="/clojure.core.server">clojure.core.server</a></li><li><a href="/clojure.data">clojure.data</a></li><li><a href="/clojure.datafy">clojure.datafy</a></li><li><a href="/clojure.edn">clojure.edn</a></li><li><a href="/clojure.inspector">clojure.inspector</a></li><li><a href="/clojure.instant">clojure.instant</a></li><li><a href="/clojure.java.browse">clojure.java.browse</a></li><li><a href="/clojure.java.io">clojure.java.io</a></li><li><a href="/clojure.java.javadoc">clojure.java.javadoc</a></li><li><a href="/clojure.java.shell">clojure.java.shell</a></li><li><a href="/clojure.main">clojure.main</a></li><li><a href="/clojure.pprint">clojure.pprint</a></li><li><a href="/clojure.reflect">clojure.reflect</a></li><li><a href="/clojure.repl">clojure.repl</a></li><li><a href="/clojure.set">clojure.set</a></li><li><a href="/clojure.spec.alpha">clojure.spec.alpha</a></li><li><a href="/clojure.stacktrace">clojure.stacktrace</a></li><li><a href="/clojure.string">clojure.string</a></li><li><a href="/clojure.template">clojure.template</a></li><li><a href="/clojure.test">clojure.test</a></li><li><a href="/clojure.test.junit">clojure.test.junit</a></li><li><a href="/clojure.test.tap">clojure.test.tap</a></li><li><a href="/clojure.walk">clojure.walk</a></li><li><a href="/clojure.xml">clojure.xml</a></li><li><a href="/clojure.zip">clojure.zip</a></li></ul></section></div><div class="mobile-nav-bar"><header class="navbar"><div class="container"><div class="row"><div class="col-md-10 col-md-offset-1"><a class="navbar-brand" href="/"><i class="fa fa-rocket"></i>ClojureDocs</a><button class="btn btn-default navbar-btn pull-right mobile-menu"><i class="fa fa-bars"></i></button><ul class="navbar-nav nav navbar-right desktop-navbar-nav"><li><a href="/core-library">Core Library</a></li><li><a href="/quickref">Quick Ref</a></li><li><a href="https://github.com/login/oauth/authorize?client_id=d0242c22610efb54ebbe&amp;redirect_uri=http%3A%2F%2Fclojuredocs.org%2Fgh-callback%2Fclojure.core%2Fgen-class&amp;scope="><i class="fa fa-github-square"></i>Log In</a></li></ul><div class="nav-search-widget navbar-right navbar-form"><form autocomplete="off" class="search"><input autocomplete="off" class="placeholder form-control" name="query" placeholder="Looking for? (ctrl-s)" type="text"></form></div></div></div><div class="row"><div class="col-md-10 col-md-offset-1"><div class="ac-results-widget"></div></div></div></div></header></div><div class="sticky-wrapper mobile-push-wrapper"><div class="desktop-nav-bar"><header class="navbar"><div class="container"><div class="row"><div class="col-md-10 col-md-offset-1"><a class="navbar-brand" href="/"><i class="fa fa-rocket"></i>ClojureDocs</a><button class="btn btn-default navbar-btn pull-right mobile-menu"><i class="fa fa-bars"></i></button><ul class="navbar-nav nav navbar-right desktop-navbar-nav"><li><a href="/core-library">Core Library</a></li><li><a href="/quickref">Quick Ref</a></li><li><a href="https://github.com/login/oauth/authorize?client_id=d0242c22610efb54ebbe&amp;redirect_uri=http%3A%2F%2Fclojuredocs.org%2Fgh-callback%2Fclojure.core%2Fgen-class&amp;scope="><i class="fa fa-github-square"></i>Log In</a></li></ul><div class="nav-search-widget navbar-right navbar-form"><form autocomplete="off" class="search"><input autocomplete="off" class="placeholder form-control" name="query" placeholder="Looking for? (ctrl-s)" type="text"></form></div></div></div><div class="row"><div class="col-md-10 col-md-offset-1"><div class="ac-results-widget"></div></div></div></div></header></div><div class="container"><div class="row"><div class="col-md-10 col-md-offset-1"><div><div class="row"><div class="col-sm-2 sidenav"><div class="desktop-side-nav" data-sticky-offset="10"><div class="var-page-nav"></div><div class="library-nav"><h5>Namespaces</h5><ul class="ns-tree"><li><span>clojure</span><ul><li><span class="current"><a href="/clojure.core">core</a></span><ul><li><span><a href="/clojure.core.async">async</a></span></li><li><span><a href="/clojure.core.logic">logic</a></span><ul><li><span><a href="/clojure.core.logic.fd">fd</a></span></li><li><span><a href="/clojure.core.logic.pldb">pldb</a></span></li></ul></li><li><span><a href="/clojure.core.protocols">protocols</a></span></li><li><span><a href="/clojure.core.reducers">reducers</a></span></li><li><span><a href="/clojure.core.server">server</a></span></li></ul></li><li><span><a href="/clojure.data">data</a></span></li><li><span><a href="/clojure.datafy">datafy</a></span></li><li><span><a href="/clojure.edn">edn</a></span></li><li><span><a href="/clojure.inspector">inspector</a></span></li><li><span><a href="/clojure.instant">instant</a></span></li><li><span>java</span><ul><li><span><a href="/clojure.java.browse">browse</a></span></li><li><span><a href="/clojure.java.io">io</a></span></li><li><span><a href="/clojure.java.javadoc">javadoc</a></span></li><li><span><a href="/clojure.java.shell">shell</a></span></li></ul></li><li><span><a href="/clojure.main">main</a></span></li><li><span><a href="/clojure.pprint">pprint</a></span></li><li><span><a href="/clojure.reflect">reflect</a></span></li><li><span><a href="/clojure.repl">repl</a></span></li><li><span><a href="/clojure.set">set</a></span></li><li><span>spec</span><ul><li><span><a href="/clojure.spec.alpha">alpha</a></span></li></ul></li><li><span><a href="/clojure.stacktrace">stacktrace</a></span></li><li><span><a href="/clojure.string">string</a></span></li><li><span><a href="/clojure.template">template</a></span></li><li><span><a href="/clojure.test">test</a></span><ul><li><span><a href="/clojure.test.junit">junit</a></span></li><li><span><a href="/clojure.test.tap">tap</a></span></li></ul></li><li><span><a href="/clojure.walk">walk</a></span></li><li><span><a href="/clojure.xml">xml</a></span></li><li><span><a href="/clojure.zip">zip</a></span></li></ul></li></ul></div></div></div><div class="col-sm-10"><div class="row var-header"><div class="col-sm-8"><h1 class="var-name">gen-class</h1></div><div class="col-sm-4"><div class="var-meta"><h4><a href="/clojure.core">clojure.core</a></h4><span>Available since 1.0</span><span class="source-link"> (<a href="https://github.com/clojure/clojure/blob/clojure-1.10.1/src/clj/clojure/genclass.clj#L507">source</a>) </span></div></div><div class="col-sm-12"><section><ul class="arglists"><li class="arglist">(gen-class &amp; options)</li></ul></section></div></div><section><div class="docstring"><pre>When compiling, generates compiled bytecode for a class with the
given package-qualified :name (which, as all names in these
parameters, can be a string or symbol), and writes the .class file
to the *compile-path* directory.  When not compiling, does
nothing. The gen-class construct contains no implementation, as the
implementation will be dynamically sought by the generated class in
functions in an implementing Clojure namespace. Given a generated
class org.mydomain.MyClass with a method named mymethod, gen-class
will generate an implementation that looks for a function named by 
(str prefix mymethod) (default prefix: "-") in a
Clojure namespace specified by :impl-ns
(defaults to the current namespace). All inherited methods,
generated methods, and init and main functions (see :methods, :init,
and :main below) will be found similarly prefixed. By default, the
static initializer for the generated class will attempt to load the
Clojure support code for the class as a resource from the classpath,
e.g. in the example case, ``org/mydomain/MyClass__init.class``. This
behavior can be controlled by :load-impl-ns
 Note that methods with a maximum of 18 parameters are supported.
 In all subsequent sections taking types, the primitive types can be
referred to by their Java names (int, float etc), and classes in the
java.lang package can be used without a package qualifier. All other
classes must be fully qualified.
 Options should be a set of key/value pairs, all except for :name are optional:
 :name aname
 The package-qualified name of the class to be generated
 :extends aclass
 Specifies the superclass, the non-private methods of which will be
overridden by the class. If not provided, defaults to Object.
 :implements [interface ...]
 One or more interfaces, the methods of which will be implemented by the class.
 :init name
 If supplied, names a function that will be called with the arguments
to the constructor. Must return [ [superclass-constructor-args] state] 
If not supplied, the constructor args are passed directly to
the superclass constructor and the state will be nil
 :constructors {[param-types] [super-param-types], ...}
 By default, constructors are created for the generated class which
match the signature(s) of the constructors for the superclass. This
parameter may be used to explicitly specify constructors, each entry
providing a mapping from a constructor signature to a superclass
constructor signature. When you supply this, you must supply an :init
specifier. 
 :post-init name
 If supplied, names a function that will be called with the object as
the first argument, followed by the arguments to the constructor.
It will be called every time an object of this class is created,
immediately after all the inherited constructors have completed.
Its return value is ignored.
 :methods [ [name [param-types] return-type], ...]
 The generated class automatically defines all of the non-private
methods of its superclasses/interfaces. This parameter can be used
to specify the signatures of additional methods of the generated
class. Static methods can be specified with ^{:static true} in the
signature's metadata. Do not repeat superclass/interface signatures
here.
 :main boolean
 If supplied and true, a static public main function will be generated. It will
pass each string of the String[] argument as a separate argument to
a function called (str prefix main).
 :factory name
 If supplied, a (set of) public static factory function(s) will be
created with the given name, and the same signature(s) as the
constructor(s).

:state name
 If supplied, a public final instance field with the given name will be
created. You must supply an :init function in order to provide a
value for the state. Note that, though final, the state can be a ref
or agent, supporting the creation of Java objects with transactional
or asynchronous mutation semantics.
 :exposes {protected-field-name {:get name :set name}, ...}
 Since the implementations of the methods of the generated class
occur in Clojure functions, they have no access to the inherited
protected fields of the superclass. This parameter can be used to
generate public getter/setter methods exposing the protected field(s)
for use in the implementation.
 :exposes-methods {super-method-name exposed-name, ...}
 It is sometimes necessary to call the superclass' implementation of an
overridden method.  Those methods may be exposed and referred in 
the new method implementation by a local name.
 :prefix string
 Default: "-" Methods called e.g. Foo will be looked up in vars called
prefixFoo in the implementing ns.
 :impl-ns name
 Default: the name of the current ns. Implementations of methods will be 
looked up in this namespace.
 :load-impl-ns boolean
 Default: true. Causes the static initializer for the generated class
to reference the load code for the implementing namespace. Should be
true when implementing-ns is the default, false if you intend to
load the code via some other method.</pre><div class="copyright">&copy; Rich Hickey. All rights reserved. <a href="https://www.eclipse.org/legal/epl-v10.html">Eclipse Public License 1.0</a></div></div></section><section><div class="examples-widget" id="examples"></div></section><section><div class="see-alsos-widget" id="see-also"></div></section><section><div class="notes-widget" id="notes"></div></section></div></div></div></div></div></div><div class="sticky-push"></div></div><footer><div class="container"><div class="row"><div class="col-sm-12"><div class="divider">- ❦ -</div></div></div><div class="row"><div class="ctas"><div class="col-sm-6 left">Brought to you by <a href="https://zacharykim.com">Zachary Kim</a>. </div><div class="col-sm-6 right"><iframe allowtransparency="true" class="gh-starred-count" frameborder="0" height="20" scrolling="0" src="/github-btn.html?user=zk&amp;repo=clojuredocs&amp;type=watch&amp;count=true" width="80"></iframe><a class="twitter-share-button" data-text="Community-powered docs and examples for #Clojure" data-url="http://clojuredocs.org" data-via="heyzk" href="https://twitter.com/share">Tweet</a></div></div><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></div></div></footer><script src="/cljs/clojuredocs.js?9421f92fbece10f3ababd69dba14cf70"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-17348828-1', 'auto');
  ga('send', 'pageview');</script><script>if(("standalone" in window.navigator) && window.navigator.standalone){
var noddy, remotes = false;

document.addEventListener('click', function(event) {

noddy = event.target;

while(noddy.nodeName !== "A" && noddy.nodeName !== "HTML") {
noddy = noddy.parentNode;
}

if('href' in noddy && noddy.href.indexOf('http') !== -1 && (noddy.href.indexOf(document.location.host) !== -1 || remotes))
{
event.preventDefault();
document.location.href = noddy.href;
}

},false);
}</script></body></html>
