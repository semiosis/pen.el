HTTP/1.1 200 OK
Date: Mon, 27 Dec 2021 01:51:19 GMT
Server: Apache/2.4.38 (Debian)
Last-Modified: Thu, 23 Dec 2021 12:36:03 GMT
ETag: "185f5-5d3cf7b4c45a1-gzip"
Accept-Ranges: bytes
Vary: Accept-Encoding
Content-Length: 21982
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>systemd.service</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><style>
    a.headerlink {
      color: #c60f0f;
      font-size: 0.8em;
      padding: 0 4px 0 4px;
      text-decoration: none;
      visibility: hidden;
    }

    a.headerlink:hover {
      background-color: #c60f0f;
      color: white;
    }

    h1:hover > a.headerlink, h2:hover > a.headerlink, h3:hover > a.headerlink, dt:hover > a.headerlink {
      visibility: visible;
    }
  </style><a href="index.html">Index </a>·
  <a href="systemd.directives.html">Directives </a><span style="float:right">systemd 250</span><hr><div class="refentry"><a name="systemd.service"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>systemd.service — Service unit configuration</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><p><code class="filename"><em class="replaceable"><code>service</code></em>.service</code></p></div><div class="refsect1"><a name="id-1.5"></a><h2 id="Description">Description<a class="headerlink" title="Permalink to this headline" href="#Description">¶</a></h2><p>A unit configuration file whose name ends in
    "<code class="literal">.service</code>" encodes information about a process
    controlled and supervised by systemd.</p><p>This man page lists the configuration options specific to
    this unit type. See
    <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>
    for the common options of all unit configuration files. The common
    configuration items are configured in the generic
    [Unit] and [Install]
    sections. The service specific configuration options are
    configured in the [Service] section.</p><p>Additional options are listed in
    <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a>,
    which define the execution environment the commands are executed
    in, and in
    <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>,
    which define the way the processes of the service are terminated,
    and in
    <a href="systemd.resource-control.html#"><span class="citerefentry"><span class="refentrytitle">systemd.resource-control</span>(5)</span></a>,
    which configure resource control settings for the processes of the
    service.</p><p>If SysV init compat is enabled, systemd automatically creates service units that wrap SysV init
    scripts (the service name is the same as the name of the script, with a "<code class="literal">.service</code>"
    suffix added); see
    <a href="systemd-sysv-generator.html#"><span class="citerefentry"><span class="refentrytitle">systemd-sysv-generator</span>(8)</span></a>.
    </p><p>The <a href="systemd-run.html#"><span class="citerefentry"><span class="refentrytitle">systemd-run</span>(1)</span></a>
    command allows creating <code class="filename">.service</code> and <code class="filename">.scope</code> units dynamically
    and transiently from the command line.</p></div><div class="refsect1"><a name="id-1.6"></a><h2 id="Service Templates">Service Templates<a class="headerlink" title="Permalink to this headline" href="#Service%20Templates">¶</a></h2><p>It is possible for <span class="command"><strong>systemd</strong></span> services to take a single argument via the
    "<code class="literal"><em class="replaceable"><code>service</code></em>@<em class="replaceable"><code>argument</code></em>.service</code>"
    syntax. Such services are called "instantiated" services, while the unit definition without the
    <em class="replaceable"><code>argument</code></em> parameter is called a "template". An example could be a
    <code class="filename">dhcpcd@.service</code> service template which takes a network interface as a
    parameter to form an instantiated service. Within the service file, this parameter or "instance
    name" can be accessed with %-specifiers. See
    <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>
    for details.</p></div><div class="refsect1"><a name="id-1.7"></a><h2 id="Automatic Dependencies">Automatic Dependencies<a class="headerlink" title="Permalink to this headline" href="#Automatic%20Dependencies">¶</a></h2><div class="refsect2"><a name="id-1.7.2"></a><h3 id="Implicit Dependencies">Implicit Dependencies<a class="headerlink" title="Permalink to this headline" href="#Implicit%20Dependencies">¶</a></h3><p>The following dependencies are implicitly added:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Services with <code class="varname">Type=dbus</code> set automatically
        acquire dependencies of type <code class="varname">Requires=</code> and
        <code class="varname">After=</code> on
        <code class="filename">dbus.socket</code>.</p></li><li class="listitem"><p>Socket activated services are automatically ordered after
        their activating <code class="filename">.socket</code> units via an
        automatic <code class="varname">After=</code> dependency.
        Services also pull in all <code class="filename">.socket</code> units
        listed in <code class="varname">Sockets=</code> via automatic
        <code class="varname">Wants=</code> and <code class="varname">After=</code> dependencies.</p></li></ul></div><p>Additional implicit dependencies may be added as result of
      execution and resource control parameters as documented in
      <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a>
      and
      <a href="systemd.resource-control.html#"><span class="citerefentry"><span class="refentrytitle">systemd.resource-control</span>(5)</span></a>.</p></div><div class="refsect2"><a name="id-1.7.3"></a><h3 id="Default Dependencies">Default Dependencies<a class="headerlink" title="Permalink to this headline" href="#Default%20Dependencies">¶</a></h3><p>The following dependencies are added unless <code class="varname">DefaultDependencies=no</code> is set:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Service units will have dependencies of type <code class="varname">Requires=</code> and
        <code class="varname">After=</code> on <code class="filename">sysinit.target</code>, a dependency of type <code class="varname">After=</code> on
        <code class="filename">basic.target</code> as well as dependencies of type <code class="varname">Conflicts=</code> and
        <code class="varname">Before=</code> on <code class="filename">shutdown.target</code>. These ensure that normal service units pull in
        basic system initialization, and are terminated cleanly prior to system shutdown. Only services involved with early
        boot or late system shutdown should disable this option.</p></li><li class="listitem"><p>Instanced service units (i.e. service units with an "<code class="literal">@</code>" in their name) are assigned by
        default a per-template slice unit (see
        <a href="systemd.slice.html#"><span class="citerefentry"><span class="refentrytitle">systemd.slice</span>(5)</span></a>), named after the
        template unit, containing all instances of the specific template. This slice is normally stopped at shutdown,
        together with all template instances. If that is not desired, set <code class="varname">DefaultDependencies=no</code> in the
        template unit, and either define your own per-template slice unit file that also sets
        <code class="varname">DefaultDependencies=no</code>, or set <code class="varname">Slice=system.slice</code> (or another suitable slice)
        in the template unit. Also see
        <a href="systemd.resource-control.html#"><span class="citerefentry"><span class="refentrytitle">systemd.resource-control</span>(5)</span></a>.
        </p></li></ul></div></div></div><div class="refsect1"><a name="id-1.8"></a><h2 id="Options">Options<a class="headerlink" title="Permalink to this headline" href="#Options">¶</a></h2><p>Service unit files may include [Unit] and [Install] sections, which are described in
    <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>.
    </p><p>Service unit files must include a [Service]
    section, which carries information about the service and the
    process it supervises. A number of options that may be used in
    this section are shared with other unit types. These options are
    documented in
    <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a>,
    <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>
    and
    <a href="systemd.resource-control.html#"><span class="citerefentry"><span class="refentrytitle">systemd.resource-control</span>(5)</span></a>.
    The options specific to the [Service] section
    of service units are the following:</p><div class="variablelist"><dl class="variablelist"><dt id="Type="><span class="term"><code class="varname">Type=</code></span><a class="headerlink" title="Permalink to this term" href="#Type=">¶</a></dt><dd><p>Configures the process start-up type for this service unit. One of <code class="option">simple</code>,
          <code class="option">exec</code>, <code class="option">forking</code>, <code class="option">oneshot</code>, <code class="option">dbus</code>,
          <code class="option">notify</code> or <code class="option">idle</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If set to <code class="option">simple</code> (the default if <code class="varname">ExecStart=</code> is
            specified but neither <code class="varname">Type=</code> nor <code class="varname">BusName=</code> are), the service manager
            will consider the unit started immediately after the main service process has been forked off. It is
            expected that the process configured with <code class="varname">ExecStart=</code> is the main process of the
            service. In this mode, if the process offers functionality to other processes on the system, its
            communication channels should be installed before the service is started up (e.g.  sockets set up by
            systemd, via socket activation), as the service manager will immediately proceed starting follow-up units,
            right after creating the main service process, and before executing the service's binary. Note that this
            means <span class="command"><strong>systemctl start</strong></span> command lines for <code class="option">simple</code> services will report
            success even if the service's binary cannot be invoked successfully (for example because the selected
            <code class="varname">User=</code> doesn't exist, or the service binary is missing).</p></li><li class="listitem"><p>The <code class="option">exec</code> type is similar to <code class="option">simple</code>, but the service
            manager will consider the unit started immediately after the main service binary has been executed. The service
            manager will delay starting of follow-up units until that point. (Or in other words:
            <code class="option">simple</code> proceeds with further jobs right after <code class="function">fork()</code> returns, while
            <code class="option">exec</code> will not proceed before both <code class="function">fork()</code> and
            <code class="function">execve()</code> in the service process succeeded.) Note that this means <span class="command"><strong>systemctl
            start</strong></span> command lines for <code class="option">exec</code> services will report failure when the service's
            binary cannot be invoked successfully (for example because the selected <code class="varname">User=</code> doesn't
            exist, or the service binary is missing).</p></li><li class="listitem"><p>If set to <code class="option">forking</code>, it is expected that the process configured with
            <code class="varname">ExecStart=</code> will call <code class="function">fork()</code> as part of its start-up. The parent
            process is expected to exit when start-up is complete and all communication channels are set up. The child
            continues to run as the main service process, and the service manager will consider the unit started when
            the parent process exits. This is the behavior of traditional UNIX services. If this setting is used, it is
            recommended to also use the <code class="varname">PIDFile=</code> option, so that systemd can reliably identify the
            main process of the service. systemd will proceed with starting follow-up units as soon as the parent
            process exits.</p></li><li class="listitem"><p>Behavior of <code class="option">oneshot</code> is similar to <code class="option">simple</code>;
            however, the service manager will consider the unit up after the main process exits. It will then
            start follow-up units. <code class="varname">RemainAfterExit=</code> is particularly useful for this type
            of service. <code class="varname">Type=</code><code class="option">oneshot</code> is the implied default if neither
            <code class="varname">Type=</code> nor <code class="varname">ExecStart=</code> are specified. Note that if this
            option is used without <code class="varname">RemainAfterExit=</code> the service will never enter
            "<code class="literal">active</code>" unit state, but directly transition from "<code class="literal">activating</code>"
            to "<code class="literal">deactivating</code>" or "<code class="literal">dead</code>" since no process is configured that
            shall run continuously. In particular this means that after a service of this type ran (and which
            has <code class="varname">RemainAfterExit=</code> not set) it will not show up as started afterwards, but
            as dead.</p></li><li class="listitem"><p>Behavior of <code class="option">dbus</code> is similar to <code class="option">simple</code>; however,
            it is expected that the service acquires a name on the D-Bus bus, as configured by
            <code class="varname">BusName=</code>. systemd will proceed with starting follow-up units after the D-Bus
            bus name has been acquired. Service units with this option configured implicitly gain
            dependencies on the <code class="filename">dbus.socket</code> unit. This type is the default if
            <code class="varname">BusName=</code> is specified. A service unit of this type is considered to be in the
            activating state until the specified bus name is acquired. It is considered activated while the
            bus name is taken. Once the bus name is released the service is considered being no longer
            functional which has the effect that the service manager attempts to terminate any remaining
            processes belonging to the service. Services that drop their bus name as part of their shutdown
            logic thus should be prepared to receive a <code class="constant">SIGTERM</code> (or whichever signal is
            configured in <code class="varname">KillSignal=</code>) as result.</p></li><li class="listitem"><p>Behavior of <code class="option">notify</code> is similar to <code class="option">exec</code>; however, it is
            expected that the service sends a notification message via
            <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a> or an
            equivalent call when it has finished starting up. systemd will proceed with starting follow-up units after
            this notification message has been sent. If this option is used, <code class="varname">NotifyAccess=</code> (see
            below) should be set to open access to the notification socket provided by systemd. If
            <code class="varname">NotifyAccess=</code> is missing or set to <code class="option">none</code>, it will be forcibly set to
            <code class="option">main</code>.</p></li><li class="listitem"><p>Behavior of <code class="option">idle</code> is very similar to <code class="option">simple</code>; however,
            actual execution of the service program is delayed until all active jobs are dispatched. This may be used
            to avoid interleaving of output of shell services with the status output on the console. Note that this
            type is useful only to improve console output, it is not useful as a general unit ordering tool, and the
            effect of this service type is subject to a 5s timeout, after which the service program is invoked
            anyway.</p></li></ul></div><p>It is generally recommended to use <code class="varname">Type=</code><code class="option">simple</code> for long-running
          services whenever possible, as it is the simplest and fastest option. However, as this service type won't
          propagate service start-up failures and doesn't allow ordering of other units against completion of
          initialization of the service (which for example is useful if clients need to connect to the service through
          some form of IPC, and the IPC channel is only established by the service itself — in contrast to doing this
          ahead of time through socket or bus activation or similar), it might not be sufficient for many cases. If so,
          <code class="option">notify</code> or <code class="option">dbus</code> (the latter only in case the service provides a D-Bus
          interface) are the preferred options as they allow service program code to precisely schedule when to
          consider the service started up successfully and when to proceed with follow-up units. The
          <code class="option">notify</code> service type requires explicit support in the service codebase (as
          <code class="function">sd_notify()</code> or an equivalent API needs to be invoked by the service at the appropriate
          time) — if it's not supported, then <code class="option">forking</code> is an alternative: it supports the traditional
          UNIX service start-up protocol. Finally, <code class="option">exec</code> might be an option for cases where it is
          enough to ensure the service binary is invoked, and where the service binary itself executes no or little
          initialization on its own (and its initialization is unlikely to fail). Note that using any type other than
          <code class="option">simple</code> possibly delays the boot process, as the service manager needs to wait for service
          initialization to complete. It is hence recommended not to needlessly use any types other than
          <code class="option">simple</code>. (Also note it is generally not recommended to use <code class="option">idle</code> or
          <code class="option">oneshot</code> for long-running services.)</p></dd><dt id="ExitType="><span class="term"><code class="varname">ExitType=</code></span><a class="headerlink" title="Permalink to this term" href="#ExitType=">¶</a></dt><dd><p>Specifies when the manager should consider the service to be finished. One of <code class="option">main</code> or
          <code class="option">cgroup</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If set to <code class="option">main</code> (the default), the service manager
            will consider the unit stopped when the main process, which is determined according to the
            <code class="varname">Type=</code>, exits. Consequently, it cannot be used with
            <code class="varname">Type=</code><code class="option">oneshot</code>.</p></li><li class="listitem"><p>If set to <code class="option">cgroup</code>, the service will be considered running as long as at
            least one process in the cgroup has not exited.</p></li></ul></div><p>It is generally recommended to use <code class="varname">ExitType=</code><code class="option">main</code> when a service has
          a known forking model and a main process can reliably be determined. <code class="varname">ExitType=</code>
          <code class="option">cgroup</code> is meant for applications whose forking model is not known ahead of time and which
          might not have a specific main process. It is well suited for transient or automatically generated services,
          such as graphical applications inside of a desktop environment.</p></dd><dt id="RemainAfterExit="><span class="term"><code class="varname">RemainAfterExit=</code></span><a class="headerlink" title="Permalink to this term" href="#RemainAfterExit=">¶</a></dt><dd><p>Takes a boolean value that specifies whether
        the service shall be considered active even when all its
        processes exited. Defaults to <code class="option">no</code>.</p></dd><dt id="GuessMainPID="><span class="term"><code class="varname">GuessMainPID=</code></span><a class="headerlink" title="Permalink to this term" href="#GuessMainPID=">¶</a></dt><dd><p>Takes a boolean value that specifies whether
        systemd should try to guess the main PID of a service if it
        cannot be determined reliably. This option is ignored unless
        <code class="option">Type=forking</code> is set and
        <code class="option">PIDFile=</code> is unset because for the other types
        or with an explicitly configured PID file, the main PID is
        always known. The guessing algorithm might come to incorrect
        conclusions if a daemon consists of more than one process. If
        the main PID cannot be determined, failure detection and
        automatic restarting of a service will not work reliably.
        Defaults to <code class="option">yes</code>.</p></dd><dt id="PIDFile="><span class="term"><code class="varname">PIDFile=</code></span><a class="headerlink" title="Permalink to this term" href="#PIDFile=">¶</a></dt><dd><p>Takes a path referring to the PID file of the service. Usage of this option is recommended for
        services where <code class="varname">Type=</code> is set to <code class="option">forking</code>. The path specified typically points
        to a file below <code class="filename">/run/</code>. If a relative path is specified it is hence prefixed with
        <code class="filename">/run/</code>. The service manager will read the PID of the main process of the service from this
        file after start-up of the service. The service manager will not write to the file configured here, although it
        will remove the file after the service has shut down if it still exists. The PID file does not need to be owned
        by a privileged user, but if it is owned by an unprivileged user additional safety restrictions are enforced:
        the file may not be a symlink to a file owned by a different user (neither directly nor indirectly), and the
        PID file must refer to a process already belonging to the service.</p><p>Note that PID files should be avoided in modern projects. Use <code class="option">Type=notify</code> or
        <code class="option">Type=simple</code> where possible, which does not require use of PID files to determine the
        main process of a service and avoids needless forking.</p></dd><dt id="BusName="><span class="term"><code class="varname">BusName=</code></span><a class="headerlink" title="Permalink to this term" href="#BusName=">¶</a></dt><dd><p>Takes a D-Bus destination name that this service shall use. This option is mandatory
        for services where <code class="varname">Type=</code> is set to <code class="option">dbus</code>. It is recommended to
        always set this property if known to make it easy to map the service name to the D-Bus destination.
        In particular, <span class="command"><strong>systemctl service-log-level/service-log-target</strong></span> verbs make use of
        this.</p></dd><dt id="ExecStart="><span class="term"><code class="varname">ExecStart=</code></span><a class="headerlink" title="Permalink to this term" href="#ExecStart=">¶</a></dt><dd><p>Commands with their arguments that are
        executed when this service is started. The value is split into
        zero or more command lines according to the rules described
        below (see section "Command Lines" below).
        </p><p>Unless <code class="varname">Type=</code> is <code class="option">oneshot</code>, exactly one command must be given. When
        <code class="varname">Type=oneshot</code> is used, zero or more commands may be specified. Commands may be specified by
        providing multiple command lines in the same directive, or alternatively, this directive may be specified more
        than once with the same effect. If the empty string is assigned to this option, the list of commands to start
        is reset, prior assignments of this option will have no effect. If no <code class="varname">ExecStart=</code> is
        specified, then the service must have <code class="varname">RemainAfterExit=yes</code> and at least one
        <code class="varname">ExecStop=</code> line set. (Services lacking both <code class="varname">ExecStart=</code> and
        <code class="varname">ExecStop=</code> are not valid.)</p><p>For each of the specified commands, the first argument must be either an absolute path to an executable
        or a simple file name without any slashes. Optionally, this filename may be prefixed with a number of special
        characters:</p><div class="table"><a name="id-1.8.4.7.2.4"></a><p class="title"><b>Table 1. Special executable prefixes</b></p><div class="table-contents"><table class="table" summary="Special executable prefixes" border="1"><colgroup><col class="prefix"><col class="meaning"></colgroup><thead><tr><th>Prefix</th><th>Effect</th></tr></thead><tbody><tr><td>"<code class="literal">@</code>"</td><td>If the executable path is prefixed with "<code class="literal">@</code>", the second specified token will be passed as "<code class="literal">argv[0]</code>" to the executed process (instead of the actual filename), followed by the further arguments specified.</td></tr><tr><td>"<code class="literal">-</code>"</td><td>If the executable path is prefixed with "<code class="literal">-</code>", an exit code of the command normally considered a failure (i.e. non-zero exit status or abnormal exit due to signal) is recorded, but has no further effect and is considered equivalent to success.</td></tr><tr><td>"<code class="literal">:</code>"</td><td>If the executable path is prefixed with "<code class="literal">:</code>", environment variable substitution (as described by the "Command Lines" section below) is not applied.</td></tr><tr><td>"<code class="literal">+</code>"</td><td>If the executable path is prefixed with "<code class="literal">+</code>" then the process is executed with full privileges. In this mode privilege restrictions configured with <code class="varname">User=</code>, <code class="varname">Group=</code>, <code class="varname">CapabilityBoundingSet=</code> or the various file system namespacing options (such as <code class="varname">PrivateDevices=</code>, <code class="varname">PrivateTmp=</code>) are not applied to the invoked command line (but still affect any other <code class="varname">ExecStart=</code>, <code class="varname">ExecStop=</code>, … lines).</td></tr><tr><td>"<code class="literal">!</code>"</td><td>Similar to the "<code class="literal">+</code>" character discussed above this permits invoking command lines with elevated privileges. However, unlike "<code class="literal">+</code>" the "<code class="literal">!</code>" character exclusively alters the effect of <code class="varname">User=</code>, <code class="varname">Group=</code> and <code class="varname">SupplementaryGroups=</code>, i.e. only the stanzas that affect user and group credentials. Note that this setting may be combined with <code class="varname">DynamicUser=</code>, in which case a dynamic user/group pair is allocated before the command is invoked, but credential changing is left to the executed process itself.</td></tr><tr><td>"<code class="literal">!!</code>"</td><td>This prefix is very similar to "<code class="literal">!</code>", however it only has an effect on systems lacking support for ambient process capabilities, i.e. without support for <code class="varname">AmbientCapabilities=</code>. It's intended to be used for unit files that take benefit of ambient capabilities to run processes with minimal privileges wherever possible while remaining compatible with systems that lack ambient capabilities support. Note that when "<code class="literal">!!</code>" is used, and a system lacking ambient capability support is detected any configured <code class="varname">SystemCallFilter=</code> and <code class="varname">CapabilityBoundingSet=</code> stanzas are implicitly modified, in order to permit spawned processes to drop credentials and capabilities themselves, even if this is configured to not be allowed. Moreover, if this prefix is used and a system lacking ambient capability support is detected <code class="varname">AmbientCapabilities=</code> will be skipped and not be applied. On systems supporting ambient capabilities, "<code class="literal">!!</code>" has no effect and is redundant.</td></tr></tbody></table></div></div><br class="table-break"><p>"<code class="literal">@</code>", "<code class="literal">-</code>", "<code class="literal">:</code>", and one of
        "<code class="literal">+</code>"/"<code class="literal">!</code>"/"<code class="literal">!!</code>" may be used together and they can appear in any
        order. However, only one of "<code class="literal">+</code>", "<code class="literal">!</code>", "<code class="literal">!!</code>" may be used at a
        time. Note that these prefixes are also supported for the other command line settings,
        i.e. <code class="varname">ExecStartPre=</code>, <code class="varname">ExecStartPost=</code>, <code class="varname">ExecReload=</code>,
        <code class="varname">ExecStop=</code> and <code class="varname">ExecStopPost=</code>.</p><p>If more than one command is specified, the commands are
        invoked sequentially in the order they appear in the unit
        file. If one of the commands fails (and is not prefixed with
        "<code class="literal">-</code>"), other lines are not executed, and the
        unit is considered failed.</p><p>Unless <code class="varname">Type=forking</code> is set, the
        process started via this command line will be considered the
        main process of the daemon.</p></dd><dt id="ExecStartPre="><span class="term"><code class="varname">ExecStartPre=</code>, </span><span class="term"><code class="varname">ExecStartPost=</code></span><a class="headerlink" title="Permalink to this term" href="#ExecStartPre=">¶</a></dt><dd><p>Additional commands that are executed before
        or after the command in <code class="varname">ExecStart=</code>,
        respectively. Syntax is the same as for
        <code class="varname">ExecStart=</code>, except that multiple command
        lines are allowed and the commands are executed one after the
        other, serially.</p><p>If any of those commands (not prefixed with
        "<code class="literal">-</code>") fail, the rest are not executed and the
        unit is considered failed.</p><p><code class="varname">ExecStart=</code> commands are only run after
        all <code class="varname">ExecStartPre=</code> commands that were not prefixed
        with a "<code class="literal">-</code>" exit successfully.</p><p><code class="varname">ExecStartPost=</code> commands are only run after the commands specified in
        <code class="varname">ExecStart=</code> have been invoked successfully, as determined by <code class="varname">Type=</code>
        (i.e. the process has been started for <code class="varname">Type=simple</code> or <code class="varname">Type=idle</code>, the last
        <code class="varname">ExecStart=</code> process exited successfully for <code class="varname">Type=oneshot</code>, the initial
        process exited successfully for <code class="varname">Type=forking</code>, "<code class="literal">READY=1</code>" is sent for
        <code class="varname">Type=notify</code>, or the <code class="varname">BusName=</code> has been taken for
        <code class="varname">Type=dbus</code>).</p><p>Note that <code class="varname">ExecStartPre=</code> may not be
        used to start long-running processes. All processes forked
        off by processes invoked via <code class="varname">ExecStartPre=</code> will
        be killed before the next service process is run.</p><p>Note that if any of the commands specified in <code class="varname">ExecStartPre=</code>,
        <code class="varname">ExecStart=</code>, or <code class="varname">ExecStartPost=</code> fail (and are not prefixed with
        "<code class="literal">-</code>", see above) or time out before the service is fully up, execution continues with commands
        specified in <code class="varname">ExecStopPost=</code>, the commands in <code class="varname">ExecStop=</code> are skipped.</p><p>Note that the execution of <code class="varname">ExecStartPost=</code> is taken into account for the purpose of
        <code class="varname">Before=</code>/<code class="varname">After=</code> ordering constraints.</p></dd><dt id="ExecCondition="><span class="term"><code class="varname">ExecCondition=</code></span><a class="headerlink" title="Permalink to this term" href="#ExecCondition=">¶</a></dt><dd><p>Optional commands that are executed before the command(s) in <code class="varname">ExecStartPre=</code>.
        Syntax is the same as for <code class="varname">ExecStart=</code>, except that multiple command lines are allowed and the
        commands are executed one after the other, serially.</p><p>The behavior is like an <code class="varname">ExecStartPre=</code> and condition check hybrid: when an
        <code class="varname">ExecCondition=</code> command exits with exit code 1 through 254 (inclusive), the remaining
        commands are skipped and the unit is <span class="emphasis"><em>not</em></span> marked as failed. However, if an
        <code class="varname">ExecCondition=</code> command exits with 255 or abnormally (e.g. timeout, killed by a
        signal, etc.), the unit will be considered failed (and remaining commands will be skipped). Exit code of 0 or
        those matching <code class="varname">SuccessExitStatus=</code> will continue execution to the next command(s).</p><p>The same recommendations about not running long-running processes in <code class="varname">ExecStartPre=</code>
        also applies to <code class="varname">ExecCondition=</code>. <code class="varname">ExecCondition=</code> will also run the commands
        in <code class="varname">ExecStopPost=</code>, as part of stopping the service, in the case of any non-zero or abnormal
        exits, like the ones described above.</p></dd><dt id="ExecReload="><span class="term"><code class="varname">ExecReload=</code></span><a class="headerlink" title="Permalink to this term" href="#ExecReload=">¶</a></dt><dd><p>Commands to execute to trigger a configuration
        reload in the service. This argument takes multiple command
        lines, following the same scheme as described for
        <code class="varname">ExecStart=</code> above. Use of this setting is
        optional. Specifier and environment variable substitution is
        supported here following the same scheme as for
        <code class="varname">ExecStart=</code>.</p><p>One additional, special environment variable is set: if
        known, <code class="varname">$MAINPID</code> is set to the main process
        of the daemon, and may be used for command lines like the
        following:</p><pre class="programlisting">ExecReload=kill -HUP $MAINPID</pre><p>Note however that reloading a daemon by sending a signal
        (as with the example line above) is usually not a good choice,
        because this is an asynchronous operation and hence not
        suitable to order reloads of multiple services against each
        other. It is strongly recommended to set
        <code class="varname">ExecReload=</code> to a command that not only
        triggers a configuration reload of the daemon, but also
        synchronously waits for it to complete. For example,
        <a href="https://www.mankier.com/1/dbus-broker"><span class="citerefentry"><span class="refentrytitle">dbus-broker</span>(1)</span></a>
        uses the following:</p><pre class="programlisting">ExecReload=busctl call org.freedesktop.DBus \
        /org/freedesktop/DBus org.freedesktop.DBus \
        ReloadConfig
</pre></dd><dt id="ExecStop="><span class="term"><code class="varname">ExecStop=</code></span><a class="headerlink" title="Permalink to this term" href="#ExecStop=">¶</a></dt><dd><p>Commands to execute to stop the service started via
        <code class="varname">ExecStart=</code>. This argument takes multiple command lines, following the same scheme
        as described for <code class="varname">ExecStart=</code> above. Use of this setting is optional. After the
        commands configured in this option are run, it is implied that the service is stopped, and any
        processes remaining for it are terminated according to the <code class="varname">KillMode=</code> setting (see
        <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>).
        If this option is not specified, the process is terminated by sending the signal specified in
        <code class="varname">KillSignal=</code> or <code class="varname">RestartKillSignal=</code> when service stop is
        requested. Specifier and environment variable substitution is supported (including
        <code class="varname">$MAINPID</code>, see above).</p><p>Note that it is usually not sufficient to specify a command for this setting that only asks the
        service to terminate (for example, by sending some form of termination signal to it), but does not
        wait for it to do so. Since the remaining processes of the services are killed according to
        <code class="varname">KillMode=</code> and <code class="varname">KillSignal=</code> or
        <code class="varname">RestartKillSignal=</code> as described above immediately after the command exited, this
        may not result in a clean stop. The specified command should hence be a synchronous operation, not an
        asynchronous one.</p><p>Note that the commands specified in <code class="varname">ExecStop=</code> are only executed when the service
        started successfully first. They are not invoked if the service was never started at all, or in case its
        start-up failed, for example because any of the commands specified in <code class="varname">ExecStart=</code>,
        <code class="varname">ExecStartPre=</code> or <code class="varname">ExecStartPost=</code> failed (and weren't prefixed with
        "<code class="literal">-</code>", see above) or timed out. Use <code class="varname">ExecStopPost=</code> to invoke commands when a
        service failed to start up correctly and is shut down again. Also note that the stop operation is always
        performed if the service started successfully, even if the processes in the service terminated on their
        own or were killed. The stop commands must be prepared to deal with that case. <code class="varname">$MAINPID</code>
        will be unset if systemd knows that the main process exited by the time the stop commands are called.</p><p>Service restart requests are implemented as stop operations followed by start operations. This
        means that <code class="varname">ExecStop=</code> and <code class="varname">ExecStopPost=</code> are executed during a
        service restart operation.</p><p>It is recommended to use this setting for commands that communicate with the service requesting
        clean termination. For post-mortem clean-up steps use <code class="varname">ExecStopPost=</code> instead.
        </p></dd><dt id="ExecStopPost="><span class="term"><code class="varname">ExecStopPost=</code></span><a class="headerlink" title="Permalink to this term" href="#ExecStopPost=">¶</a></dt><dd><p>Additional commands that are executed after the service is stopped. This includes cases where
        the commands configured in <code class="varname">ExecStop=</code> were used, where the service does not have any
        <code class="varname">ExecStop=</code> defined, or where the service exited unexpectedly. This argument takes multiple
        command lines, following the same scheme as described for <code class="varname">ExecStart=</code>. Use of these settings
        is optional. Specifier and environment variable substitution is supported. Note that – unlike
        <code class="varname">ExecStop=</code> – commands specified with this setting are invoked when a service failed to start
        up correctly and is shut down again.</p><p>It is recommended to use this setting for clean-up operations that shall be executed even when the
        service failed to start up correctly. Commands configured with this setting need to be able to operate even if
        the service failed starting up half-way and left incompletely initialized data around. As the service's
        processes have been terminated already when the commands specified with this setting are executed they should
        not attempt to communicate with them.</p><p>Note that all commands that are configured with this setting are invoked with the result code of the
        service, as well as the main process' exit code and status, set in the <code class="varname">$SERVICE_RESULT</code>,
        <code class="varname">$EXIT_CODE</code> and <code class="varname">$EXIT_STATUS</code> environment variables, see
        <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a> for
        details.</p><p>Note that the execution of <code class="varname">ExecStopPost=</code> is taken into account for the purpose of
        <code class="varname">Before=</code>/<code class="varname">After=</code> ordering constraints.</p></dd><dt id="RestartSec="><span class="term"><code class="varname">RestartSec=</code></span><a class="headerlink" title="Permalink to this term" href="#RestartSec=">¶</a></dt><dd><p>Configures the time to sleep before restarting
        a service (as configured with <code class="varname">Restart=</code>).
        Takes a unit-less value in seconds, or a time span value such
        as "5min 20s". Defaults to 100ms.</p></dd><dt id="TimeoutStartSec="><span class="term"><code class="varname">TimeoutStartSec=</code></span><a class="headerlink" title="Permalink to this term" href="#TimeoutStartSec=">¶</a></dt><dd><p>Configures the time to wait for start-up. If a daemon service does not signal start-up
        completion within the configured time, the service will be considered failed and will be shut down again. The
        precise action depends on the <code class="varname">TimeoutStartFailureMode=</code> option. Takes a unit-less value in
        seconds, or a time span value such as "5min 20s". Pass "<code class="literal">infinity</code>" to disable the timeout logic.
        Defaults to <code class="varname">DefaultTimeoutStartSec=</code> from the manager configuration file, except when
        <code class="varname">Type=oneshot</code> is used, in which case the timeout is disabled by default (see
        <a href="systemd-system.conf.html#"><span class="citerefentry"><span class="refentrytitle">systemd-system.conf</span>(5)</span></a>).
        </p><p>If a service of <code class="varname">Type=notify</code> sends "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>", this may cause
        the start time to be extended beyond <code class="varname">TimeoutStartSec=</code>. The first receipt of this message
        must occur before <code class="varname">TimeoutStartSec=</code> is exceeded, and once the start time has extended beyond
        <code class="varname">TimeoutStartSec=</code>, the service manager will allow the service to continue to start, provided
        the service repeats "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>" within the interval specified until the service
        startup status is finished by "<code class="literal">READY=1</code>". (see
        <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a>).
        </p></dd><dt id="TimeoutStopSec="><span class="term"><code class="varname">TimeoutStopSec=</code></span><a class="headerlink" title="Permalink to this term" href="#TimeoutStopSec=">¶</a></dt><dd><p>This option serves two purposes. First, it configures the time to wait for each
        <code class="varname">ExecStop=</code> command. If any of them times out, subsequent <code class="varname">ExecStop=</code> commands
        are skipped and the service will be terminated by <code class="constant">SIGTERM</code>. If no <code class="varname">ExecStop=</code>
        commands are specified, the service gets the <code class="constant">SIGTERM</code> immediately. This default behavior
        can be changed by the <code class="varname">TimeoutStopFailureMode=</code> option. Second, it configures the time
        to wait for the service itself to stop. If it doesn't terminate in the specified time, it will be forcibly terminated
        by <code class="constant">SIGKILL</code> (see <code class="varname">KillMode=</code> in
        <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>).
        Takes a unit-less value in seconds, or a time span value such
        as "5min 20s". Pass "<code class="literal">infinity</code>" to disable the
        timeout logic. Defaults to
        <code class="varname">DefaultTimeoutStopSec=</code> from the manager
        configuration file (see
        <a href="systemd-system.conf.html#"><span class="citerefentry"><span class="refentrytitle">systemd-system.conf</span>(5)</span></a>).
        </p><p>If a service of <code class="varname">Type=notify</code> sends "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>", this may cause
        the stop time to be extended beyond <code class="varname">TimeoutStopSec=</code>. The first receipt of this message
        must occur before <code class="varname">TimeoutStopSec=</code> is exceeded, and once the stop time has extended beyond
        <code class="varname">TimeoutStopSec=</code>, the service manager will allow the service to continue to stop, provided
        the service repeats "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>" within the interval specified, or terminates itself
        (see <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a>).
        </p></dd><dt id="TimeoutAbortSec="><span class="term"><code class="varname">TimeoutAbortSec=</code></span><a class="headerlink" title="Permalink to this term" href="#TimeoutAbortSec=">¶</a></dt><dd><p>This option configures the time to wait for the service to terminate when it was aborted due to a
        watchdog timeout (see <code class="varname">WatchdogSec=</code>). If the service has a short <code class="varname">TimeoutStopSec=</code>
        this option can be used to give the system more time to write a core dump of the service. Upon expiration the service
        will be forcibly terminated by <code class="constant">SIGKILL</code> (see <code class="varname">KillMode=</code> in
        <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>). The core file will
        be truncated in this case. Use <code class="varname">TimeoutAbortSec=</code> to set a sensible timeout for the core dumping per
        service that is large enough to write all expected data while also being short enough to handle the service failure
        in due time.
        </p><p>Takes a unit-less value in seconds, or a time span value such as "5min 20s". Pass an empty value to skip
        the dedicated watchdog abort timeout handling and fall back <code class="varname">TimeoutStopSec=</code>. Pass
        "<code class="literal">infinity</code>" to disable the timeout logic. Defaults to <code class="varname">DefaultTimeoutAbortSec=</code> from
        the manager configuration file (see
        <a href="systemd-system.conf.html#"><span class="citerefentry"><span class="refentrytitle">systemd-system.conf</span>(5)</span></a>).
        </p><p>If a service of <code class="varname">Type=notify</code> handles <code class="constant">SIGABRT</code> itself (instead of relying
        on the kernel to write a core dump) it can send "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>" to
        extended the abort time beyond <code class="varname">TimeoutAbortSec=</code>. The first receipt of this message
        must occur before <code class="varname">TimeoutAbortSec=</code> is exceeded, and once the abort time has extended beyond
        <code class="varname">TimeoutAbortSec=</code>, the service manager will allow the service to continue to abort, provided
        the service repeats "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>" within the interval specified, or terminates itself
        (see <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a>).
        </p></dd><dt id="TimeoutSec="><span class="term"><code class="varname">TimeoutSec=</code></span><a class="headerlink" title="Permalink to this term" href="#TimeoutSec=">¶</a></dt><dd><p>A shorthand for configuring both
        <code class="varname">TimeoutStartSec=</code> and
        <code class="varname">TimeoutStopSec=</code> to the specified value.
        </p></dd><dt id="TimeoutStartFailureMode="><span class="term"><code class="varname">TimeoutStartFailureMode=</code>, </span><span class="term"><code class="varname">TimeoutStopFailureMode=</code></span><a class="headerlink" title="Permalink to this term" href="#TimeoutStartFailureMode=">¶</a></dt><dd><p>These options configure the action that is taken in case a daemon service does not signal
        start-up within its configured <code class="varname">TimeoutStartSec=</code>, respectively if it does not stop within
        <code class="varname">TimeoutStopSec=</code>. Takes one of <code class="option">terminate</code>, <code class="option">abort</code> and
        <code class="option">kill</code>. Both options default to <code class="option">terminate</code>.</p><p>If <code class="option">terminate</code> is set the service will be gracefully terminated by sending the signal
        specified in <code class="varname">KillSignal=</code> (defaults to <code class="constant">SIGTERM</code>, see
        <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>). If the
        service does not terminate the <code class="varname">FinalKillSignal=</code> is sent after
        <code class="varname">TimeoutStopSec=</code>. If <code class="option">abort</code> is set, <code class="varname">WatchdogSignal=</code> is sent
        instead and <code class="varname">TimeoutAbortSec=</code> applies before sending <code class="varname">FinalKillSignal=</code>.
        This setting may be used to analyze services that fail to start-up or shut-down intermittently.
        By using <code class="option">kill</code> the service is immediately terminated by sending
        <code class="varname">FinalKillSignal=</code> without any further timeout. This setting can be used to expedite the
        shutdown of failing services.
        </p></dd><dt id="RuntimeMaxSec="><span class="term"><code class="varname">RuntimeMaxSec=</code></span><a class="headerlink" title="Permalink to this term" href="#RuntimeMaxSec=">¶</a></dt><dd><p>Configures a maximum time for the service to run. If this is used and the service has been
        active for longer than the specified time it is terminated and put into a failure state. Note that this setting
        does not have any effect on <code class="varname">Type=oneshot</code> services, as they terminate immediately after
        activation completed. Pass "<code class="literal">infinity</code>" (the default) to configure no runtime
        limit.</p><p>If a service of <code class="varname">Type=notify</code> sends "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>", this may cause
        the runtime to be extended beyond <code class="varname">RuntimeMaxSec=</code>. The first receipt of this message
        must occur before <code class="varname">RuntimeMaxSec=</code> is exceeded, and once the runtime has extended beyond
        <code class="varname">RuntimeMaxSec=</code>, the service manager will allow the service to continue to run, provided
        the service repeats "<code class="literal">EXTEND_TIMEOUT_USEC=…</code>" within the interval specified until the service
        shutdown is achieved by "<code class="literal">STOPPING=1</code>" (or termination). (see
        <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a>).
        </p></dd><dt id="RuntimeRandomizedExtraSec="><span class="term"><code class="varname">RuntimeRandomizedExtraSec=</code></span><a class="headerlink" title="Permalink to this term" href="#RuntimeRandomizedExtraSec=">¶</a></dt><dd><p>This option modifies <code class="varname">RuntimeMaxSec=</code> by increasing the maximum runtime by an
        evenly distributed duration between 0 and the specified value (in seconds). If <code class="varname">RuntimeMaxSec=</code> is
        unspecified, then this feature will be disabled.
        </p></dd><dt id="WatchdogSec="><span class="term"><code class="varname">WatchdogSec=</code></span><a class="headerlink" title="Permalink to this term" href="#WatchdogSec=">¶</a></dt><dd><p>Configures the watchdog timeout for a service.
        The watchdog is activated when the start-up is completed. The
        service must call
        <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a>
        regularly with "<code class="literal">WATCHDOG=1</code>" (i.e. the
        "keep-alive ping"). If the time between two such calls is
        larger than the configured time, then the service is placed in
        a failed state and it will be terminated with
        <code class="constant">SIGABRT</code> (or the signal specified by
        <code class="varname">WatchdogSignal=</code>). By setting
        <code class="varname">Restart=</code> to <code class="option">on-failure</code>,
        <code class="option">on-watchdog</code>, <code class="option">on-abnormal</code> or
        <code class="option">always</code>, the service will be automatically
        restarted. The time configured here will be passed to the
        executed service process in the
        <code class="varname">WATCHDOG_USEC=</code> environment variable. This
        allows daemons to automatically enable the keep-alive pinging
        logic if watchdog support is enabled for the service. If this
        option is used, <code class="varname">NotifyAccess=</code> (see below)
        should be set to open access to the notification socket
        provided by systemd. If <code class="varname">NotifyAccess=</code> is
        not set, it will be implicitly set to <code class="option">main</code>.
        Defaults to 0, which disables this feature. The service can
        check whether the service manager expects watchdog keep-alive
        notifications. See
        <a href="sd_watchdog_enabled.html#"><span class="citerefentry"><span class="refentrytitle">sd_watchdog_enabled</span>(3)</span></a>
        for details.
        <a href="sd_event_set_watchdog.html#"><span class="citerefentry"><span class="refentrytitle">sd_event_set_watchdog</span>(3)</span></a>
        may be used to enable automatic watchdog notification support.
        </p></dd><dt id="Restart="><span class="term"><code class="varname">Restart=</code></span><a class="headerlink" title="Permalink to this term" href="#Restart=">¶</a></dt><dd><p>Configures whether the service shall be
        restarted when the service process exits, is killed, or a
        timeout is reached. The service process may be the main
        service process, but it may also be one of the processes
        specified with <code class="varname">ExecStartPre=</code>,
        <code class="varname">ExecStartPost=</code>,
        <code class="varname">ExecStop=</code>,
        <code class="varname">ExecStopPost=</code>, or
        <code class="varname">ExecReload=</code>. When the death of the process
        is a result of systemd operation (e.g. service stop or
        restart), the service will not be restarted. Timeouts include
        missing the watchdog "keep-alive ping" deadline and a service
        start, reload, and stop operation timeouts.</p><p>Takes one of
        <code class="option">no</code>,
        <code class="option">on-success</code>,
        <code class="option">on-failure</code>,
        <code class="option">on-abnormal</code>,
        <code class="option">on-watchdog</code>,
        <code class="option">on-abort</code>, or
        <code class="option">always</code>.
        If set to <code class="option">no</code> (the default), the service will
        not be restarted. If set to <code class="option">on-success</code>, it
        will be restarted only when the service process exits cleanly.
        In this context, a clean exit means any of the following:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">exit code of 0;</li><li class="listitem">for types other than
            <code class="varname">Type=oneshot</code>, one of the signals
                <code class="constant">SIGHUP</code>,
                <code class="constant">SIGINT</code>,
                <code class="constant">SIGTERM</code>, or
                <code class="constant">SIGPIPE</code>;</li><li class="listitem">exit statuses and signals specified in
                <code class="varname">SuccessExitStatus=</code>.</li></ul></div><p>
        If set to
        <code class="option">on-failure</code>, the service will be restarted
        when the process exits with a non-zero exit code, is
        terminated by a signal (including on core dump, but excluding
        the aforementioned four signals), when an operation (such as
        service reload) times out, and when the configured watchdog
        timeout is triggered. If set to <code class="option">on-abnormal</code>,
        the service will be restarted when the process is terminated
        by a signal (including on core dump, excluding the
        aforementioned four signals), when an operation times out, or
        when the watchdog timeout is triggered. If set to
        <code class="option">on-abort</code>, the service will be restarted only
        if the service process exits due to an uncaught signal not
        specified as a clean exit status. If set to
        <code class="option">on-watchdog</code>, the service will be restarted
        only if the watchdog timeout for the service expires. If set
        to <code class="option">always</code>, the service will be restarted
        regardless of whether it exited cleanly or not, got terminated
        abnormally by a signal, or hit a timeout.</p><div class="table"><a name="id-1.8.4.22.2.3"></a><p class="title"><b>Table 2. Exit causes and the effect of the <code class="varname">Restart=</code> settings</b></p><div class="table-contents"><table class="table" summary="Exit causes and the effect of the Restart= settings" border="1"><colgroup><col class="path"><col class="expl"></colgroup><thead><tr><th>Restart settings/Exit causes</th><th><code class="option">no</code></th><th><code class="option">always</code></th><th><code class="option">on-success</code></th><th><code class="option">on-failure</code></th><th><code class="option">on-abnormal</code></th><th><code class="option">on-abort</code></th><th><code class="option">on-watchdog</code></th></tr></thead><tbody><tr><td>Clean exit code or signal</td><td> </td><td>X</td><td>X</td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>Unclean exit code</td><td> </td><td>X</td><td> </td><td>X</td><td> </td><td> </td><td> </td></tr><tr><td>Unclean signal</td><td> </td><td>X</td><td> </td><td>X</td><td>X</td><td>X</td><td> </td></tr><tr><td>Timeout</td><td> </td><td>X</td><td> </td><td>X</td><td>X</td><td> </td><td> </td></tr><tr><td>Watchdog</td><td> </td><td>X</td><td> </td><td>X</td><td>X</td><td> </td><td>X</td></tr></tbody></table></div></div><br class="table-break"><p>As exceptions to the setting above, the service will not
        be restarted if the exit code or signal is specified in
        <code class="varname">RestartPreventExitStatus=</code> (see below) or
        the service is stopped with <span class="command"><strong>systemctl stop</strong></span>
        or an equivalent operation. Also, the services will always be
        restarted if the exit code or signal is specified in
        <code class="varname">RestartForceExitStatus=</code> (see below).</p><p>Note that service restart is subject to unit start rate
        limiting configured with <code class="varname">StartLimitIntervalSec=</code>
        and <code class="varname">StartLimitBurst=</code>, see
        <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>
        for details.  A restarted service enters the failed state only
        after the start limits are reached.</p><p>Setting this to <code class="option">on-failure</code> is the
        recommended choice for long-running services, in order to
        increase reliability by attempting automatic recovery from
        errors. For services that shall be able to terminate on their
        own choice (and avoid immediate restarting),
        <code class="option">on-abnormal</code> is an alternative choice.</p></dd><dt id="SuccessExitStatus="><span class="term"><code class="varname">SuccessExitStatus=</code></span><a class="headerlink" title="Permalink to this term" href="#SuccessExitStatus=">¶</a></dt><dd><p>Takes a list of exit status definitions that, when returned by the main service
        process, will be considered successful termination, in addition to the normal successful exit status
        0 and, except for <code class="varname">Type=oneshot</code>, the signals <code class="constant">SIGHUP</code>, <code class="constant">SIGINT</code>,
        <code class="constant">SIGTERM</code>, and <code class="constant">SIGPIPE</code>. Exit status definitions can be
        numeric termination statuses, termination status names, or termination signal names, separated by
        spaces. See the Process Exit Codes section in
        <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a> for
        a list of termination status names (for this setting only the part without the
        "<code class="literal">EXIT_</code>" or "<code class="literal">EX_</code>" prefix should be used). See <a href="http://man7.org/linux/man-pages/man7/signal.7.html"><span class="citerefentry"><span class="refentrytitle">signal</span>(7)</span></a> for
        a list of signal names.</p><p>Note that this setting does not change the mapping between numeric exit statuses and their
        names, i.e. regardless how this setting is used 0 will still be mapped to "<code class="literal">SUCCESS</code>"
        (and thus typically shown as "<code class="literal">0/SUCCESS</code>" in tool outputs) and 1 to
        "<code class="literal">FAILURE</code>" (and thus typically shown as "<code class="literal">1/FAILURE</code>"), and so on. It
        only controls what happens as effect of these exit statuses, and how it propagates to the state of
        the service as a whole.</p><p>This option may appear more than once, in which case the list of successful exit statuses is
        merged. If the empty string is assigned to this option, the list is reset, all prior assignments of
        this option will have no effect.</p><div class="example"><a name="id-1.8.4.23.2.4"></a><p class="title"><b>Example 1. A service with the <code class="varname">SuccessExitStatus=</code> setting</b></p><div class="example-contents"><pre class="programlisting">SuccessExitStatus=TEMPFAIL 250 SIGKILL</pre><p>Exit status 75 (<code class="constant">TEMPFAIL</code>), 250, and the termination signal
          <code class="constant">SIGKILL</code> are considered clean service terminations.</p></div></div><br class="example-break"><p>Note: <span class="command"><strong>systemd-analyze exit-status</strong></span> may be used to list exit statuses and
        translate between numerical status values and names.</p></dd><dt id="RestartPreventExitStatus="><span class="term"><code class="varname">RestartPreventExitStatus=</code></span><a class="headerlink" title="Permalink to this term" href="#RestartPreventExitStatus=">¶</a></dt><dd><p>Takes a list of exit status definitions that, when returned by the main service
        process, will prevent automatic service restarts, regardless of the restart setting configured with
        <code class="varname">Restart=</code>. Exit status definitions can either be numeric exit codes or termination
        signal names, and are separated by spaces. Defaults to the empty list, so that, by default, no exit
        status is excluded from the configured restart logic. For example:

        </p><pre class="programlisting">RestartPreventExitStatus=1 6 SIGABRT</pre><p>

        ensures that exit codes 1 and 6 and the termination signal <code class="constant">SIGABRT</code> will not
        result in automatic service restarting. This option may appear more than once, in which case the list
        of restart-preventing statuses is merged. If the empty string is assigned to this option, the list is
        reset and all prior assignments of this option will have no effect.</p><p>Note that this setting has no effect on processes configured via
        <code class="varname">ExecStartPre=</code>, <code class="varname">ExecStartPost=</code>, <code class="varname">ExecStop=</code>,
        <code class="varname">ExecStopPost=</code> or <code class="varname">ExecReload=</code>, but only on the main service
        process, i.e. either the one invoked by <code class="varname">ExecStart=</code> or (depending on
        <code class="varname">Type=</code>, <code class="varname">PIDFile=</code>, …) the otherwise configured main
        process.</p></dd><dt id="RestartForceExitStatus="><span class="term"><code class="varname">RestartForceExitStatus=</code></span><a class="headerlink" title="Permalink to this term" href="#RestartForceExitStatus=">¶</a></dt><dd><p>Takes a list of exit status definitions that,
        when returned by the main service process, will force automatic
        service restarts, regardless of the restart setting configured
        with <code class="varname">Restart=</code>. The argument format is
        similar to
        <code class="varname">RestartPreventExitStatus=</code>.</p></dd><dt id="RootDirectoryStartOnly="><span class="term"><code class="varname">RootDirectoryStartOnly=</code></span><a class="headerlink" title="Permalink to this term" href="#RootDirectoryStartOnly=">¶</a></dt><dd><p>Takes a boolean argument. If true, the root
        directory, as configured with the
        <code class="varname">RootDirectory=</code> option (see
        <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a>
        for more information), is only applied to the process started
        with <code class="varname">ExecStart=</code>, and not to the various
        other <code class="varname">ExecStartPre=</code>,
        <code class="varname">ExecStartPost=</code>,
        <code class="varname">ExecReload=</code>, <code class="varname">ExecStop=</code>,
        and <code class="varname">ExecStopPost=</code> commands. If false, the
        setting is applied to all configured commands the same way.
        Defaults to false.</p></dd><dt id="NonBlocking="><span class="term"><code class="varname">NonBlocking=</code></span><a class="headerlink" title="Permalink to this term" href="#NonBlocking=">¶</a></dt><dd><p>Set the <code class="constant">O_NONBLOCK</code> flag for all file descriptors passed via socket-based
        activation. If true, all file descriptors &gt;= 3 (i.e. all except stdin, stdout, stderr), excluding those passed
        in via the file descriptor storage logic (see <code class="varname">FileDescriptorStoreMax=</code> for details), will
        have the <code class="constant">O_NONBLOCK</code> flag set and hence are in non-blocking mode. This option is only
        useful in conjunction with a socket unit, as described in
        <a href="systemd.socket.html#"><span class="citerefentry"><span class="refentrytitle">systemd.socket</span>(5)</span></a> and has no
        effect on file descriptors which were previously saved in the file-descriptor store for example.  Defaults to
        false.</p></dd><dt id="NotifyAccess="><span class="term"><code class="varname">NotifyAccess=</code></span><a class="headerlink" title="Permalink to this term" href="#NotifyAccess=">¶</a></dt><dd><p>Controls access to the service status notification socket, as accessible via the
        <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a> call. Takes one
        of <code class="option">none</code> (the default), <code class="option">main</code>, <code class="option">exec</code> or
        <code class="option">all</code>. If <code class="option">none</code>, no daemon status updates are accepted from the service
        processes, all status update messages are ignored. If <code class="option">main</code>, only service updates sent from the
        main process of the service are accepted. If <code class="option">exec</code>, only service updates sent from any of the
        main or control processes originating from one of the <code class="varname">Exec*=</code> commands are accepted. If
        <code class="option">all</code>, all services updates from all members of the service's control group are accepted. This
        option should be set to open access to the notification socket when using <code class="varname">Type=notify</code> or
        <code class="varname">WatchdogSec=</code> (see above). If those options are used but <code class="varname">NotifyAccess=</code> is
        not configured, it will be implicitly set to <code class="option">main</code>.</p><p>Note that <code class="function">sd_notify()</code> notifications may be attributed to units correctly only if
        either the sending process is still around at the time PID 1 processes the message, or if the sending process
        is explicitly runtime-tracked by the service manager. The latter is the case if the service manager originally
        forked off the process, i.e. on all processes that match <code class="option">main</code> or
        <code class="option">exec</code>. Conversely, if an auxiliary process of the unit sends an
        <code class="function">sd_notify()</code> message and immediately exits, the service manager might not be able to
        properly attribute the message to the unit, and thus will ignore it, even if
        <code class="varname">NotifyAccess=</code><code class="option">all</code> is set for it.</p><p>Hence, to eliminate all race conditions involving lookup of the client's unit and attribution of notifications
        to units correctly, <code class="function">sd_notify_barrier()</code> may be used. This call acts as a synchronization point
        and ensures all notifications sent before this call have been picked up by the service manager when it returns
        successfully. Use of <code class="function">sd_notify_barrier()</code> is needed for clients which are not invoked by the
        service manager, otherwise this synchronization mechanism is unnecessary for attribution of notifications to the
        unit.</p></dd><dt id="Sockets="><span class="term"><code class="varname">Sockets=</code></span><a class="headerlink" title="Permalink to this term" href="#Sockets=">¶</a></dt><dd><p>Specifies the name of the socket units this
        service shall inherit socket file descriptors from when the
        service is started. Normally, it should not be necessary to use
        this setting, as all socket file descriptors whose unit shares
        the same name as the service (subject to the different unit
        name suffix of course) are passed to the spawned
        process.</p><p>Note that the same socket file descriptors may be passed
        to multiple processes simultaneously. Also note that a
        different service may be activated on incoming socket traffic
        than the one which is ultimately configured to inherit the
        socket file descriptors. Or, in other words: the
        <code class="varname">Service=</code> setting of
        <code class="filename">.socket</code> units does not have to match the
        inverse of the <code class="varname">Sockets=</code> setting of the
        <code class="filename">.service</code> it refers to.</p><p>This option may appear more than once, in which case the list of socket units is merged. Note
        that once set, clearing the list of sockets again (for example, by assigning the empty string to this
        option) is not supported.</p></dd><dt id="FileDescriptorStoreMax="><span class="term"><code class="varname">FileDescriptorStoreMax=</code></span><a class="headerlink" title="Permalink to this term" href="#FileDescriptorStoreMax=">¶</a></dt><dd><p>Configure how many file descriptors may be stored in the service manager for the
        service using
        <a href="sd_pid_notify_with_fds.html#"><span class="citerefentry"><span class="refentrytitle">sd_pid_notify_with_fds</span>(3)</span></a>'s
        "<code class="literal">FDSTORE=1</code>" messages. This is useful for implementing services that can restart
        after an explicit request or a crash without losing state. Any open sockets and other file
        descriptors which should not be closed during the restart may be stored this way. Application state
        can either be serialized to a file in <code class="filename">/run/</code>, or better, stored in a
        <a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html"><span class="citerefentry"><span class="refentrytitle">memfd_create</span>(2)</span></a>
        memory file descriptor. Defaults to 0, i.e. no file descriptors may be stored in the service
        manager. All file descriptors passed to the service manager from a specific service are passed back
        to the service's main process on the next service restart (see
        <a href="sd_listen_fds.html#"><span class="citerefentry"><span class="refentrytitle">sd_listen_fds</span>(3)</span></a> for
        details about the precise protocol used and the order in which the file descriptors are passed). Any
        file descriptors passed to the service manager are automatically closed when
        <code class="constant">POLLHUP</code> or <code class="constant">POLLERR</code> is seen on them, or when the service is
        fully stopped and no job is queued or being executed for it. If this option is used,
        <code class="varname">NotifyAccess=</code> (see above) should be set to open access to the notification socket
        provided by systemd. If <code class="varname">NotifyAccess=</code> is not set, it will be implicitly set to
        <code class="option">main</code>.</p></dd><dt id="USBFunctionDescriptors="><span class="term"><code class="varname">USBFunctionDescriptors=</code></span><a class="headerlink" title="Permalink to this term" href="#USBFunctionDescriptors=">¶</a></dt><dd><p>Configure the location of a file containing
        <a class="ulink" href="https://www.kernel.org/doc/Documentation/usb/functionfs.txt" target="_top">USB
        FunctionFS</a> descriptors, for implementation of USB
        gadget functions. This is used only in conjunction with a
        socket unit with <code class="varname">ListenUSBFunction=</code>
        configured. The contents of this file are written to the
        <code class="filename">ep0</code> file after it is
        opened.</p></dd><dt id="USBFunctionStrings="><span class="term"><code class="varname">USBFunctionStrings=</code></span><a class="headerlink" title="Permalink to this term" href="#USBFunctionStrings=">¶</a></dt><dd><p>Configure the location of a file containing
        USB FunctionFS strings.  Behavior is similar to
        <code class="varname">USBFunctionDescriptors=</code>
        above.</p></dd><dt id="OOMPolicy="><span class="term"><code class="varname">OOMPolicy=</code></span><a class="headerlink" title="Permalink to this term" href="#OOMPolicy=">¶</a></dt><dd><p>Configure the Out-Of-Memory (OOM) killer policy. On Linux, when memory becomes scarce
        the kernel might decide to kill a running process in order to free up memory and reduce memory
        pressure. This setting takes one of <code class="constant">continue</code>, <code class="constant">stop</code> or
        <code class="constant">kill</code>. If set to <code class="constant">continue</code> and a process of the service is
        killed by the kernel's OOM killer this is logged but the service continues running. If set to
        <code class="constant">stop</code> the event is logged but the service is terminated cleanly by the service
        manager. If set to <code class="constant">kill</code> and one of the service's processes is killed by the OOM
        killer the kernel is instructed to kill all remaining processes of the service, too. Defaults to the
        setting <code class="varname">DefaultOOMPolicy=</code> in
        <a href="systemd-system.conf.html#"><span class="citerefentry"><span class="refentrytitle">systemd-system.conf</span>(5)</span></a>
        is set to, except for services where <code class="varname">Delegate=</code> is turned on, where it defaults to
        <code class="constant">continue</code>.</p><p>Use the <code class="varname">OOMScoreAdjust=</code> setting to configure whether processes of the unit
        shall be considered preferred or less preferred candidates for process termination by the Linux OOM
        killer logic. See
        <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a> for
        details.</p></dd></dl></div><p><a name="shared-unit-options"></a>Check
    <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>,
    <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a>, and
    <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a> for more
    settings.</p></div><div class="refsect1"><a name="id-1.9"></a><h2 id="Command lines">Command lines<a class="headerlink" title="Permalink to this headline" href="#Command%20lines">¶</a></h2><p>This section describes command line parsing and
    variable and specifier substitutions for
    <code class="varname">ExecStart=</code>,
    <code class="varname">ExecStartPre=</code>,
    <code class="varname">ExecStartPost=</code>,
    <code class="varname">ExecReload=</code>,
    <code class="varname">ExecStop=</code>, and
    <code class="varname">ExecStopPost=</code> options.</p><p>Multiple command lines may be concatenated in a single directive by separating them with semicolons
    (these semicolons must be passed as separate words). Lone semicolons may be escaped as
    "<code class="literal">\;</code>".</p><p>Each command line is unquoted using the rules described in "Quoting" section in
    <a href="systemd.syntax.html#"><span class="citerefentry"><span class="refentrytitle">systemd.syntax</span>(7)</span></a>. The
    first item becomes the command to execute, and the subsequent items the arguments.</p><p>This syntax is inspired by shell syntax, but only the meta-characters and expansions
    described in the following paragraphs are understood, and the expansion of variables is
    different. Specifically, redirection using
    "<code class="literal">&lt;</code>",
    "<code class="literal">&lt;&lt;</code>",
    "<code class="literal">&gt;</code>", and
    "<code class="literal">&gt;&gt;</code>", pipes using
    "<code class="literal">|</code>", running programs in the background using
    "<code class="literal">&amp;</code>", and <span class="emphasis"><em>other elements of shell
    syntax are not supported</em></span>.</p><p>The command to execute may contain spaces, but control characters are not allowed.</p><p>The command line accepts "<code class="literal">%</code>" specifiers as described in
    <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>.</p><p>Basic environment variable substitution is supported. Use
    "<code class="literal">${FOO}</code>" as part of a word, or as a word of its
    own, on the command line, in which case it will be erased and replaced
    by the exact value of the environment variable (if any) including all
    whitespace it contains, always resulting in exactly a single argument.
    Use "<code class="literal">$FOO</code>" as a separate word on the command line, in
    which case it will be replaced by the value of the environment
    variable split at whitespace, resulting in zero or more arguments.
    For this type of expansion, quotes are respected when splitting
    into words, and afterwards removed.</p><p>If the command is not a full (absolute) path, it will be resolved to a full path using a
    fixed search path determined at compilation time. Searched directories include
    <code class="filename">/usr/local/bin/</code>, <code class="filename">/usr/bin/</code>, <code class="filename">/bin/</code>
    on systems using split <code class="filename">/usr/bin/</code> and <code class="filename">/bin/</code>
    directories, and their <code class="filename">sbin/</code> counterparts on systems using split
    <code class="filename">bin/</code> and <code class="filename">sbin/</code>. It is thus safe to use just the
    executable name in case of executables located in any of the "standard" directories, and an
    absolute path must be used in other cases. Using an absolute path is recommended to avoid
    ambiguity. Hint: this search path may be queried using
    <span class="command"><strong>systemd-path search-binaries-default</strong></span>.</p><p>Example:</p><pre class="programlisting">Environment="ONE=one" 'TWO=two two'
ExecStart=echo $ONE $TWO ${TWO}</pre><p>This will execute <span class="command"><strong>/bin/echo</strong></span> with four
    arguments: "<code class="literal">one</code>", "<code class="literal">two</code>",
    "<code class="literal">two</code>", and "<code class="literal">two two</code>".</p><p>Example:</p><pre class="programlisting">Environment=ONE='one' "TWO='two two' too" THREE=
ExecStart=/bin/echo ${ONE} ${TWO} ${THREE}
ExecStart=/bin/echo $ONE $TWO $THREE</pre><p>This results in <code class="filename">/bin/echo</code> being
    called twice, the first time with arguments
    "<code class="literal">'one'</code>",
    "<code class="literal">'two two' too</code>", "<code class="literal"></code>",
    and the second time with arguments
    "<code class="literal">one</code>", "<code class="literal">two two</code>",
    "<code class="literal">too</code>".
    </p><p>To pass a literal dollar sign, use "<code class="literal">$$</code>".
    Variables whose value is not known at expansion time are treated
    as empty strings. Note that the first argument (i.e. the program
    to execute) may not be a variable.</p><p>Variables to be used in this fashion may be defined through
    <code class="varname">Environment=</code> and
    <code class="varname">EnvironmentFile=</code>. In addition, variables listed
    in the section "Environment variables in spawned processes" in
    <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a>,
    which are considered "static configuration", may be used (this
    includes e.g. <code class="varname">$USER</code>, but not
    <code class="varname">$TERM</code>).</p><p>Note that shell command lines are not directly supported. If
    shell command lines are to be used, they need to be passed
    explicitly to a shell implementation of some kind. Example:</p><pre class="programlisting">ExecStart=sh -c 'dmesg | tac'</pre><p>Example:</p><pre class="programlisting">ExecStart=echo one ; echo "two two"</pre><p>This will execute <span class="command"><strong>echo</strong></span> two times,
    each time with one argument: "<code class="literal">one</code>" and
    "<code class="literal">two two</code>", respectively. Because two commands are
    specified, <code class="varname">Type=oneshot</code> must be used.</p><p>Example:</p><pre class="programlisting">ExecStart=echo / &gt;/dev/null &amp; \; \
ls</pre><p>This will execute <span class="command"><strong>echo</strong></span>
    with five arguments: "<code class="literal">/</code>",
    "<code class="literal">&gt;/dev/null</code>",
    "<code class="literal">&amp;</code>", "<code class="literal">;</code>", and
    "<code class="literal">ls</code>".</p></div><div class="refsect1"><a name="id-1.10"></a><h2 id="Examples">Examples<a class="headerlink" title="Permalink to this headline" href="#Examples">¶</a></h2><div class="example"><a name="id-1.10.2"></a><p class="title"><b>Example 2. Simple service</b></p><div class="example-contents"><p>The following unit file creates a service that will
      execute <code class="filename">/usr/sbin/foo-daemon</code>. Since no
      <code class="varname">Type=</code> is specified, the default
      <code class="varname">Type=</code><code class="option">simple</code> will be assumed.
      systemd will assume the unit to be started immediately after the
      program has begun executing.</p><pre class="programlisting">[Unit]
Description=Foo

[Service]
ExecStart=/usr/sbin/foo-daemon

[Install]
WantedBy=multi-user.target</pre><p>Note that systemd assumes here that the process started by
      systemd will continue running until the service terminates. If
      the program daemonizes itself (i.e. forks), please use
      <code class="varname">Type=</code><code class="option">forking</code> instead.</p><p>Since no <code class="varname">ExecStop=</code> was specified,
      systemd will send SIGTERM to all processes started from this
      service, and after a timeout also SIGKILL. This behavior can be
      modified, see
      <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>
      for details.</p><p>Note that this unit type does not include any type of
      notification when a service has completed initialization. For
      this, you should use other unit types, such as
      <code class="varname">Type=</code><code class="option">notify</code> if the service
      understands systemd's notification protocol,
      <code class="varname">Type=</code><code class="option">forking</code> if the service
      can background itself or
      <code class="varname">Type=</code><code class="option">dbus</code> if the unit
      acquires a DBus name once initialization is complete. See
      below.</p></div></div><br class="example-break"><div class="example"><a name="id-1.10.3"></a><p class="title"><b>Example 3. Oneshot service</b></p><div class="example-contents"><p>Sometimes, units should just execute an action without
      keeping active processes, such as a filesystem check or a
      cleanup action on boot. For this,
      <code class="varname">Type=</code><code class="option">oneshot</code> exists. Units
      of this type will wait until the process specified terminates
      and then fall back to being inactive. The following unit will
      perform a cleanup action:</p><pre class="programlisting">[Unit]
Description=Cleanup old Foo data

[Service]
Type=oneshot
ExecStart=/usr/sbin/foo-cleanup

[Install]
WantedBy=multi-user.target</pre><p>Note that systemd will consider the unit to be in the
      state "starting" until the program has terminated, so ordered
      dependencies will wait for the program to finish before starting
      themselves. The unit will revert to the "inactive" state after
      the execution is done, never reaching the "active" state. That
      means another request to start the unit will perform the action
      again.</p><p><code class="varname">Type=</code><code class="option">oneshot</code> are the
      only service units that may have more than one
      <code class="varname">ExecStart=</code> specified. For units with multiple
      commands (<code class="varname">Type=oneshot</code>), all commands will be run again.</p><p> For <code class="varname">Type=oneshot</code>, <code class="varname">Restart=</code><code class="option">always</code>
      and <code class="varname">Restart=</code><code class="option">on-success</code> are <span class="emphasis"><em>not</em></span> allowed.</p></div></div><br class="example-break"><div class="example"><a name="id-1.10.4"></a><p class="title"><b>Example 4. Stoppable oneshot service</b></p><div class="example-contents"><p>Similarly to the oneshot services, there are sometimes
      units that need to execute a program to set up something and
      then execute another to shut it down, but no process remains
      active while they are considered "started". Network
      configuration can sometimes fall into this category. Another use
      case is if a oneshot service shall not be executed each time
      when they are pulled in as a dependency, but only the first
      time.</p><p>For this, systemd knows the setting
      <code class="varname">RemainAfterExit=</code><code class="option">yes</code>, which
      causes systemd to consider the unit to be active if the start
      action exited successfully. This directive can be used with all
      types, but is most useful with
      <code class="varname">Type=</code><code class="option">oneshot</code> and
      <code class="varname">Type=</code><code class="option">simple</code>. With
      <code class="varname">Type=</code><code class="option">oneshot</code>, systemd waits
      until the start action has completed before it considers the
      unit to be active, so dependencies start only after the start
      action has succeeded. With
      <code class="varname">Type=</code><code class="option">simple</code>, dependencies
      will start immediately after the start action has been
      dispatched. The following unit provides an example for a simple
      static firewall.</p><pre class="programlisting">[Unit]
Description=Simple firewall

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/sbin/simple-firewall-start
ExecStop=/usr/local/sbin/simple-firewall-stop

[Install]
WantedBy=multi-user.target</pre><p>Since the unit is considered to be running after the start
      action has exited, invoking <span class="command"><strong>systemctl start</strong></span>
      on that unit again will cause no action to be taken.</p></div></div><br class="example-break"><div class="example"><a name="id-1.10.5"></a><p class="title"><b>Example 5. Traditional forking services</b></p><div class="example-contents"><p>Many traditional daemons/services background (i.e. fork,
      daemonize) themselves when starting. Set
      <code class="varname">Type=</code><code class="option">forking</code> in the
      service's unit file to support this mode of operation. systemd
      will consider the service to be in the process of initialization
      while the original program is still running. Once it exits
      successfully and at least a process remains (and
      <code class="varname">RemainAfterExit=</code><code class="option">no</code>), the
      service is considered started.</p><p>Often, a traditional daemon only consists of one process.
      Therefore, if only one process is left after the original
      process terminates, systemd will consider that process the main
      process of the service. In that case, the
      <code class="varname">$MAINPID</code> variable will be available in
      <code class="varname">ExecReload=</code>, <code class="varname">ExecStop=</code>,
      etc.</p><p>In case more than one process remains, systemd will be
      unable to determine the main process, so it will not assume
      there is one. In that case, <code class="varname">$MAINPID</code> will not
      expand to anything. However, if the process decides to write a
      traditional PID file, systemd will be able to read the main PID
      from there. Please set <code class="varname">PIDFile=</code> accordingly.
      Note that the daemon should write that file before finishing
      with its initialization. Otherwise, systemd might try to read the
      file before it exists.</p><p>The following example shows a simple daemon that forks and
      just starts one process in the background:</p><pre class="programlisting">[Unit]
Description=Some simple daemon

[Service]
Type=forking
ExecStart=/usr/sbin/my-simple-daemon -d

[Install]
WantedBy=multi-user.target</pre><p>Please see
      <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>
      for details on how you can influence the way systemd terminates
      the service.</p></div></div><br class="example-break"><div class="example"><a name="id-1.10.6"></a><p class="title"><b>Example 6. DBus services</b></p><div class="example-contents"><p>For services that acquire a name on the DBus system bus,
      use <code class="varname">Type=</code><code class="option">dbus</code> and set
      <code class="varname">BusName=</code> accordingly. The service should not
      fork (daemonize). systemd will consider the service to be
      initialized once the name has been acquired on the system bus.
      The following example shows a typical DBus service:</p><pre class="programlisting">[Unit]
Description=Simple DBus service

[Service]
Type=dbus
BusName=org.example.simple-dbus-service
ExecStart=/usr/sbin/simple-dbus-service

[Install]
WantedBy=multi-user.target</pre><p>For <span class="emphasis"><em>bus-activatable</em></span> services, do not
      include a [Install] section in the systemd
      service file, but use the <code class="varname">SystemdService=</code>
      option in the corresponding DBus service file, for example
      (<code class="filename">/usr/share/dbus-1/system-services/org.example.simple-dbus-service.service</code>):</p><pre class="programlisting">[D-BUS Service]
Name=org.example.simple-dbus-service
Exec=/usr/sbin/simple-dbus-service
User=root
SystemdService=simple-dbus-service.service</pre><p>Please see
      <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>
      for details on how you can influence the way systemd terminates
      the service.</p></div></div><br class="example-break"><div class="example"><a name="id-1.10.7"></a><p class="title"><b>Example 7. Services that notify systemd about their initialization</b></p><div class="example-contents"><p><code class="varname">Type=</code><code class="option">simple</code> services
      are really easy to write, but have the major disadvantage of
      systemd not being able to tell when initialization of the given
      service is complete. For this reason, systemd supports a simple
      notification protocol that allows daemons to make systemd aware
      that they are done initializing. Use
      <code class="varname">Type=</code><code class="option">notify</code> for this. A
      typical service file for such a daemon would look like
      this:</p><pre class="programlisting">[Unit]
Description=Simple notifying service

[Service]
Type=notify
ExecStart=/usr/sbin/simple-notifying-service

[Install]
WantedBy=multi-user.target</pre><p>Note that the daemon has to support systemd's notification
      protocol, else systemd will think the service has not started yet
      and kill it after a timeout. For an example of how to update
      daemons to support this protocol transparently, take a look at
      <a href="sd_notify.html#"><span class="citerefentry"><span class="refentrytitle">sd_notify</span>(3)</span></a>.
      systemd will consider the unit to be in the 'starting' state
      until a readiness notification has arrived.</p><p>Please see
      <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>
      for details on how you can influence the way systemd terminates
      the service.</p></div></div><br class="example-break"></div><div class="refsect1"><a name="id-1.11"></a><h2 id="See Also">See Also<a class="headerlink" title="Permalink to this headline" href="#See%20Also">¶</a></h2><p>
        <a href="systemd.html#"><span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span></a>,
        <a href="systemctl.html#"><span class="citerefentry"><span class="refentrytitle">systemctl</span>(1)</span></a>,
        <a href="systemd-system.conf.html#"><span class="citerefentry"><span class="refentrytitle">systemd-system.conf</span>(5)</span></a>,
        <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>,
        <a href="systemd.exec.html#"><span class="citerefentry"><span class="refentrytitle">systemd.exec</span>(5)</span></a>,
        <a href="systemd.resource-control.html#"><span class="citerefentry"><span class="refentrytitle">systemd.resource-control</span>(5)</span></a>,
        <a href="systemd.kill.html#"><span class="citerefentry"><span class="refentrytitle">systemd.kill</span>(5)</span></a>,
        <a href="systemd.directives.html#"><span class="citerefentry"><span class="refentrytitle">systemd.directives</span>(7)</span></a>,
        <a href="systemd-run.html#"><span class="citerefentry"><span class="refentrytitle">systemd-run</span>(1)</span></a>
      </p></div></div></body></html>
