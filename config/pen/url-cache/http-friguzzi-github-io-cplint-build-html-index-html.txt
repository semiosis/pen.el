HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 42226
Server: GitHub.com
Content-Type: text/html; charset=utf-8
permissions-policy: interest-cohort=()
Last-Modified: Thu, 08 Feb 2024 07:59:33 GMT
Access-Control-Allow-Origin: *
ETag: W/"65c489e5-4d468"
expires: Mon, 17 Jun 2024 01:25:44 GMT
Cache-Control: max-age=600
x-proxy-cache: MISS
X-GitHub-Request-Id: 4968:1A92B6:241A13:28F864:666F8E3F
Accept-Ranges: bytes
Date: Mon, 17 Jun 2024 01:15:46 GMT
Via: 1.1 varnish
Age: 2
X-Served-By: cache-chc950024-CHC
X-Cache: HIT
X-Cache-Hits: 1
X-Timer: S1718586946.328170,VS0,VE1
Vary: Accept-Encoding
X-Fastly-Request-ID: 0b6274e69cda1eaf4307b5eadfd2e88a7110c083


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>cplint - SWI-Prolog Version &#8212; cplint 4.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="#">cplint 4.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cplint - SWI-Prolog Version</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="cplint-swi-prolog-version">
<h1>cplint - SWI-Prolog Version<a class="headerlink" href="#cplint-swi-prolog-version" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>cplint is a suite of programs for reasoning with LPADs/CP-logic programs <span id="id1">[<a class="reference internal" href="#id69" title="J. Vennekens, M. Denecker, and M. Bruynooghe. Representing causal information about a probabilistic process. In Proceedings of the 10th European Conference on Logics in Artificial Intelligence, LNAI. Springer, September 2006.">VDB06</a>, <a class="reference internal" href="#id70" title="J. Vennekens, Marc Denecker, and Maurice Bruynooghe. CP-logic: a language of causal probabilistic events and its relation to logic programming. Theory Pract. Log. Program., 9(3):245-308, 2009.">VDB09</a>, <a class="reference internal" href="#id68" title="J. Vennekens and S. Verbaeten. Logic programs with annotated disjunctions. Technical Report CW386, K. U. Leuven, 2003.">VV03</a>, <a class="reference internal" href="#id48" title="J. Vennekens, S. Verbaeten, and M. Bruynooghe. Logic programs with annotated disjunctions. In International Conference on Logic Programming, volume 3131 of LNCS, 195-209. Springer, 2004.">VVB04</a>]</span>.
It contains modules for both inference and learning.</p>
<p>cplint is available in three versions, one for Yap Prolog, one for XSB and one for SWI-Prolog.
They differ slightly in the features offered.
This manual is about the SWI-Prolog version.
You can find the manual for the Yap version at <a class="reference external" href="http://ds.ing.unife.it/~friguzzi/software/cplint/manual.html">http://ds.ing.unife.it/~friguzzi/software/cplint/manual.html</a> and
for the XSB version at <a class="reference external" href="http://xsb.sourceforge.net/manual2/manual2.pdf">http://xsb.sourceforge.net/manual2/manual2.pdf</a>.</p>
<p>cplint on SWISH is a web application for using cplint available at <a class="reference external" href="http://cplint.eu">http://cplint.eu</a>.</p>
</section>
<section id="predicate-reference">
<h2>Predicate Reference<a class="headerlink" href="#predicate-reference" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/pita.html">pita</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/mcintyre.html">mcintyre</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/slipcover.html">slipcover</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/viterbi.html">viterbi</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/cplint_util.html">cplint_util</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/kbest.html">kbest</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/pitaind.html">pitaind</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint/pldoc/lemur.html">lemur</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/cplint_r">cplint_r</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/auc">auc</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/matrix">matrix</a></p></li>
<li><p><a class="reference external" href="https://friguzzi.github.io/bddem">bddem</a></p></li>
</ul>
</div></blockquote>
</section>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>cplint is distributed as a <a class="reference external" href="http://www.swi-prolog.org/pack/list?p=cplint">pack</a> of <a class="reference external" href="http://www.swi-prolog.org/">SWI-Prolog</a>.
To install it, use</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">pack_install</span><span class="p">(</span><span class="s s-Atom">cplint</span><span class="p">).</span>
</pre></div>
</div>
<section id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<p>It requires the packs</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://github.com/friguzzi/bddem">bddem</a></p></li>
<li><p><a class="reference external" href="https://github.com/friguzzi/auc">auc</a></p></li>
<li><p><a class="reference external" href="https://github.com/friguzzi/matrix">matrix</a></p></li>
</ul>
</div></blockquote>
<p>They are installed automatically when installing pack <cite>cplint</cite> or can installed manually as</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>swipl
<span class="go">?- pack_install(bddem).</span>
<span class="go">?- pack_install(auc).</span>
<span class="go">?- pack_install(matrix).</span>
</pre></div>
</div>
<p><cite>bddem</cite> uses a foreign library and contains the library binaries for 32 and 64 bits Linux, MacOs and 64 bits Windows. If you want to recompile the foreign library you can use</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">pack_rebuild</span><span class="p">(</span><span class="s s-Atom">bdeem</span><span class="p">).</span>
</pre></div>
</div>
<p>On 32 and 64 bits Linux this should work out of the box. On 64 bits Windows the library must be rebuilt by hand, see the pack page <a class="reference external" href="https://github.com/friguzzi/bddem">https://github.com/friguzzi/bddem</a>.</p>
<p>You can upgrade the pack with</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>swipl
<span class="go">?- pack_upgrade(cplint).</span>
</pre></div>
</div>
<p>Note that the packs on which <cite>cplint</cite> depends are not upgraded automatically in this case so they need to be upgraded manually.</p>
</section>
<section id="example-of-use">
<h3>Example of use<a class="headerlink" href="#example-of-use" title="Permalink to this headline">¶</a></h3>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span> &lt;pack&gt;/cplint/prolog/examples
<span class="gp">$ </span>swipl
<span class="go">?- [coin].</span>
<span class="go">?- prob(heads(coin),P).</span>
</pre></div>
</div>
</section>
<section id="testing-the-installation">
<h3>Testing the installation<a class="headerlink" href="#testing-the-installation" title="Permalink to this headline">¶</a></h3>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>swipl
<span class="go">?- [library(cplint_test/test)].</span>
<span class="go">?- test.</span>
</pre></div>
</div>
</section>
<section id="datasets">
<h3>Datasets<a class="headerlink" href="#datasets" title="Permalink to this headline">¶</a></h3>
<p>Other machine learning datasets are available in pack <a class="reference external" href="https://github.com/friguzzi/cplint_datasets">cplint_datasets</a>.</p>
</section>
<section id="support">
<h3>Support<a class="headerlink" href="#support" title="Permalink to this headline">¶</a></h3>
<p>Use the Google group <a class="reference external" href="https://groups.google.com/forum/#!forum/cplint">https://groups.google.com/forum/#!forum/cplint</a>.</p>
</section>
</section>
<section id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>cplint allows the definition of discrete probability distributions and continuous probability densities.</p>
<section id="discrete-probability-distributions">
<h3>Discrete Probability Distributions<a class="headerlink" href="#discrete-probability-distributions" title="Permalink to this headline">¶</a></h3>
<p>LPAD and CP-logic programs consist of a set of annotated disjunctive clauses.
Disjunction in the head is represented with a semicolon and atoms in the head are separated from probabilities by a colon.
For the rest, the usual syntax of Prolog is used.
A general CP-logic clause has the form:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">h1</span><span class="o">:</span><span class="s s-Atom">p1</span> <span class="p">;</span> <span class="p">...</span> <span class="p">;</span> <span class="s s-Atom">hn</span><span class="p">:</span><span class="nf">pn</span> <span class="o">:-</span> <span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Body</span></code> is a conjunction of goals as in Prolog.
No parentheses are necessary.
The <code class="code docutils literal notranslate"><span class="pre">pi</span></code> are numeric expressions.
It is up to the user to ensure that the numeric expressions are legal, i.e. that they sum up to less than one.
If the clause has an empty body, it can be represented like this:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">h1</span><span class="o">:</span><span class="s s-Atom">p1</span> <span class="p">;</span> <span class="p">...</span> <span class="p">;</span> <span class="s s-Atom">hn</span><span class="p">:</span><span class="s s-Atom">pn</span><span class="p">.</span>
</pre></div>
</div>
<p>If the clause has a single head with probability 1, the annotation can be omitted and the clause takes
the form of a normal prolog clause, i.e.:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="o">:-</span> <span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>stands for:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">h1</span><span class="o">:</span><span class="mi">1</span> <span class="o">:-</span> <span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>The coin example <span id="id5">[<a class="reference internal" href="#id48" title="J. Vennekens, S. Verbaeten, and M. Bruynooghe. Logic programs with annotated disjunctions. In International Conference on Logic Programming, volume 3131 of LNCS, 195-209. Springer, 2004.">VVB04</a>]</span> is represented as (file <a class="reference external" href="http://cplint.eu/e/coin.pl">coin.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">heads</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="p">;</span> <span class="nf">tails</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">:-</span>
    <span class="nf">toss</span><span class="p">(</span><span class="nv">Coin</span><span class="p">),</span><span class="s s-Atom">\+</span><span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">).</span>

<span class="nf">heads</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.6</span> <span class="p">;</span> <span class="nf">tails</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.4</span> <span class="o">:-</span>
    <span class="nf">toss</span><span class="p">(</span><span class="nv">Coin</span><span class="p">),</span><span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">).</span>

<span class="nf">fair</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.9</span> <span class="p">;</span> <span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.1</span><span class="p">.</span>

<span class="nf">toss</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">).</span>
</pre></div>
</div>
<p>The first clause states that if we toss a coin that is not biased it has equal probability of landing heads and
tails.
The second states that if the coin is biased it has a slightly higher probability of landing heads.
The third states that the coin is fair with probability 0.9 and biased with probability 0.1 and the last clause
states that we toss a coin with certainty.</p>
<p>Moreover, the bodies of rules may contain built-in predicates, predicates from the libraries <code class="code docutils literal notranslate"><span class="pre">lists</span></code>,
<code class="code docutils literal notranslate"><span class="pre">apply</span></code> and <code class="code docutils literal notranslate"><span class="pre">clpr/nf_r</span></code> plus the predicate <code class="code docutils literal notranslate"><span class="pre">average/2</span></code>
that, given a list of numbers, computes its arithmetic mean.</p>
<p>The body of rules may also contain the predicate <code class="code docutils literal notranslate"><span class="pre">prob/2</span></code> that computes the probability of an atom,
thus allowing nested probability computations.
For example (<a class="reference external" href="http://cplint.eu/e/meta.pl">meta.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">a</span><span class="p">:</span><span class="mf">0.2</span><span class="o">:-</span>
    <span class="nf">prob</span><span class="p">(</span><span class="s s-Atom">b</span><span class="p">,</span><span class="nv">P</span><span class="p">),</span>
    <span class="nv">P</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">.</span>
</pre></div>
</div>
<p>is a valid rule.</p>
<p>Moreover, the probabilistic annotations can be variables, as in (<a class="reference external" href="http://cplint.eu/e/flexprob.pl">flexprob.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">red</span><span class="p">(</span><span class="nv">Prob</span><span class="p">)</span><span class="o">:</span><span class="nv">Prob</span><span class="p">.</span>

<span class="nf">draw_red</span><span class="p">(</span><span class="nv">R</span><span class="p">,</span> <span class="nv">G</span><span class="p">)</span><span class="o">:-</span>
    <span class="nv">Prob</span> <span class="o">is</span> <span class="nv">R</span><span class="s s-Atom">/</span><span class="p">(</span><span class="nv">R</span> <span class="o">+</span> <span class="nv">G</span><span class="p">),</span>
    <span class="nf">red</span><span class="p">(</span><span class="nv">Prob</span><span class="p">).</span>
</pre></div>
</div>
<p>Variables in probabilistic annotations must be ground when resolution reaches the end of the body, otherwise an exception is raised.</p>
<p>Alternative ways of specifying probability distribution include</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">A</span><span class="o">:</span><span class="nb">discrete</span><span class="p">(</span><span class="nv">Var</span><span class="p">,</span><span class="nv">D</span><span class="p">)</span><span class="o">:-</span><span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">A</span><span class="o">:</span><span class="nb">finite</span><span class="p">(</span><span class="nv">Var</span><span class="p">,</span><span class="nv">D</span><span class="p">)</span><span class="o">:-</span><span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">A</span></code> is an atom containing variable <code class="code docutils literal notranslate"><span class="pre">Var</span></code> and <code class="code docutils literal notranslate"><span class="pre">D</span></code> is a list of pairs <code class="code docutils literal notranslate"><span class="pre">Value:Prob</span></code> assigning probability <code class="code docutils literal notranslate"><span class="pre">Prob</span></code> to <code class="code docutils literal notranslate"><span class="pre">Value</span></code>.</p>
<p>Moreover, you can use</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">A</span><span class="o">:</span><span class="nb">uniform</span><span class="p">(</span><span class="nv">Var</span><span class="p">,</span><span class="nv">D</span><span class="p">)</span><span class="o">:-</span><span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">A</span></code> is an atom containing variable <code class="code docutils literal notranslate"><span class="pre">Var</span></code> and <code class="code docutils literal notranslate"><span class="pre">D</span></code> is a list of values each taking the same probability (1 over the length of <code class="code docutils literal notranslate"><span class="pre">D</span></code>).</p>
<section id="problog-syntax">
<h4>ProbLog Syntax<a class="headerlink" href="#problog-syntax" title="Permalink to this headline">¶</a></h4>
<p>You can also use ProbLog <span id="id6">[<a class="reference internal" href="#id49" title="L. De Raedt, A. Kimmig, and H. Toivonen. ProbLog: a probabilistic Prolog and its application in link discovery. In International Joint Conference on Artificial Intelligence, 2462-2467. 2007.">DRKT07</a>]</span> syntax, so a general clause takes the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">p1</span><span class="o">::</span><span class="s s-Atom">h1</span> <span class="p">;</span> <span class="p">...</span> <span class="p">;</span> <span class="s s-Atom">pn</span><span class="p">:</span><span class="o">:</span><span class="nf">hn</span> <span class="o">:-</span> <span class="s s-Atom">body</span>
</pre></div>
</div>
<p>where the <span class="math notranslate nohighlight">\(pi\)</span> are numeric expressions.</p>
</section>
<section id="prism-syntax">
<h4>PRISM Syntax<a class="headerlink" href="#prism-syntax" title="Permalink to this headline">¶</a></h4>
<p>You can also use PRISM <span id="id7">[<a class="reference internal" href="#id50" title="Taisuke Sato and Yoshitaka Kameya. Prism: a language for symbolic-statistical modeling. In International Joint Conference on Artificial Intelligence, 1330-1339. 1997.">SK97</a>]</span> syntax, so a program is composed of a set of regular Prolog rules whose body may contain calls to the <code class="code docutils literal notranslate"><span class="pre">msw/2</span></code> predicate (multi-ary switch).
A call <code class="code docutils literal notranslate"><span class="pre">msw(term,value)</span></code> means that a random variable associated to <code class="code docutils literal notranslate"><span class="pre">term</span></code> assumes value <code class="code docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>The admissible values for a discrete random variable are specified using facts for the <code class="code docutils literal notranslate"><span class="pre">values/2</span></code> predicate
of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">values</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span><span class="nv">L</span><span class="p">).</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">T</span></code> is a term (possibly containing variables) and <code class="code docutils literal notranslate"><span class="pre">L</span></code> is a list of values.
The distribution over values is specified using directives for <code class="code docutils literal notranslate"><span class="pre">set_sw/2</span></code> of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">set_sw</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span><span class="nv">LP</span><span class="p">).</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">T</span></code> is a term (possibly containing variables) and <code class="code docutils literal notranslate"><span class="pre">LP</span></code> is a list of probability values.
Remember that usually in PRISM each call to <code class="code docutils literal notranslate"><span class="pre">msw/2</span></code> refers to a different random variable, i.e., no memoing is performed, differently from the case of LPAD/CP-Logic/ProbLog.
This behavior can be changed with the setting <code class="code docutils literal notranslate"><span class="pre">prism_memoization</span></code>: if set to <code class="code docutils literal notranslate"><span class="pre">true</span></code> then memoization is performed.
Its default value is <code class="code docutils literal notranslate"><span class="pre">false</span></code>, i.e., no memoization.</p>
<p>For example, the coin example above in PRISM syntax becomes (<a class="reference external" href="http://cplint.eu/e/coinmsw.pl">coinmsw.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">values</span><span class="p">(</span><span class="nf">throw</span><span class="p">(</span><span class="k">_</span><span class="p">),[</span><span class="s s-Atom">heads</span><span class="p">,</span><span class="s s-Atom">tails</span><span class="p">]).</span>
<span class="o">:-</span> <span class="nf">set_sw</span><span class="p">(</span><span class="nf">throw</span><span class="p">(</span><span class="s s-Atom">fair</span><span class="p">),[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]).</span>
<span class="o">:-</span> <span class="nf">set_sw</span><span class="p">(</span><span class="nf">throw</span><span class="p">(</span><span class="s s-Atom">biased</span><span class="p">),[</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.4</span><span class="p">]).</span>
<span class="nf">values</span><span class="p">(</span><span class="s s-Atom">fairness</span><span class="p">,[</span><span class="s s-Atom">fair</span><span class="p">,</span><span class="s s-Atom">biased</span><span class="p">]).</span>
<span class="o">:-</span> <span class="nf">set_sw</span><span class="p">(</span><span class="s s-Atom">fairness</span><span class="p">,[</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.1</span><span class="p">]).</span>
<span class="nf">res</span><span class="p">(</span><span class="nv">Coin</span><span class="p">,</span><span class="nv">R</span><span class="p">)</span><span class="o">:-</span> <span class="nf">toss</span><span class="p">(</span><span class="nv">Coin</span><span class="p">),</span><span class="nf">fairness</span><span class="p">(</span><span class="nv">Coin</span><span class="p">,</span><span class="nv">Fairness</span><span class="p">),</span><span class="nf">msw</span><span class="p">(</span><span class="nf">throw</span><span class="p">(</span><span class="nv">Fairness</span><span class="p">),</span><span class="nv">R</span><span class="p">).</span>
<span class="nf">fairness</span><span class="p">(</span><span class="k">_</span><span class="nv">Coin</span><span class="p">,</span><span class="nv">Fairness</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">msw</span><span class="p">(</span><span class="s s-Atom">fairness</span><span class="p">,</span><span class="nv">Fairness</span><span class="p">).</span>
<span class="nf">toss</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">).</span>
</pre></div>
</div>
</section>
</section>
<section id="continuous-probability-densities">
<h3>Continuous Probability Densities<a class="headerlink" href="#continuous-probability-densities" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">cplint</span></code> handles continuous or integer random variables as well with its sampling inference module.
To specify a probability density on an argument <code class="code docutils literal notranslate"><span class="pre">Var</span></code> of an atom <code class="code docutils literal notranslate"><span class="pre">A</span></code> you can used rules of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">A</span><span class="o">:</span><span class="nv">Density</span><span class="o">:-</span> <span class="nv">Body</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Density</span></code> is a special atom identifying a probability density on variable <code class="code docutils literal notranslate"><span class="pre">Var</span></code> and <code class="code docutils literal notranslate"><span class="pre">Body</span></code>
(optional) is a regular clause body. Allowed <code class="code docutils literal notranslate"><span class="pre">Density</span></code> atoms are</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">uniform_dens(Var,L,U)</span></code>: <code class="code docutils literal notranslate"><span class="pre">Var</span></code> is uniformly distributed in <code class="code docutils literal notranslate"><span class="pre">[L,U]</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">gaussian(Var,Mean,Variance)</span></code>: <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows a Gaussian distribution with mean <code class="code docutils literal notranslate"><span class="pre">Mean</span></code> and variance <code class="code docutils literal notranslate"><span class="pre">Variance</span></code>. The distribution can be multivariate if <code class="code docutils literal notranslate"><span class="pre">Mean</span></code> is a list and <code class="code docutils literal notranslate"><span class="pre">Variance</span></code> a list of lists representing the mean vector and the covariance matrix. In this case the values of <code class="code docutils literal notranslate"><span class="pre">Var</span></code> are lists of real values with the same length as that of <code class="code docutils literal notranslate"><span class="pre">Mean</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">dirichlet(Var,Par)</span></code>: <code class="code docutils literal notranslate"><span class="pre">Var</span></code> is a list of real numbers following a Dirichlet distribution with <span class="math notranslate nohighlight">\(\alpha\)</span> parameters specified by the list <code class="code docutils literal notranslate"><span class="pre">Par</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">gamma(Var,Shape,Scale)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows a gamma distribution with shape parameter <code class="code docutils literal notranslate"><span class="pre">Shape</span></code> and scale parameter <code class="code docutils literal notranslate"><span class="pre">Scale</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">beta(Var,Alpha,Beta)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows a beta distribution with parameters <code class="code docutils literal notranslate"><span class="pre">Alpha</span></code> and <code class="code docutils literal notranslate"><span class="pre">Beta</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">poisson(Var,Lambda)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows a Poisson distribution with parameter <code class="code docutils literal notranslate"><span class="pre">Lambda</span></code> (rate).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">binomial(Var,N,P)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows a binomial distribution with parameters <code class="code docutils literal notranslate"><span class="pre">N</span></code> (number of trials) and <code class="code docutils literal notranslate"><span class="pre">P</span></code> (success probability).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">geometric(Var,P)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows a geometric distribution with parameter <code class="code docutils literal notranslate"><span class="pre">P</span></code> (success probability).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">exponential(Var,Lambda)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows an exponential distribution with parameter <code class="code docutils literal notranslate"><span class="pre">Lambda</span></code> (rate, or inverse scale).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">negative_binomial(Var,R,P)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> follows a negative binomial distribution with parameters <code class="code docutils literal notranslate"><span class="pre">R</span></code> (number of successes) and <code class="code docutils literal notranslate"><span class="pre">P</span></code> (success probability).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">multinomial(Var,N,P)</span></code> <code class="code docutils literal notranslate"><span class="pre">Var</span></code> (vector/list of event numbers) follows a multinomial distribution with parameters <code class="code docutils literal notranslate"><span class="pre">N</span></code> (number of trials) and <code class="code docutils literal notranslate"><span class="pre">P</span></code> (vector/list of event probabilities).</p></li>
</ul>
<p>For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">g</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="o">:</span> <span class="nb">gaussian</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>states that argument <code class="code docutils literal notranslate"><span class="pre">X</span></code> of <code class="code docutils literal notranslate"><span class="pre">g(X)</span></code> follows a Gaussian distribution with mean 0 and variance 1, while</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">g</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="o">:</span> <span class="nb">gaussian</span><span class="p">(</span><span class="nv">X</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]).</span>
</pre></div>
</div>
<p>states that argument <code class="code docutils literal notranslate"><span class="pre">X</span></code> of <code class="code docutils literal notranslate"><span class="pre">g(X)</span></code> follows a Gaussian multivariate distribution with mean vector <code class="code docutils literal notranslate"><span class="pre">[0,0]</span></code> and covariance matrix <span class="math notranslate nohighlight">\(\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}\)</span></p>
<p>For example, <a class="reference external" href="http://cplint.eu/e/gaussian_mixture.pl">gaussian_mixture.pl</a> defines a mixture of two Gaussians:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">heads</span><span class="p">:</span><span class="mf">0.6</span><span class="p">;</span><span class="s s-Atom">tails</span><span class="p">:</span><span class="mf">0.4</span><span class="p">.</span>
<span class="nf">g</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="o">:</span> <span class="nb">gaussian</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span>
<span class="nf">h</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="o">:</span> <span class="nb">gaussian</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span>
<span class="nf">mix</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">:-</span> <span class="s s-Atom">heads</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">mix</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">:-</span> <span class="s s-Atom">tails</span><span class="p">,</span> <span class="nf">h</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>The argument <code class="code docutils literal notranslate"><span class="pre">X</span></code> of <code class="code docutils literal notranslate"><span class="pre">mix(X)</span></code> follows a distribution that is a mixture of two Gaussian, one with mean 0 and variance 1 with probability 0.6 and one with mean 5 and variance 2 with probability 0.4.
The parameters of the distribution atoms can be taken from the probabilistic atom, the example (<a class="reference external" href="http://cplint.eu/e/gauss_mean_est.pl">gauss_mean_est.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">val</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="nv">X</span><span class="p">)</span> <span class="o">:-</span>
    <span class="nf">mean</span><span class="p">(</span><span class="nv">M</span><span class="p">),</span>
    <span class="nf">val</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">X</span><span class="p">).</span>
<span class="nf">mean</span><span class="p">(</span><span class="nv">M</span><span class="p">)</span><span class="o">:</span> <span class="nb">gaussian</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">).</span>
<span class="nf">val</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">X</span><span class="p">)</span><span class="o">:</span> <span class="nb">gaussian</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">).</span>
</pre></div>
</div>
<p>states that for an index <code class="code docutils literal notranslate"><span class="pre">I</span></code> the continuous variable <code class="code docutils literal notranslate"><span class="pre">X</span></code> is sampled from a Gaussian whose variance is 2 and whose mean is sampled from a Gaussian with mean 1 and variance 5.
Any operation is allowed on continuous random variables.
The example below (<a class="reference external" href="http://cplint.eu/e/kalman_filter.pl">kalman_filter.pl</a>) encodes a Kalman filter:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">kf</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span> <span class="o">:-</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">S</span><span class="p">),</span>
    <span class="nf">kf_part</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">S</span><span class="p">,</span><span class="nv">O</span><span class="p">,</span><span class="nv">T</span><span class="p">).</span>

<span class="nf">kf_part</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">S</span><span class="p">,[</span><span class="nv">V</span><span class="p">|</span><span class="nv">RO</span><span class="p">],</span> <span class="nv">T</span><span class="p">)</span> <span class="o">:-</span>
    <span class="nv">I</span> <span class="o">&lt;</span> <span class="nv">N</span><span class="p">,</span>
    <span class="nv">NextI</span> <span class="o">is</span> <span class="nv">I</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="nf">trans</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">I</span><span class="p">,</span><span class="nv">NextS</span><span class="p">),</span>
    <span class="nf">emit</span><span class="p">(</span><span class="nv">NextS</span><span class="p">,</span><span class="nv">I</span><span class="p">,</span><span class="nv">V</span><span class="p">),</span>
    <span class="nf">kf_part</span><span class="p">(</span><span class="nv">NextI</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">NextS</span><span class="p">,</span><span class="nv">RO</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
<span class="nf">kf_part</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">S</span><span class="p">,</span> <span class="p">[],</span><span class="nv">S</span><span class="p">).</span>

<span class="nf">trans</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="nv">I</span><span class="p">,</span><span class="nv">NextS</span><span class="p">)</span> <span class="o">:-</span>
    <span class="p">{</span><span class="nv">NextS</span> <span class="o">=:=</span> <span class="nv">E</span> <span class="o">+</span> <span class="nv">S</span><span class="p">},</span>
    <span class="nf">trans_err</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>

<span class="nf">emit</span><span class="p">(</span><span class="nv">NextS</span><span class="p">,</span><span class="nv">I</span><span class="p">,</span><span class="nv">V</span><span class="p">)</span> <span class="o">:-</span>
    <span class="p">{</span><span class="nv">NextS</span> <span class="o">=:=</span> <span class="nv">V</span><span class="o">+</span><span class="nv">X</span><span class="p">},</span>
    <span class="nf">obs_err</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="nv">X</span><span class="p">).</span>

<span class="nf">init</span><span class="p">(</span><span class="nv">S</span><span class="p">)</span><span class="o">:</span><span class="nb">gaussian</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">trans_err</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nv">E</span><span class="p">)</span><span class="o">:</span><span class="nb">gaussian</span><span class="p">(</span><span class="nv">E</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">).</span>
<span class="nf">obs_err</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nv">E</span><span class="p">)</span><span class="o">:</span><span class="nb">gaussian</span><span class="p">(</span><span class="nv">E</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>Continuous random variables are involved in arithmetic expressions (in <code class="code docutils literal notranslate"><span class="pre">trans/3</span></code> and <code class="code docutils literal notranslate"><span class="pre">emit/3</span></code>).
It is often convenient, as in this case, to use CLP(R) constraints (by including the directive <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">use_module(library(clpr)).</span></code>) as in this way the expressions can be used in multiple directions and the same clauses can be used both to sample and to evaluate the weight of the sample on the basis of evidence, otherwise different clauses have to be written.
In case random variables are not sufficiently instantiated to exploit expressions for inferring the values of other variables, inference will return an error.</p>
<p>Moreover, user defined distributions are allowed with the syntax:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">A</span><span class="o">:</span><span class="nb">user</span><span class="p">(</span><span class="nv">Var</span><span class="p">,</span><span class="nv">Density</span><span class="p">)</span><span class="o">:-</span><span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Var</span></code> appears in <code class="code docutils literal notranslate"><span class="pre">A</span></code> and will contain the sampled value and <code class="code docutils literal notranslate"><span class="pre">Density</span></code> is an atom of the form <code class="code docutils literal notranslate"><span class="pre">predicate(Parameters)</span></code>.
If <code class="code docutils literal notranslate"><span class="pre">predicate</span></code> in <code class="code docutils literal notranslate"><span class="pre">predicate(Parameters)</span></code> has arity <code class="code docutils literal notranslate"><span class="pre">n</span></code>, then the user has to define predicate <code class="code docutils literal notranslate"><span class="pre">predicate/n+1</span></code> such that</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">predicate</span><span class="p">(</span><span class="nv">Parameters</span><span class="p">,</span><span class="nv">Var</span><span class="p">)</span>
</pre></div>
</div>
<p>called with <code class="code docutils literal notranslate"><span class="pre">Parameters</span></code> instantiated, returns in <code class="code docutils literal notranslate"><span class="pre">Var</span></code> a value sampled from the user defined density.
The definition of <code class="code docutils literal notranslate"><span class="pre">predicate/n+1</span></code> should appear after <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">end_lpad.</span></code></p>
<p>If likelihood weighting or particle filtering will be used for inference, then the user has to define also predicate <code class="code docutils literal notranslate"><span class="pre">predicate/n+2</span></code> such that <code class="code docutils literal notranslate"><span class="pre">predicate(Parameters,Var,Dens)</span></code>, when called with <code class="code docutils literal notranslate"><span class="pre">Parameters</span></code> and <code class="code docutils literal notranslate"><span class="pre">Var</span></code> instantiated, returns in <code class="code docutils literal notranslate"><span class="pre">Dens</span></code> the value of the probability density of <code class="code docutils literal notranslate"><span class="pre">Var</span></code>. The definition of <code class="code docutils literal notranslate"><span class="pre">predicate/n+2</span></code> should appear after <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">end_lpad.</span></code></p>
<p>Moreover, if the density is discrete, the program must include the fact</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">disc</span><span class="p">(</span><span class="s s-Atom">predicate</span><span class="p">).</span>
</pre></div>
</div>
<p>also after <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">end_lpad.</span></code>
See for example <a class="reference external" href="http://cplint.eu/e/gauss_mean_est_user.pl">gauss_mean_est_user.pl</a></p>
<section id="distributional-clauses-syntax">
<h4>Distributional Clauses Syntax<a class="headerlink" href="#distributional-clauses-syntax" title="Permalink to this headline">¶</a></h4>
<p>You can also use the syntax of Distributional Clauses (DC) <span id="id8">[<a class="reference internal" href="#id51" title="Davide Nitti, Tinne De Laet, and Luc De Raedt. Probabilistic logic programming for hybrid relational domains. Mach. Learn., 103(3):407–449, 2016. URL: http://dx.doi.org/10.1007/s10994-016-5558-8, doi:10.1007/s10994-016-5558-8.">NDLDR16</a>]</span>.
Continuous random variables are represented in this case by term whose distribution can be specified with density atoms as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">T</span><span class="o">~</span><span class="nv">Density</span> <span class="o">:=</span> <span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>Here <code class="code docutils literal notranslate"><span class="pre">:=</span></code> replaces the implication symbol, <code class="code docutils literal notranslate"><span class="pre">T</span></code> is a term and <code class="code docutils literal notranslate"><span class="pre">Density</span></code> is one of the density atoms above without the <code class="code docutils literal notranslate"><span class="pre">Var</span></code> argument, because <code class="code docutils literal notranslate"><span class="pre">T</span></code> itself represents a random variables.
In the body of clauses you can use the infix operator <code class="code docutils literal notranslate"><span class="pre">~=</span></code> to equate a term representing a random variable with a logical variable or a constant as in <code class="code docutils literal notranslate"><span class="pre">T</span> <span class="pre">~=</span> <span class="pre">X</span></code>.
Internally <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> transforms the terms representing random variables into atoms with an extra argument for holding the variable.</p>
<p>DC can be used to represent also discrete distributions using</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">T</span><span class="o">~</span><span class="nb">uniform</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">:=</span> <span class="nv">Body</span><span class="p">.</span>
<span class="nv">T</span><span class="o">~</span><span class="nb">finite</span><span class="p">(</span><span class="nv">D</span><span class="p">)</span> <span class="o">:=</span> <span class="nv">Body</span><span class="p">.</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">L</span></code> is a list of values and <code class="code docutils literal notranslate"><span class="pre">D</span></code> is a list of pairs <code class="code docutils literal notranslate"><span class="pre">P:V</span></code> with <code class="code docutils literal notranslate"><span class="pre">P</span></code> a probability and <code class="code docutils literal notranslate"><span class="pre">V</span></code> a value.
If <code class="code docutils literal notranslate"><span class="pre">Body</span></code> is empty, as in regular Prolog, the implication symbol <code class="code docutils literal notranslate"><span class="pre">:=</span></code> can be omitted.</p>
<p>The Indian GPA problem from <a class="reference external" href="http://www.robots.ox.ac.uk/~fwood/anglican/examples/viewer/?worksheet=indian-gpa">http://www.robots.ox.ac.uk/~fwood/anglican/examples/viewer/?worksheet=indian-gpa</a> in distributional clauses syntax
(<a class="reference external" href="https://github.com/davidenitti/DC/blob/master/examples/indian-gpa.pl">https://github.com/davidenitti/DC/blob/master/examples/indian-gpa.pl</a>) takes the form (<a class="reference external" href="http://cplint.eu/e/indian_gpadc.pl">indian_gpadc.pl</a>):</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">coin</span> <span class="o">~</span> <span class="nb">finite</span><span class="p">([</span><span class="mf">0.95</span><span class="o">:</span><span class="s s-Atom">true</span><span class="p">,</span><span class="mf">0.05</span><span class="o">:</span><span class="s s-Atom">false</span><span class="p">]).</span>
<span class="s s-Atom">agpa</span> <span class="o">~</span> <span class="nb">beta</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">:=</span> <span class="s s-Atom">coin</span><span class="o">~=</span><span class="s s-Atom">true</span><span class="p">.</span>
<span class="s s-Atom">american_gpa</span> <span class="o">~</span> <span class="nb">finite</span><span class="p">([</span><span class="mf">0.85</span><span class="o">:</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">0.15</span><span class="o">:</span><span class="mf">0.0</span><span class="p">])</span> <span class="o">:=</span> <span class="s s-Atom">coin</span><span class="o">~=</span><span class="s s-Atom">false</span><span class="p">.</span>

<span class="s s-Atom">american_gpa</span> <span class="o">~</span> <span class="nf">val</span><span class="p">(</span><span class="nv">V</span><span class="p">)</span> <span class="o">:=</span> <span class="s s-Atom">agpa</span> <span class="o">~=</span><span class="nv">A</span><span class="p">,</span> <span class="nv">V</span> <span class="o">is</span> <span class="nv">A</span><span class="o">*</span><span class="mf">4.0</span><span class="p">.</span>

<span class="s s-Atom">coin2</span> <span class="o">~</span> <span class="nb">finite</span><span class="p">([</span><span class="mf">0.99</span><span class="o">:</span><span class="s s-Atom">true</span><span class="p">,</span><span class="mf">0.01</span><span class="o">:</span><span class="s s-Atom">false</span><span class="p">]).</span>
<span class="s s-Atom">igpa</span> <span class="o">~</span> <span class="nb">beta</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">:=</span> <span class="s s-Atom">coin2</span><span class="o">~=</span><span class="s s-Atom">true</span><span class="p">.</span>
<span class="s s-Atom">indian_gpa</span> <span class="o">~</span> <span class="nb">finite</span><span class="p">([</span><span class="mf">0.1</span><span class="o">:</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.9</span><span class="o">:</span><span class="mf">10.0</span><span class="p">])</span> <span class="o">:=</span> <span class="s s-Atom">coin2</span><span class="o">~=</span><span class="s s-Atom">false</span><span class="p">.</span>

<span class="s s-Atom">indian_gpa</span> <span class="o">~</span> <span class="nf">val</span><span class="p">(</span><span class="nv">V</span><span class="p">)</span> <span class="o">:=</span> <span class="s s-Atom">igpa</span> <span class="o">~=</span><span class="nv">A</span><span class="p">,</span> <span class="nv">V</span> <span class="o">is</span> <span class="nv">A</span><span class="o">*</span><span class="mf">10.0</span><span class="p">.</span>

<span class="s s-Atom">nation</span> <span class="o">~</span> <span class="nb">finite</span><span class="p">([</span><span class="mf">0.25</span><span class="o">:</span><span class="s s-Atom">a</span><span class="p">,</span><span class="mf">0.75</span><span class="o">:</span><span class="s s-Atom">i</span><span class="p">]).</span>

<span class="s s-Atom">student_gpa</span> <span class="o">~</span> <span class="nf">val</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="o">:=</span> <span class="s s-Atom">nation</span><span class="o">~=</span><span class="s s-Atom">a</span><span class="p">,</span><span class="s s-Atom">american_gpa</span><span class="o">~=</span><span class="nv">A</span><span class="p">.</span>
<span class="s s-Atom">student_gpa</span> <span class="o">~</span> <span class="nf">val</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">:=</span> <span class="s s-Atom">nation</span><span class="o">~=</span><span class="s s-Atom">i</span><span class="p">,</span><span class="s s-Atom">indian_gpa</span><span class="o">~=</span><span class="nv">I</span><span class="p">.</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="semantics">
<h2>Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h2>
<p>The semantics of LPADs for the case of programs without functions symbols can be given as follows.
An LPAD defines a probability distribution over normal logic programs called <em>worlds</em>.
A world is obtained from an LPAD by first grounding it, by selecting a single head atom for each ground clause and by including in the world the clause with the selected head atom and the body.
The probability of a world is the product of the probabilities associated to the heads selected.
The probability of a ground atom (the query) is given by the sum of the probabilities of the worlds where the query is true.</p>
<p>If the LPAD contains function symbols, the definition is more complex, see <span id="id9">[<a class="reference internal" href="#id52" title="David Poole. The independent choice logic for modelling multiple agents under uncertainty. Artificial Intelligence, 94(1-2):7-56, 1997.">Poo97</a>, <a class="reference internal" href="#id53" title="Taisuke Sato and Yoshitaka Kameya. Parameter learning of logic programs for symbolic-statistical modeling. J. Artif. Intell. Res., 15:391-454, 2001.">SK01</a>]</span>.
For the semantics of programs with continuous random variables, see <span id="id10">[<a class="reference internal" href="#id54" title="Muhammad Asiful Islam, CR Ramakrishnan, and IV Ramakrishnan. Inference in probabilistic logic programs with continuous random variables. Theory and Practice of Logic Programming, 12:505–523, 7 2012. doi:10.1017/S1471068412000154.">IRR12</a>]</span> that defines the probability space for <span class="math notranslate nohighlight">\(N\)</span> continuous random variables by considering the Borel <span class="math notranslate nohighlight">\(\sigma\)</span>-algebra over <span class="math notranslate nohighlight">\(\mathbb{R}^N\)</span> and defines a Lebesgue measure on this set as the probability measure.
The probability space is lifted to cover the entire program using the least model semantics of constraint logic programs.
Alternatively, <span id="id11">[<a class="reference internal" href="#id51" title="Davide Nitti, Tinne De Laet, and Luc De Raedt. Probabilistic logic programming for hybrid relational domains. Mach. Learn., 103(3):407–449, 2016. URL: http://dx.doi.org/10.1007/s10994-016-5558-8, doi:10.1007/s10994-016-5558-8.">NDLDR16</a>]</span> defines the semantics of distributional clauses by resorting to a stochastic <span class="math notranslate nohighlight">\(Tp\)</span> operator.</p>
<p><code class="code docutils literal notranslate"><span class="pre">cplint</span></code> allows more freedom than distributional clauses in the use of continuous random variables in expressions,
for example <a class="reference external" href="http://cplint.eu/e/kalman_filter.pl">kalman_filter.pl</a> would not be allowed by distributional clauses.</p>
</section>
<section id="inference">
<h2>Inference<a class="headerlink" href="#inference" title="Permalink to this headline">¶</a></h2>
<p><code class="code docutils literal notranslate"><span class="pre">cplint</span></code> answers queries using the module <code class="code docutils literal notranslate"><span class="pre">pita</span></code> or <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code>.
The first performs the program transformation technique of <span id="id13">[<a class="reference internal" href="#id55" title="Fabrizio Riguzzi and Terrance Swift. Tabling and Answer Subsumption for Reasoning on Logic Programs with Annotated Disjunctions. In Technical Communications of the International Conference on Logic Programming, volume 7 of Leibniz International Proceedings in Informatics (LIPIcs), 162–171. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2010. doi:10.4230/LIPIcs.ICLP.2010.162.">RS10</a>]</span>.
The latter performs approximate inference by sampling using a different program transformation technique and is described in <span id="id14">[<a class="reference internal" href="#id56" title="Fabrizio Riguzzi. MCINTYRE: a Monte Carlo system for probabilistic logic programming. Fundamenta Informaticae, 124(4):521-541, 2013. URL: http://ds.ing.unife.it/~friguzzi/Papers/Rig13-FI-IJ.pdf, doi:10.3233/FI-2013-847.">Rig13</a>]</span>.
Only <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> is able to handle continuous random variables.</p>
<p>For answering queries, you have to prepare a Prolog file where you first load the inference module (for example <code class="code docutils literal notranslate"><span class="pre">pita</span></code>), initialize it with a directive (for example <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">pita</span></code>) and then enclose the LPAD clauses in <code class="code docutils literal notranslate"><span class="pre">:-begin_lpad.</span></code> or <code class="code docutils literal notranslate"><span class="pre">:-begin_plp.</span></code> and <code class="code docutils literal notranslate"><span class="pre">:-end_lpad.</span></code> or <code class="code docutils literal notranslate"><span class="pre">:-end_plp.</span></code>
For example, the coin program above can be stored in <a class="reference external" href="http://cplint.eu/example/inference/coin.pl">coin.pl</a> for performing inference with <code class="code docutils literal notranslate"><span class="pre">pita</span></code> as follows</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">pita</span><span class="p">)).</span>
<span class="o">:-</span> <span class="s s-Atom">pita</span><span class="p">.</span>
<span class="o">:-</span> <span class="s s-Atom">begin_lpad</span><span class="p">.</span>
<span class="nf">heads</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="p">;</span> <span class="nf">tails</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">:-</span>
<span class="nf">toss</span><span class="p">(</span><span class="nv">Coin</span><span class="p">),</span><span class="s s-Atom">\+</span><span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">).</span>

<span class="nf">heads</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.6</span> <span class="p">;</span> <span class="nf">tails</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.4</span><span class="o">:-</span>
<span class="nf">toss</span><span class="p">(</span><span class="nv">Coin</span><span class="p">),</span><span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">).</span>

<span class="nf">fair</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.9</span> <span class="p">;</span> <span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.1</span><span class="p">.</span>

<span class="nf">toss</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">).</span>
<span class="o">:-</span> <span class="s s-Atom">end_lpad</span><span class="p">.</span>
</pre></div>
</div>
<p>The same program for <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">mcintyre</span><span class="p">)).</span>
<span class="o">:-</span> <span class="s s-Atom">mc</span><span class="p">.</span>
<span class="o">:-</span> <span class="s s-Atom">begin_lpad</span><span class="p">.</span>
<span class="nf">heads</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="p">;</span> <span class="nf">tails</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">:-</span>
<span class="nf">toss</span><span class="p">(</span><span class="nv">Coin</span><span class="p">),</span><span class="s s-Atom">\+</span><span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">).</span>

<span class="nf">heads</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.6</span> <span class="p">;</span> <span class="nf">tails</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.4</span><span class="o">:-</span>
<span class="nf">toss</span><span class="p">(</span><span class="nv">Coin</span><span class="p">),</span><span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">).</span>

<span class="nf">fair</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.9</span> <span class="p">;</span> <span class="nf">biased</span><span class="p">(</span><span class="nv">Coin</span><span class="p">)</span><span class="o">:</span><span class="mf">0.1</span><span class="p">.</span>

<span class="nf">toss</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">).</span>
<span class="o">:-</span> <span class="s s-Atom">end_lpad</span><span class="p">.</span>
</pre></div>
</div>
<p>You can have also (non-probabilistic) clauses outside <code class="code docutils literal notranslate"><span class="pre">:-begin/end_lpad.</span></code>
These are considered as database clauses.
In <code class="code docutils literal notranslate"><span class="pre">pita</span></code> subgoals in the body of probabilistic clauses can query them by enclosing the query in <code class="code docutils literal notranslate"><span class="pre">db/1</span></code>.
For example (<a class="reference external" href="http://cplint.eu/example/inference/testdb.pl">testdb.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">pita</span><span class="p">)).</span>
<span class="o">:-</span> <span class="s s-Atom">pita</span><span class="p">.</span>
<span class="o">:-</span> <span class="s s-Atom">begin_lpad</span><span class="p">.</span>
<span class="nf">sampled_male</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span><span class="o">:</span><span class="mf">0.5</span><span class="o">:-</span>
<span class="nf">db</span><span class="p">(</span><span class="nf">male</span><span class="p">(</span><span class="nv">X</span><span class="p">)).</span>
<span class="o">:-</span> <span class="s s-Atom">end_lpad</span><span class="p">.</span>
<span class="nf">male</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">).</span>
<span class="nf">male</span><span class="p">(</span><span class="s s-Atom">david</span><span class="p">).</span>
</pre></div>
</div>
<p>You can also use <code class="code docutils literal notranslate"><span class="pre">findall/3</span></code> on subgoals defined by database clauses (<a class="reference external" href="http://cplint.eu/example/inference/persons.pl">persons.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">pita</span><span class="p">)).</span>
<span class="o">:-</span> <span class="s s-Atom">pita</span><span class="p">.</span>
<span class="o">:-</span> <span class="s s-Atom">begin_lpad</span><span class="p">.</span>

<span class="s s-Atom">male</span><span class="p">:</span><span class="nv">M</span><span class="o">/</span><span class="nv">P</span><span class="p">;</span> <span class="s s-Atom">female</span><span class="p">:</span><span class="nv">F</span><span class="o">/</span><span class="nv">P</span><span class="o">:-</span>
<span class="nf">findall</span><span class="p">(</span><span class="nv">Male</span><span class="p">,</span><span class="nf">male</span><span class="p">(</span><span class="nv">Male</span><span class="p">),</span><span class="nv">LM</span><span class="p">),</span>
<span class="nf">findall</span><span class="p">(</span><span class="nv">Female</span><span class="p">,</span><span class="nf">female</span><span class="p">(</span><span class="nv">Female</span><span class="p">),</span><span class="nv">LF</span><span class="p">),</span>
<span class="nf">length</span><span class="p">(</span><span class="nv">LM</span><span class="p">,</span><span class="nv">M</span><span class="p">),</span>
<span class="nf">length</span><span class="p">(</span><span class="nv">LF</span><span class="p">,</span><span class="nv">F</span><span class="p">),</span>
<span class="nv">P</span> <span class="o">is</span> <span class="nv">F</span><span class="o">+</span><span class="nv">M</span><span class="p">.</span>

<span class="o">:-</span> <span class="s s-Atom">end_lpad</span><span class="p">.</span>

<span class="nf">male</span><span class="p">(</span><span class="s s-Atom">john</span><span class="p">).</span>
<span class="nf">male</span><span class="p">(</span><span class="s s-Atom">david</span><span class="p">).</span>
<span class="nf">female</span><span class="p">(</span><span class="s s-Atom">anna</span><span class="p">).</span>
<span class="nf">female</span><span class="p">(</span><span class="s s-Atom">elen</span><span class="p">).</span>
<span class="nf">female</span><span class="p">(</span><span class="s s-Atom">cathy</span><span class="p">).</span>
</pre></div>
</div>
<p>Aggregate predicates on probabilistic subgoals are not implemented due to their high computational cost (if the aggregation is over <span class="math notranslate nohighlight">\(n\)</span> atoms, the values of the aggregation are potentially <span class="math notranslate nohighlight">\(2^n\)</span>).
The Yap version of <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> includes reasoning algorithms that allows aggregate predicates on probabilistic subgoals, see <a class="reference external" href="http://ds.ing.unife.it/~friguzzi/software/cplint/manual.html">http://ds.ing.unife.it/~friguzzi/software/cplint/manual.html</a>.</p>
<p>In <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> you can query database clauses in the body of probabilistic clauses without any special syntax.
You can also use <code class="code docutils literal notranslate"><span class="pre">findall/3</span></code>.</p>
<p>To run a query, you can simply load the Prolog file, for example <a class="reference external" href="http://cplint.eu/e/coin.pl">coin.pl</a>, as:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="p">[</span><span class="s s-Atom">coin</span><span class="p">].</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>swipl coin.pl
</pre></div>
</div>
<section id="unconditional-queries">
<h3>Unconditional Queries<a class="headerlink" href="#unconditional-queries" title="Permalink to this headline">¶</a></h3>
<p>The unconditional probability of an atom can be asked using <code class="code docutils literal notranslate"><span class="pre">pita</span></code> with the predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">prob</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
</pre></div>
</div>
<p>as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">prob</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>If the query is non-ground, <code class="code docutils literal notranslate"><span class="pre">prob/2</span></code> returns in backtracking the successful instantiations together with their probability.
When using <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code>, the predicate for querying is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_prob</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_prob/3</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> BarChart is a dict for rendering with c3 as a bar chart with a bar for the number of successes and a bar for the number of failures.</p></li>
</ul>
<p>For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_prob</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">P</span><span class="p">,[]).</span>
</pre></div>
</div>
<p>You can also use</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_prob</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>which is equivalent to <code class="code docutils literal notranslate"><span class="pre">mc_prob/3</span></code> with an empty option list.
In general, all the predicates that admit a list of options as an argument have a corresponding version without the list of options that is equivalent to calling the first with an empty option list.</p>
<p>With <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code>, you can also take a given number of samples with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_sample</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span> <span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_sample/4</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">successes(-Successes:int)</span></code> Number of successes</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">failures(-Failures:int)</span></code> Number of failures</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> <code class="code docutils literal notranslate"><span class="pre">BarChart</span></code> is a dict for rendering with c3 as a bar chart with a bar for the number of successes and a bar for the number of failures.</p></li>
</ul>
<p>For example (<a class="reference external" href="http://cplint.eu/e/coinmc.pl">coinmc.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">P</span><span class="p">,[</span><span class="nf">successes</span><span class="p">(</span><span class="nv">S</span><span class="p">),</span><span class="nf">failures</span><span class="p">(</span><span class="nv">F</span><span class="p">)]).</span>
</pre></div>
</div>
<p>that samples <code class="code docutils literal notranslate"><span class="pre">heads(coin)</span></code> 1000 times and returns in <code class="code docutils literal notranslate"><span class="pre">S</span></code> the number of successes, in <code class="code docutils literal notranslate"><span class="pre">F</span></code> the number of failures and in <code class="code docutils literal notranslate"><span class="pre">P</span></code> the estimated probability (<code class="code docutils literal notranslate"><span class="pre">S/1000</span></code>).</p>
<p>As another example, the call</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">Prob</span><span class="p">).</span>
</pre></div>
</div>
<p>samples <code class="code docutils literal notranslate"><span class="pre">heads(coin)</span></code> 1000 times and returns the estimated probability that a sample is true.</p>
<p>You can also sample using Gibbs sampling with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_gibbs_sample</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_gibbs_sample/4</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">block(+Block:int)</span></code> Perform blocked Gibbs: <code class="code docutils literal notranslate"><span class="pre">Block</span></code> variables are sampled together, default value 1</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mix(+Mix:int)</span></code> The first <code class="code docutils literal notranslate"><span class="pre">Mix</span></code> samples are discarded (mixing time), default value 0</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">successes(-Successes:int)</span></code> Number of successes</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">failures(-Failures:int)</span></code> Number of failures</p></li>
</ul>
<p><code class="code docutils literal notranslate"><span class="pre">mc_gibbs_sample/3</span></code> is equivalent to <code class="code docutils literal notranslate"><span class="pre">mc_gibbs_sample/4</span></code> with an empty option list.</p>
<p>Moreover, you can sample arguments of queries with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>The predicate samples <code class="code docutils literal notranslate"><span class="pre">Query</span></code> a number of <code class="code docutils literal notranslate"><span class="pre">Samples</span></code> times. <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> should be a variable in <code class="code docutils literal notranslate"><span class="pre">Query</span></code>.
The predicate returns in <code class="code docutils literal notranslate"><span class="pre">Values</span></code> a list of pairs <code class="code docutils literal notranslate"><span class="pre">L-N</span></code> where <code class="code docutils literal notranslate"><span class="pre">L</span></code> is the list of values of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> for which <code class="code docutils literal notranslate"><span class="pre">Query</span></code> succeeds in a world sampled at random and <code class="code docutils literal notranslate"><span class="pre">N</span></code> is the number of samples returning that list of values. If <code class="code docutils literal notranslate"><span class="pre">L</span></code> is the empty list, it means that for that sample the query failed.
If <code class="code docutils literal notranslate"><span class="pre">L</span></code> is a list with a single element, it means that for that sample the query is determinate.
If, in all pairs <code class="code docutils literal notranslate"><span class="pre">L-N</span></code>, <code class="code docutils literal notranslate"><span class="pre">L</span></code> is a list with a single element, it means that the clauses in the program are mutually exclusive, i.e., that in every sample, only one clause for each subgoal has the body true.
This is one of the assumptions taken for programs of the PRISM system <span id="id16">[<a class="reference internal" href="#id53" title="Taisuke Sato and Yoshitaka Kameya. Parameter learning of logic programs for symbolic-statistical modeling. J. Artif. Intell. Res., 15:391-454, 2001.">SK01</a>]</span>.
For example <a class="reference external" href="http://cplint.eu/e/pcfglr.pl">pcfglr.pl</a> and <a class="reference external" href="http://cplint.eu/e/plcg.pl">plcg.pl</a> satisfy this constraint while <a class="reference external" href="http://cplint.eu/e/markov_chain.pl">markov_chain.pl</a> and <a class="reference external" href="http://cplint.eu/e/var_obj.pl">var_obj.pl</a> doesn’t.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg/5</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">successes(-Successes:int)</span></code> Number of successes</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">failures(-Failures:int)</span></code> Number of failures</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> <code class="code docutils literal notranslate"><span class="pre">BarChart</span></code> is a dict for rendering with c3 as a bar chart with with a bar for each possible value of <code class="code docutils literal notranslate"><span class="pre">L</span></code>, the list of values of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> for which the query succeeds in a world sampled at random. The size of the bar is the number of samples returning that list of values.</p></li>
</ul>
<p>An example of use of <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg/4</span></code> is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample_arg</span><span class="p">(</span><span class="nf">reach</span><span class="p">(</span><span class="s s-Atom">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nv">S</span><span class="p">),</span><span class="mi">50</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">Values</span><span class="p">).</span>
</pre></div>
</div>
<p>of <a class="reference external" href="http://cplint.eu/e/markov_chain.pl">markov_chain.pl</a> that takes 50 samples of <code class="code docutils literal notranslate"><span class="pre">L</span></code> in <code class="code docutils literal notranslate"><span class="pre">findall(S,(reach(s0,0,S),L)</span></code>.</p>
<p>You can sample arguments of queries also with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_sample_arg_raw</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>that samples <code class="code docutils literal notranslate"><span class="pre">Query</span></code> a number of <code class="code docutils literal notranslate"><span class="pre">Samples</span></code> times. The predicate returns in <code class="code docutils literal notranslate"><span class="pre">Values</span></code> a list of values of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> returned as the first answer by <code class="code docutils literal notranslate"><span class="pre">Query</span></code> in a world sampled at random.
The value is <code class="code docutils literal notranslate"><span class="pre">failure</span></code> if the query fails.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_sample_arg_first</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>samples <code class="code docutils literal notranslate"><span class="pre">Query</span></code> a number of <code class="code docutils literal notranslate"><span class="pre">Samples</span></code> times and returns in <code class="code docutils literal notranslate"><span class="pre">Values</span></code> a list of pairs <code class="code docutils literal notranslate"><span class="pre">V-N</span></code> where <code class="code docutils literal notranslate"><span class="pre">V</span></code> is the value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> returned as the first answer by <code class="code docutils literal notranslate"><span class="pre">Query</span></code> in a world sampled at random and <code class="code docutils literal notranslate"><span class="pre">N</span></code> is the number of samples returning that value. <code class="code docutils literal notranslate"><span class="pre">V</span></code> is failure if the query fails. <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg_first/5</span></code> differs from <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg/5</span></code> because the first just computes the first answer of the query for each sampled world.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg_first/5</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> <code class="code docutils literal notranslate"><span class="pre">BarChart</span></code> has a bar for each value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> returned as a first answer for the query in a world sampled at random. The size of the bar is the number of samples that returned that value.</p></li>
</ul>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_sample_arg_one</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>samples <code class="code docutils literal notranslate"><span class="pre">Query</span></code> a number of <code class="code docutils literal notranslate"><span class="pre">Samples</span></code> times and returns in <code class="code docutils literal notranslate"><span class="pre">Values</span></code> a list of pairs <code class="code docutils literal notranslate"><span class="pre">V-N</span></code> where <code class="code docutils literal notranslate"><span class="pre">V</span></code> is a value sampled with uniform probability from those returned by <code class="code docutils literal notranslate"><span class="pre">Query</span></code> in a world sampled at random and <code class="code docutils literal notranslate"><span class="pre">N</span></code> is the number of samples returning that value.
<code class="code docutils literal notranslate"><span class="pre">V</span></code> is failure if the query fails.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg_one/5</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> <code class="code docutils literal notranslate"><span class="pre">BarChart</span></code> has a bar for each value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> returned by sampling with uniform probability one answer from those returned by the query in a world sampled at random. The size of the bar is the number of samples.</p></li>
</ul>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_gibbs_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>samples an argument of the query using Gibbs sampling.
The same options as those of <code class="code docutils literal notranslate"><span class="pre">mc_gibbs_sample/4</span></code> are recognized.</p>
<p>Finally, you can compute expectations with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_expectation</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>that computes the expected value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> in <code class="code docutils literal notranslate"><span class="pre">Query</span></code> by sampling.
It takes <code class="code docutils literal notranslate"><span class="pre">N</span></code> samples of <code class="code docutils literal notranslate"><span class="pre">Query</span></code> and sums up the value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> for each sample.
The overall sum is divided by <code class="code docutils literal notranslate"><span class="pre">N</span></code> to give <code class="code docutils literal notranslate"><span class="pre">Exp</span></code>.</p>
<p>An example of use of the above predicate is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_expectation</span><span class="p">(</span><span class="nf">eventually</span><span class="p">(</span><span class="s s-Atom">elect</span><span class="p">,</span><span class="nv">T</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">T</span><span class="p">,</span><span class="nv">E</span><span class="p">).</span>
</pre></div>
</div>
<p>of <a class="reference external" href="http://cplint.eu/e/pctl_slep.pl">pctl_slep.pl</a> that returns in <code class="code docutils literal notranslate"><span class="pre">E</span></code> the expected value
of <code class="code docutils literal notranslate"><span class="pre">T</span></code> by taking 1000 samples.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_gibbs_expectation</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>computes an expectation with Gibbs sampling.</p>
<section id="drawing-bdds">
<h4>Drawing BDDs<a class="headerlink" href="#drawing-bdds" title="Permalink to this headline">¶</a></h4>
<p>With <code class="code docutils literal notranslate"><span class="pre">pita</span></code>, you can obtain the BDD for a query with the predicates</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">bdd_dot_file</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">atom</span><span class="p">,</span><span class="o">+</span><span class="nv">FileName</span><span class="o">:</span><span class="s s-Atom">string</span><span class="p">,</span><span class="o">-</span><span class="nv">Var</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
<span class="nf">bdd_dot_string</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">atom</span><span class="p">,</span><span class="o">-</span><span class="nv">DotString</span><span class="o">:</span><span class="s s-Atom">string</span><span class="p">,</span><span class="o">-</span><span class="nv">Var</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
</pre></div>
</div>
<p>The first write the BDD to a file, the latter returns it as a string.
The BDD is represented in the dot format of graphviz.
Solid edges indicate 1-children, dashed edges indicate 0-children and dotted edges indicate 0-children
with negation applied to the sub BDD.
Each level of the BDD is associated to a variable of the form XI_J indicated on the left: I indicates the multivalued variable index and J the index of the Boolean variable of rule I.
The hexadecimal number in each node is part of its address in memory and is not significant.
The table <code class="code docutils literal notranslate"><span class="pre">Var</span></code> contains the associations between the rule groundings and the multivalued variables: the first column contains contains the multivalued variable index, the second column contains the rule index, corresponding to its position in the program, and the last column contains the list of constants grounding the rule, each replacing a variable in the order of appearance in the rule.</p>
<p>The BDD can be drawn in <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH by using the <code class="code docutils literal notranslate"><span class="pre">graphviz</span></code> renderer by including</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_rendering</span><span class="p">(</span><span class="s s-Atom">graphviz</span><span class="p">).</span>
</pre></div>
</div>
<p>before <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">pita.</span></code></p>
<p>For example (<a class="reference external" href="http://cplint.eu/e/coin.pl">coin.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">bdd_dot_string</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">BDD</span><span class="p">,</span><span class="nv">Var</span><span class="p">).</span>
</pre></div>
</div>
<p>returns the BDD for the query <code class="code docutils literal notranslate"><span class="pre">heads(coin)</span></code> and the list of associations between rule groundings
and multivalued variables.</p>
</section>
</section>
<section id="conditional-queries-on-discrete-variables">
<h3>Conditional Queries on Discrete Variables<a class="headerlink" href="#conditional-queries-on-discrete-variables" title="Permalink to this headline">¶</a></h3>
<p>The conditional probability of an atom query given another atom evidence can be asked using <code class="code docutils literal notranslate"><span class="pre">pita</span></code>
with the predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">prob</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
</pre></div>
</div>
<p>as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">prob</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nf">biased</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>If the query/evidence are non-ground, <code class="code docutils literal notranslate"><span class="pre">prob/3</span></code> returns in backtracking ground
instantiations together with their probability.
The query and the evidence can be conjunctions of literals (positive or negative).</p>
<p>You also have</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">prob</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">prob/4</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> <code class="code docutils literal notranslate"><span class="pre">BarChart</span></code> is a dict for rendering with c3 as a bar chart with a bar for the number of successes and a bar for the number of failures.</p></li>
</ul>
<p>as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">prob</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nf">biased</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">P</span><span class="p">,[</span><span class="nf">bar</span><span class="p">(</span><span class="nv">Chart</span><span class="p">)}).</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">prob/3</span></code> is equivalent to <code class="code docutils literal notranslate"><span class="pre">prob/4</span></code> with an empty option list.
When using <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code>, you can ask conditional queries with rejection sampling,
Metropolis-Hastings Markov Chain Monte Carlo or Gibbs sampling.
In rejection sampling <span id="id18">[<a class="reference internal" href="#id57" title="John Von Neumann. Various techniques used in connection with random digits. Nat. Bureau Stand. Appl. Math. Ser., 12:36-38, 1951.">VN51</a>]</span>, you first query the evidence and, if the query is successful, query the goal in the same sample, otherwise the sample is discarded.
In Metropolis-Hastings MCMC, <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> follows the algorithm proposed in <span id="id19">[<a class="reference internal" href="#id58" title="Arun Nampally and CR Ramakrishnan. Adaptive mcmc-based inference in probabilistic logic programs. arXiv preprint arXiv:1403.6036, 2014. URL: http://arxiv.org/pdf/1403.6036.pdf.">NR14</a>]</span> (the non adaptive version).
A Markov chain is built by building an initial sample and by generating successor samples.</p>
<p>The initial sample is built by randomly sampling choices so that the evidence is true.
This is done with a backtracking meta-interpreter that starts with the goal and randomizes the order in which clauses are selected during the search so that the initial sample is unbiased.
Each time the meta-interpreter encounters a probabilistic choice, it first checks whether a value has already been sampled, if not, it takes a sample and records it.
If a failure is obtained, the meta-interpreter backtracks to other clauses but without deleting samples. Then the goal is queries using regular MCINTYRE.</p>
<p>A successor sample is obtained by deleting a fixed number (parameter <code class="code docutils literal notranslate"><span class="pre">Lag</span></code>) of sampled probabilistic choices.
Then the evidence is queried using regular MCINTYRE starting with the undeleted choices.
If the query succeeds, the goal is queried using regular MCINTYRE.
The sample is accepted with a probability of <span class="math notranslate nohighlight">\(\min\{1,\frac{N_0}{N_1}\)</span> where <span class="math notranslate nohighlight">\(N_0\)</span> is the number of choices sampled in the previous sample and <span class="math notranslate nohighlight">\(N_1\)</span> is the number of choices sampled in the current sample.
In <span id="id20">[<a class="reference internal" href="#id58" title="Arun Nampally and CR Ramakrishnan. Adaptive mcmc-based inference in probabilistic logic programs. arXiv preprint arXiv:1403.6036, 2014. URL: http://arxiv.org/pdf/1403.6036.pdf.">NR14</a>]</span> the lag is always 1 but the proof in <span id="id21">[<a class="reference internal" href="#id58" title="Arun Nampally and CR Ramakrishnan. Adaptive mcmc-based inference in probabilistic logic programs. arXiv preprint arXiv:1403.6036, 2014. URL: http://arxiv.org/pdf/1403.6036.pdf.">NR14</a>]</span> that the above acceptance probability yields a valid Metropolis-Hastings algorithm holds also when forgetting more than one sampled choice, so the lag is user defined in <code class="code docutils literal notranslate"><span class="pre">cplint</span></code>.</p>
<p>Then the number of successes of the query is increased by 1 if the query succeeded in the last accepted sample.
The final probability is given by the number of successes over the total number of samples.</p>
<p>You can take a given number of sample with rejection sampling using</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_rejection_sample</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg/5</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">successes(-Successes:int)</span></code> Number of successes</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">failures(-Failures:int)</span></code> Number of failures</p></li>
</ul>
<p>as in (<a class="reference external" href="http://cplint.eu/e/coinmc.pl">coinmc.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_rejection_sample</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nf">biased</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">P</span><span class="p">,[</span><span class="nf">successes</span><span class="p">(</span><span class="nv">S</span><span class="p">),</span><span class="nf">failures</span><span class="p">(</span><span class="nv">F</span><span class="p">)]).</span>
</pre></div>
</div>
<p>that takes 1000 samples where <code class="code docutils literal notranslate"><span class="pre">biased(coin)</span></code> is true and returns in <code class="code docutils literal notranslate"><span class="pre">S</span></code> the number of samples where <code class="code docutils literal notranslate"><span class="pre">heads(coin)</span></code> is true, in <code class="code docutils literal notranslate"><span class="pre">F</span></code> the number of samples where <code class="code docutils literal notranslate"><span class="pre">heads(coin)</span></code> is false and in <code class="code docutils literal notranslate"><span class="pre">P</span></code> the estimated probability (<code class="code docutils literal notranslate"><span class="pre">S/1000</span></code>).</p>
<p>The query and the evidence can be conjunctions of literals.</p>
<p>You can take a given number of sample with Metropolis-Hastings MCMC using</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_mh_sample</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Lag</span></code> (that is set with the options, default value 1) is the number of sampled choices to forget before taking a new sample.</p>
<p><code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_mh_sample/5</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">mix(+Mix:int)</span></code> The first Mix samples are discarded (mixing time), default value 0</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">lag(+Lag:int)</span></code> lag between each sample, Lag sampled choices are forgotten, default value 1</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">successes(-Successes:int)</span></code> Number of successes</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">failures(-Failures:int)</span></code> Number of failures</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> BarChart is a dict for rendering with c3 as a bar chart with a bar for the number of successes and a bar for the number of failures.</p></li>
</ul>
<p>With <code class="code docutils literal notranslate"><span class="pre">Mix</span></code> specified it takes <code class="code docutils literal notranslate"><span class="pre">Mix+Samples</span></code> samples and discards the first <code class="code docutils literal notranslate"><span class="pre">Mix</span></code>.
For example (<a class="reference external" href="http://cplint.eu/e/arithm.pl">arithm.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_mh_sample</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="nf">eval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="mi">10000</span><span class="p">,</span><span class="nv">P</span><span class="p">,[</span><span class="nf">successes</span><span class="p">(</span><span class="nv">T</span><span class="p">),</span> <span class="nf">failures</span><span class="p">(</span><span class="nv">F</span><span class="p">)]).</span>
</pre></div>
</div>
<p>takes 10000 accepted samples and returns in <code class="code docutils literal notranslate"><span class="pre">T</span></code> the number of samples where <code class="code docutils literal notranslate"><span class="pre">eval(2,4)</span></code> is true,
in <code class="code docutils literal notranslate"><span class="pre">F</span></code> the number of samples where <code class="code docutils literal notranslate"><span class="pre">eval(2,4)</span></code> is false and in <code class="code docutils literal notranslate"><span class="pre">P</span></code> the estimated probability (<code class="code docutils literal notranslate"><span class="pre">T/10000</span></code>).</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_gibbs_sample</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>performs Gibbs sampling. <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised by <code class="code docutils literal notranslate"><span class="pre">mc_gibbs_sample/5</span></code>:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">block(+Block:int)</span></code> Perform blocked Gibbs: <code class="code docutils literal notranslate"><span class="pre">Block</span></code> variables are sampled together, default value 1</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mix(+Mix:int)</span></code> The first <code class="code docutils literal notranslate"><span class="pre">Mix</span></code> samples are discarded (mixing time), default value 0</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">successes(-Successes:int)</span></code> Number of successes</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">failures(-Failures:int)</span></code> Number of failures</p></li>
</ul>
<p>Moreover, you can sample arguments of queries with rejection sampling, Metropolis-Hastings MCMC or Gibbs sampling using</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_rejection_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
<span class="nf">mc_mh_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
<span class="nf">mc_gibbs_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>that return the distribution of values for <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> in <code class="code docutils literal notranslate"><span class="pre">Query</span></code> in <code class="code docutils literal notranslate"><span class="pre">Samples</span></code> of <code class="code docutils literal notranslate"><span class="pre">Query</span></code> given that <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is true. <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">mix(+Mix:int)</span></code> The first <code class="code docutils literal notranslate"><span class="pre">Mix</span></code> samples are discarded (mixing time), default value 0 (only MH and GIbbs)</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">lag(+Lag:int)</span></code> lag between each sample, <code class="code docutils literal notranslate"><span class="pre">Lag</span></code> sampled choices are forgotten, default value 1 (only MH)</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">block(+Block:int)</span></code> Perform blocked Gibbs: <code class="code docutils literal notranslate"><span class="pre">Block</span></code> variables are sampled together, default value 1 (only Gibbs)</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">bar(-BarChar:dict)</span></code> <code class="code docutils literal notranslate"><span class="pre">BarChart</span></code> is a bar chart of the possible values</p></li>
</ul>
<p>The predicates return in <code class="code docutils literal notranslate"><span class="pre">Values</span></code> a list of pairs <code class="code docutils literal notranslate"><span class="pre">L-N</span></code> where <code class="code docutils literal notranslate"><span class="pre">L</span></code> is the list of values of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> for which <code class="code docutils literal notranslate"><span class="pre">Query</span></code> succeeds in a world sampled at random where <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is true and <code class="code docutils literal notranslate"><span class="pre">N</span></code> is the number of samples returning that list of values.</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_gibbs_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>An example of use of the above predicates is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_mh_sample_arg</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nv">Y</span><span class="p">),</span><span class="nf">eval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">V</span><span class="p">,[]).</span>
</pre></div>
</div>
<p>of (<a class="reference external" href="http://cplint.eu/e/arithm.pl">arithm.pl</a>).</p>
<p>To compute conditional expectations, use</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_rejection_expectation</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
<span class="nf">mc_mh_expectation</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
<span class="nf">mc_gibbs_expectation</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the same as those of the predicates for conditional argument sampling are recognised. For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_mh_expectation</span><span class="p">(</span><span class="nf">eval</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nv">Y</span><span class="p">),</span><span class="nf">eval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">E</span><span class="p">,[]).</span>
</pre></div>
</div>
<p>of (<a class="reference external" href="http://cplint.eu/e/arithm.pl">arithm.pl</a>) computes the expectation of argument <code class="code docutils literal notranslate"><span class="pre">Y</span></code> of <code class="code docutils literal notranslate"><span class="pre">eval(2,Y)</span></code> given that <code class="code docutils literal notranslate"><span class="pre">eval(1,3)</span></code> is true by taking 1000 samples using Metropolis-Hastings MCMC.</p>
<p>Note that conditional inference is not allowed for PRISM programs with the setting <code class="code docutils literal notranslate"><span class="pre">prism_memoization</span></code> set to <code class="code docutils literal notranslate"><span class="pre">false</span></code>, as sampled values are not stored in that case and conditioning would have no effect.</p>
</section>
<section id="conditional-queries-on-continuous-variables">
<h3>Conditional Queries on Continuous Variables<a class="headerlink" href="#conditional-queries-on-continuous-variables" title="Permalink to this headline">¶</a></h3>
<p>When you have continuous random variables, you may be interested in sampling arguments of goals representing continuous random variables.
In this way you can build a probability density of the sampled argument.
When you do not have evidence or you have evidence on atoms not depending on continuous random variables, you can use the above predicates for sampling arguments.</p>
<p>For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample_arg</span><span class="p">(</span><span class="nf">val</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nv">X</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">L</span><span class="p">).</span>
</pre></div>
</div>
<p>from (<a class="reference external" href="http://cplint.eu/e/gauss_mean_est.pl">gauss_mean_est.pl</a>) samples 1000 values for <code class="code docutils literal notranslate"><span class="pre">X</span></code> in <code class="code docutils literal notranslate"><span class="pre">value(0,X)</span></code> and returns them in <code class="code docutils literal notranslate"><span class="pre">L</span></code>.</p>
<p>When you have evidence on ground atoms that have continuous values as arguments, you cannot use rejection sampling or Metropolis-Hastings, as the probability of the evidence is 0. For example, the probability of sampling a specific value from a Gaussian is 0.
Continuous variables have probability densities instead of distributions as discrete variables. In this case, you can use likelihood weighting or particle filtering <span id="id26">[<a class="reference internal" href="#id59" title="Robert M Fung and Kuo-Chu Chang. Weighing and integrating evidence for stochastic simulation in bayesian networks. In Fifth Annual Conference on Uncertainty in Artificial Intelligence, 209–220. North-Holland Publishing Co., 1990.">FC90</a>]</span>,:cite:<cite>koller2009probabilistic</cite>,:cite:<cite>Nitti2016</cite> to obtain samples of continuous arguments of a goal.</p>
<p>For each sample to be taken, likelihood weighting uses a meta-interpreter to find a sample where the goal is true, randomizing the choice of clauses when more than one resolves with the goal in order to obtain an unbiased sample.
This meta-interpreter is similar to the one used to generate the first sample in Metropolis-Hastings.
Then a different meta-interpreter is used to evaluate the weight of the sample.
This meta-interpreter starts with the evidence as the query and a weight of 1.
Each time the meta-interpreter encounters a probabilistic choice over a continuous variable, it first checks whether a value has already been sampled.
If so, it computes the probability density of the sampled value and multiplies the weight by it.
If the value has not been sampled, it takes a sample and records it, leaving the weight unchanged.
In this way, each sample in the result has a weight that is 1 for the prior distribution and that may be different from the posterior distribution, reflecting the influence of evidence.</p>
<p>In particle filtering, the evidence is a list of atoms. Each sample is weighted by the likelihood of an element of the evidence and constitutes a particle.
After weighting, particles are resampled and the next element of the evidence is considered.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_lw_sample</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Prob</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>samples <code class="code docutils literal notranslate"><span class="pre">Query</span></code> a number of <code class="code docutils literal notranslate"><span class="pre">Samples</span></code> times given that <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> (a conjunction of atoms is allowed here) is true.
The predicate returns in <code class="code docutils literal notranslate"><span class="pre">Prob</span></code> the probability that the query is true.
It performs likelihood weighting: each sample is weighted by the likelihood of evidence in the sample.</p>
<p>For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_lw_sample</span><span class="p">(</span><span class="nf">nation</span><span class="p">(</span><span class="s s-Atom">a</span><span class="p">),</span><span class="nf">student_gpa</span><span class="p">(</span><span class="mf">4.0</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>from <a class="reference external" href="http://cplint.eu/e/indian_gpa.pl">indian_gpa.pl</a> samples 1000 times the query <code class="code docutils literal notranslate"><span class="pre">nation(a)</span></code> given that <code class="code docutils literal notranslate"><span class="pre">student_gpa(4.0)</span></code> has been observed.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_lw_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">ValList</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>returns in <code class="code docutils literal notranslate"><span class="pre">ValList</span></code> a list of pairs <code class="code docutils literal notranslate"><span class="pre">V-W</span></code> where <code class="code docutils literal notranslate"><span class="pre">V</span></code> is a value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> for which <code class="code docutils literal notranslate"><span class="pre">Query</span></code> succeeds and <code class="code docutils literal notranslate"><span class="pre">W</span></code> is the weight computed by likelihood weighting according to <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> (a conjunction of atoms is allowed here).
For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_lw_sample_arg</span><span class="p">(</span><span class="nf">val</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nv">X</span><span class="p">),(</span><span class="nf">val</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span><span class="nf">val</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)),</span><span class="mi">100</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">L</span><span class="p">).</span>
</pre></div>
</div>
<p>from <a class="reference external" href="http://cplint.eu/e/gauss_mean_est.pl">gauss_mean_est.pl</a> samples 100 values for <code class="code docutils literal notranslate"><span class="pre">X</span></code> in <code class="code docutils literal notranslate"><span class="pre">val(0,X)</span></code> given that <code class="code docutils literal notranslate"><span class="pre">val(1,9)</span></code> and <code class="code docutils literal notranslate"><span class="pre">val(2,8)</span></code> have been observed.</p>
<p>You can compute conditional expectations using likelihood weighting with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_lw_expectation</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>that computes the expected value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> in <code class="code docutils literal notranslate"><span class="pre">Query</span></code> given that <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is true.
It takes <code class="code docutils literal notranslate"><span class="pre">N</span></code> samples of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> in <code class="code docutils literal notranslate"><span class="pre">Query</span></code>, weighting each according to the evidence, and returns their weighted average.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_particle_sample_arg</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">+</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>samples argument <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> of <code class="code docutils literal notranslate"><span class="pre">Query</span></code> using particle filtering given that <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is true. <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is a list of goals and <code class="code docutils literal notranslate"><span class="pre">Query</span></code> can be either a single goal or a list of goals.
When <code class="code docutils literal notranslate"><span class="pre">Query</span></code> is a single goal, the predicate returns in <code class="code docutils literal notranslate"><span class="pre">Values</span></code> a list of pairs <code class="code docutils literal notranslate"><span class="pre">V-W</span></code> where <code class="code docutils literal notranslate"><span class="pre">V</span></code> is a value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> for which <code class="code docutils literal notranslate"><span class="pre">Query</span></code> succeeds in a particle in the last set of particles and <code class="code docutils literal notranslate"><span class="pre">W</span></code> is the weight of the particle.
For each element of <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code>, the particles are obtained by sampling <code class="code docutils literal notranslate"><span class="pre">Query</span></code> in each current particle and weighting the particle by the likelihood of the evidence element.</p>
<p>When <code class="code docutils literal notranslate"><span class="pre">Query</span></code> is a list of goals, <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> is a list of variables, one for each query of <code class="code docutils literal notranslate"><span class="pre">Query</span></code> and <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> and <code class="code docutils literal notranslate"><span class="pre">Query</span></code> must have the same length of <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code>.
<code class="code docutils literal notranslate"><span class="pre">Values</span></code> is then list of the same length of <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> and each of its elements is a list of pairs <code class="code docutils literal notranslate"><span class="pre">V-W</span></code> where <code class="code docutils literal notranslate"><span class="pre">V</span></code> is a value of the corresponding element of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> for which the corresponding element of <code class="code docutils literal notranslate"><span class="pre">Query</span></code> succeeds in a particle and <code class="code docutils literal notranslate"><span class="pre">W</span></code> is the weight of the particle.
For each element of <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code>, the particles are obtained by sampling the corresponding element of <code class="code docutils literal notranslate"><span class="pre">Query</span></code> in each current particle and weighting the particle by the likelihood of the evidence element.</p>
<p>For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="p">[</span><span class="nv">O1</span><span class="p">,</span><span class="nv">O2</span><span class="p">,</span><span class="nv">O3</span><span class="p">,</span><span class="nv">O4</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.133</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.183</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.212</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.586</span><span class="p">],</span>
<span class="nf">mc_particle_sample_arg</span><span class="p">([</span><span class="nf">kf_fin</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nv">T1</span><span class="p">),</span><span class="nf">kf_fin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nv">T2</span><span class="p">),</span><span class="nf">kf_fin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nv">T3</span><span class="p">),</span>
<span class="nf">kf_fin</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="nv">T4</span><span class="p">)],</span>
<span class="p">[</span><span class="nf">kf_o</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nv">O1</span><span class="p">),</span><span class="nf">kf_o</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nv">O2</span><span class="p">),</span><span class="nf">kf_o</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nv">O3</span><span class="p">),</span><span class="nf">kf_o</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="nv">O4</span><span class="p">)],</span><span class="mi">100</span><span class="p">,</span>
<span class="p">[</span><span class="nv">T1</span><span class="p">,</span><span class="nv">T2</span><span class="p">,</span><span class="nv">T3</span><span class="p">,</span><span class="nv">T4</span><span class="p">],[</span><span class="nv">F1</span><span class="p">,</span><span class="nv">F2</span><span class="p">,</span><span class="nv">F3</span><span class="p">,</span><span class="nv">F4</span><span class="p">]).</span>
</pre></div>
</div>
<p>from <a class="reference external" href="http://cplint.eu/e/kalman_filter.pl">kalman_filter.pl</a> performs particle filtering for a Kalman filter with four observations.
For each observation, the value of the state at the same time point is sampled.
The list of samples is returned in <code class="code docutils literal notranslate"><span class="pre">[F1,F2,F3,F4]</span></code>, with each element being the sample for a time point.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_particle_sample</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">:</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Samples</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Prob</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>samples <code class="code docutils literal notranslate"><span class="pre">Query</span></code> a number of <code class="code docutils literal notranslate"><span class="pre">Samples</span></code> times given that <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is true using particle filtering. <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is a list of goals.
The predicate returns in <code class="code docutils literal notranslate"><span class="pre">Prob</span></code> the probability that the query is true.</p>
<p>You can compute conditional expectations using particle filtering with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">mc_particle_expectation</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="nv">Evidence</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">N</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="s s-Atom">?</span><span class="nv">Arg</span><span class="o">:</span><span class="s s-Atom">var</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>that computes the expected value of <code class="code docutils literal notranslate"><span class="pre">Arg</span></code> in <code class="code docutils literal notranslate"><span class="pre">Query</span></code> given that <code class="code docutils literal notranslate"><span class="pre">Evidence</span></code> is true.
It uses <code class="code docutils literal notranslate"><span class="pre">N</span></code> particles.</p>
</section>
<section id="mpe-map-and-viterbi-inference">
<h3>MPE, MAP and Viterbi Inference<a class="headerlink" href="#mpe-map-and-viterbi-inference" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">pita</span></code> supports MPE (Most Probable Explanation) and MAP (Maximum A Posteriori) inference. <span id="id29">[<a class="reference internal" href="#id47" title="Elena Bellodi, Marco Alberti, Fabrizio Riguzzi, and Riccardo Zese. MAP inference for probabilistic logic programming. Theory and Practice of Logic Programming, 20(5):641â€“655, 2020. URL: https://arxiv.org/abs/2008.01394, doi:10.1017/S1471068420000174.">BARZ20</a>, <a class="reference internal" href="#id46" title="Dimitar Sht. Shterionov, Joris Renkens, Jonas Vlasselaer, Angelika Kimmig, Wannes Meert, and Gerda Janssens. The most probable explanation for probabilistic logic programs with annotated disjunctions. In Jesse Davis and Jan Ramon, editors, International Conference on Inductive Logic Programming, volume 9046 of LNCS, 139–153. Berlin, Heidelberg, 2015. Springer. doi:10.1007/978-3-319-23708-4_10.">SRV+15</a>]</span>.</p>
<p>In MAP inference we look for the choices of head atoms of some clauses that lead to the probability of a query being
maximal. The rules for which we want the choices, called <em>query</em>, are indicated in the input file by prepending
the text <code class="code docutils literal notranslate"><span class="pre">map_query</span></code> to each query rule. For example, in the program <a class="reference external" href="http://cplint.eu/e/bag_1.pl">bag_1.pl</a></p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="mf">0.6</span><span class="o">::</span><span class="nf">red</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">);</span> <span class="mf">0.3</span><span class="o">::</span><span class="nf">green</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">);</span> <span class="mf">0.1</span><span class="o">::</span><span class="nf">blue</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">)</span> <span class="o">:-</span> <span class="nf">pick</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">).</span>
<span class="s s-Atom">map_query</span> <span class="mf">0.6</span><span class="o">::</span><span class="nf">pick</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">);</span> <span class="mf">0.4</span><span class="o">::</span><span class="nf">no_pick</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">).</span>

<span class="s s-Atom">ev</span><span class="p">:</span><span class="o">-</span> <span class="s s-Atom">\+</span> <span class="nf">blue</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">).</span>
</pre></div>
</div>
<p>we are asking for the choice for the second rule.
The predicate to use is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">map</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">atom</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
</pre></div>
</div>
<p>For example, the query on the program above</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">map</span><span class="p">(</span><span class="s s-Atom">ev</span><span class="p">,</span><span class="nv">P</span><span class="p">,</span><span class="nv">Exp</span><span class="p">).</span>
</pre></div>
</div>
<p>asks for the chocie for the second rule that yelds the highest probability for <code class="code docutils literal notranslate"><span class="pre">ev</span></code>. The query returns</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">P</span> <span class="o">=</span> <span class="mf">0.5399999999999999</span><span class="p">,</span>
<span class="nv">Exp</span> <span class="o">=</span> <span class="p">[</span><span class="nf">rule</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">pick</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">),</span> <span class="p">[</span><span class="nf">pick</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">)</span><span class="o">:</span><span class="mf">0.6</span><span class="p">,</span> <span class="nf">no_pick</span><span class="p">(</span><span class="s s-Atom">b1</span><span class="p">)</span><span class="o">:</span><span class="mf">0.4</span><span class="p">],</span> <span class="s s-Atom">true</span><span class="p">)].</span>
</pre></div>
</div>
<p>In MPE inference we are interested in the choices for <em>all</em> rules. To perform MPE inference,
we need to prepend  <code class="code docutils literal notranslate"><span class="pre">map_query</span></code> to each rule and use predicate <code class="code docutils literal notranslate"><span class="pre">map/3</span></code>.</p>
<p>For example, on program <a class="reference external" href="http://cplint.eu/e/bag_game_mpe.pl">bag_game_mpe.pl</a></p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">win</span> <span class="o">:-</span> <span class="s s-Atom">red</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">.</span>
<span class="nf">win</span> <span class="o">:-</span> <span class="s s-Atom">blue</span><span class="p">,</span> <span class="s s-Atom">yellow</span><span class="p">.</span>

<span class="s s-Atom">map_query</span> <span class="mf">0.4</span><span class="o">::</span><span class="s s-Atom">red</span><span class="p">.</span>
<span class="s s-Atom">map_query</span> <span class="mf">0.9</span><span class="o">::</span><span class="s s-Atom">green</span><span class="p">.</span>
<span class="s s-Atom">map_query</span> <span class="mf">0.5</span><span class="o">::</span><span class="s s-Atom">blue</span><span class="p">.</span>
<span class="s s-Atom">map_query</span> <span class="mf">0.6</span><span class="o">::</span><span class="s s-Atom">yellow</span><span class="p">.</span>
</pre></div>
</div>
<p>the query</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">map</span><span class="p">(</span><span class="s s-Atom">win</span><span class="p">,</span><span class="nv">P</span><span class="p">,</span><span class="nv">Exp</span><span class="p">).</span>
</pre></div>
</div>
<p>returns</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">Exp</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nf">rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s s-Atom">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">red</span><span class="p">:</span><span class="mf">0.4</span><span class="p">,</span> <span class="s s-Atom">&#39;&#39;</span> <span class="o">:</span> <span class="mf">0.6</span><span class="p">],</span> <span class="s s-Atom">true</span><span class="p">),</span>
        <span class="nf">rule</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">green</span><span class="p">:</span><span class="mf">0.9</span><span class="p">,</span> <span class="s s-Atom">&#39;&#39;</span> <span class="o">:</span> <span class="mf">0.09999999999999998</span><span class="p">],</span> <span class="s s-Atom">true</span><span class="p">),</span>
        <span class="nf">rule</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s s-Atom">blue</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">blue</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="s s-Atom">&#39;&#39;</span> <span class="o">:</span> <span class="mf">0.5</span><span class="p">],</span> <span class="s s-Atom">true</span><span class="p">),</span>
        <span class="nf">rule</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s s-Atom">yellow</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">yellow</span><span class="p">:</span><span class="mf">0.6</span><span class="p">,</span> <span class="s s-Atom">&#39;&#39;</span> <span class="o">:</span> <span class="mf">0.4</span><span class="p">],</span> <span class="s s-Atom">true</span><span class="p">)],</span>
<span class="nv">P</span> <span class="o">=</span> <span class="mf">0.162</span><span class="p">,</span>
</pre></div>
</div>
<p>In Viterbi inference we are interested in the most probable proof of a query. See <span id="id30">[<a class="reference internal" href="#id46" title="Dimitar Sht. Shterionov, Joris Renkens, Jonas Vlasselaer, Angelika Kimmig, Wannes Meert, and Gerda Janssens. The most probable explanation for probabilistic logic programs with annotated disjunctions. In Jesse Davis and Jan Ramon, editors, International Conference on Inductive Logic Programming, volume 9046 of LNCS, 139–153. Berlin, Heidelberg, 2015. Springer. doi:10.1007/978-3-319-23708-4_10.">SRV+15</a>]</span>
for the difference between the most probable proof and the most probable explanation.
Module <code class="code docutils literal notranslate"><span class="pre">viterbi</span></code> looks for the most probable proof by using a meta interpreter
that performs branch and bound.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">viterbi</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">conjunction_of_literals</span><span class="p">,</span><span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">Exp</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
</pre></div>
</div>
<p>computes the most probable proof of the conjunction of literals <code class="code docutils literal notranslate"><span class="pre">Query</span></code>.
It returns the proof as explanation in <code class="code docutils literal notranslate"><span class="pre">Exp</span></code>.</p>
<p>In example <a class="reference external" href="http://cplint.eu/e/bag_game_vit.pl">bag_game_vit.pl</a>:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">viterbi</span><span class="p">)).</span>

<span class="o">:-</span> <span class="s s-Atom">viterbi</span><span class="p">.</span>

<span class="o">:-</span> <span class="s s-Atom">begin_lpad</span><span class="p">.</span>

<span class="nf">win</span> <span class="o">:-</span> <span class="s s-Atom">red</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">.</span>
<span class="nf">win</span> <span class="o">:-</span> <span class="s s-Atom">blue</span><span class="p">,</span> <span class="s s-Atom">yellow</span><span class="p">.</span>

<span class="mf">0.4</span><span class="o">::</span><span class="s s-Atom">red</span><span class="p">.</span>
<span class="mf">0.9</span><span class="o">::</span><span class="s s-Atom">green</span><span class="p">.</span>
<span class="mf">0.5</span><span class="o">::</span><span class="s s-Atom">blue</span><span class="p">.</span>
<span class="mf">0.6</span><span class="o">::</span><span class="s s-Atom">yellow</span><span class="p">.</span>

<span class="o">:-</span> <span class="s s-Atom">end_lpad</span><span class="p">.</span>
</pre></div>
</div>
<p>the query</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">viterbi</span><span class="p">(</span><span class="s s-Atom">win</span><span class="p">,</span><span class="nv">P</span><span class="p">,</span><span class="nv">Exp</span><span class="p">).</span>
</pre></div>
</div>
<p>returns</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">P</span><span class="o">=</span><span class="mf">0.36</span><span class="p">,</span>
<span class="nv">Exp</span><span class="o">=</span><span class="p">[</span>
        <span class="nf">rule</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s s-Atom">red</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">red</span><span class="p">:</span><span class="mf">0.4</span><span class="p">,</span> <span class="s s-Atom">&#39;&#39;</span><span class="o">:</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[]),</span>
        <span class="nf">rule</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s s-Atom">green</span><span class="p">,</span> <span class="p">[</span><span class="s s-Atom">green</span><span class="p">:</span><span class="mf">0.9</span><span class="p">,</span> <span class="s s-Atom">&#39;&#39;</span><span class="o">:</span><span class="mf">0.09999999999999998</span><span class="p">],</span> <span class="p">[])])).</span>
</pre></div>
</div>
<p>As you can see the Viterbi explanation is different from the MPE one presented above.</p>
<p>Note that <code class="code docutils literal notranslate"><span class="pre">viterbi/3</span></code>, in case the query contains variables, returns their instantiation
leading to the highest probability of the grounding of the query. For example,
in <a class="reference external" href="http://cplint.eu/e/hmm_vit.pl">hmm_vit.pl</a>, the query</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span><span class="nf">viterbi</span><span class="p">(</span><span class="nf">hmm1</span><span class="p">(</span><span class="nv">S</span><span class="p">,[</span><span class="s s-Atom">a</span><span class="p">,</span><span class="s s-Atom">g</span><span class="p">,</span><span class="s s-Atom">g</span><span class="p">]),</span><span class="k">_</span><span class="nv">P</span><span class="p">,</span><span class="k">_</span><span class="nv">E</span><span class="p">).</span>
</pre></div>
</div>
<p>returns</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nv">S</span> <span class="o">=</span> <span class="p">[</span><span class="s s-Atom">q2</span><span class="p">,</span> <span class="s s-Atom">q2</span><span class="p">,</span> <span class="s s-Atom">q1</span><span class="p">],</span>
</pre></div>
</div>
<section id="drawing-bdds-for-map-mpe">
<h4>Drawing BDDs for MAP/MPE<a class="headerlink" href="#drawing-bdds-for-map-mpe" title="Permalink to this headline">¶</a></h4>
<p>With <code class="code docutils literal notranslate"><span class="pre">pita</span></code>, you can obtain the BDD for a MAP/MPE query with the predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">map_bdd_dot_string</span><span class="p">(</span><span class="o">:</span><span class="nv">Query</span><span class="o">:</span><span class="s s-Atom">atom</span><span class="p">,</span><span class="o">-</span><span class="nv">DotString</span><span class="o">:</span><span class="s s-Atom">string</span><span class="p">,</span><span class="o">-</span><span class="nv">LV</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">LAV</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span>
        <span class="o">-</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">Delta</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">nondet</span>
</pre></div>
</div>
<p>The BDD is represented in the dot format of graphviz and returned in <code class="code docutils literal notranslate"><span class="pre">DotString</span></code>. See <a class="reference internal" href="#drawing-bdds"><span class="std std-ref">Drawing BDDs</span></a>
for the graph format and for instruction on how to draw it.
It returns the explanation in <code class="code docutils literal notranslate"><span class="pre">Delta</span></code> together with its <code class="code docutils literal notranslate"><span class="pre">Probability</span></code>
The predicate returns <code class="code docutils literal notranslate"><span class="pre">LV</span></code> and <code class="code docutils literal notranslate"><span class="pre">LAV</span></code>, the association of variables to rules
and of query variables to rules respectively.
<code class="code docutils literal notranslate"><span class="pre">LV</span></code> and <code class="code docutils literal notranslate"><span class="pre">LAV</span></code> are lists of list, each sublist has three elements:
the multivalued variable number,
the rule number and the grounding substitution.</p>
</section>
</section>
<section id="causal-inference">
<h3>Causal Inference<a class="headerlink" href="#causal-inference" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">pita</span></code> and <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> support causal reasoning, i.e., computing the effect of actions using the do-calculus <span id="id31">[<a class="reference internal" href="#id60" title="J. Pearl. Causality. Cambridge University Press, 2000.">Pea00</a>]</span>.</p>
<p>Actions in this setting are represented as literals of action predicates, that must be declared as such with the directive</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="s s-Atom">action</span> <span class="s s-Atom">predicate1</span><span class="o">/</span><span class="s s-Atom">arity1</span><span class="p">,...,</span><span class="s s-Atom">predicaten</span><span class="o">/</span><span class="s s-Atom">arityn</span><span class="p">.</span>
</pre></div>
</div>
<p>for <code class="code docutils literal notranslate"><span class="pre">pita</span></code>, and</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="s s-Atom">mcaction</span> <span class="s s-Atom">predicate1</span><span class="o">/</span><span class="s s-Atom">arity1</span><span class="p">,...,</span><span class="s s-Atom">predicaten</span><span class="o">/</span><span class="s s-Atom">arityn</span><span class="p">.</span>
</pre></div>
</div>
<p>for <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code>.</p>
<p>When performing causal reasoning, action literals must be enclosed in the <code class="code docutils literal notranslate"><span class="pre">do/1</span></code> functor and included in the evidence conjunction.
More than one action can be included (each with in a separate <code class="code docutils literal notranslate"><span class="pre">do/1</span></code> term) and actions and observations can be freely mixed.
All conditional inference goals can be used except those for particle filtering.</p>
<p>For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">prob</span><span class="p">(</span><span class="s s-Atom">recovery</span><span class="p">,</span><span class="nf">do</span><span class="p">(</span><span class="s s-Atom">drug</span><span class="p">),</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>from <a class="reference external" href="http://cplint.eu/e/simpson.swinb">simpson.swinb</a> computes the probability of recovery of a patient given that the action of administering a drug has been performed.</p>
</section>
<section id="graphing-the-results">
<h3>Graphing the Results<a class="headerlink" href="#graphing-the-results" title="Permalink to this headline">¶</a></h3>
<p>In <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH you can draw graphs for visualizing the results either with <a class="reference external" href="http://www.c3js.org/">C3.js</a> or with <a class="reference external" href="http://www.r-project.org/">R</a>.
Similar predicates are available for the two methods.
There are two types of graphs: those that represent individual probability values with a bar chart and those that visualize the results of sampling arguments.</p>
<section id="using-c3-js">
<h4>Using C3.js<a class="headerlink" href="#using-c3-js" title="Permalink to this headline">¶</a></h4>
<p>You can draw the probability of a query being true and being false as a bar chart using the predicates</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">bar1</span><span class="p">(</span><span class="o">+</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">Chart</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
<span class="nf">bar</span><span class="p">(</span><span class="o">+</span><span class="nv">Probability</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">Chart</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
<span class="nf">bar</span><span class="p">(</span><span class="o">+</span><span class="nv">Successes</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">+</span><span class="nv">Failures</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">Chart</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
<span class="nf">argbar</span><span class="p">(</span><span class="o">+</span><span class="nv">Values</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">Chart</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>They return a dict for rendering with C3.js as a bar chart: the first returns bar chart with a single bar for the probability, the second a chart with bar for the probability and a bar for one minus the probability, the third a chart with a bar for the number of successes and a bar for the number of failures, and the fourth a chart with a for bar each value, where <code class="code docutils literal notranslate"><span class="pre">Values</span></code> is a list of pairs <code class="code docutils literal notranslate"><span class="pre">V-N</span></code> where <code class="code docutils literal notranslate"><span class="pre">V</span></code> is the value and <code class="code docutils literal notranslate"><span class="pre">N</span></code> is the number of samples returning that value.</p>
<p>To render C3.js charts you have to include</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_rendering</span><span class="p">(</span><span class="s s-Atom">c3</span><span class="p">).</span>
</pre></div>
</div>
<p>before <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">pita.</span></code></p>
<p>You can also use the <code class="code docutils literal notranslate"><span class="pre">bar(-Chart:dict)</span></code> option of many predicates as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">prob</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nf">biased</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">P</span><span class="p">,[</span><span class="nf">bar</span><span class="p">(</span><span class="nv">Chart</span><span class="p">)]).</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">P</span></code> will be instantiated with a chart with a bar for the probability of <code class="code docutils literal notranslate"><span class="pre">heads(coin)</span></code> true and a bar for the probability of <code class="code docutils literal notranslate"><span class="pre">heads(coin)</span></code> false, given that <code class="code docutils literal notranslate"><span class="pre">biased(coin)</span></code> is true.</p>
<p>Another example is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_prob</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">P</span><span class="p">,[</span><span class="nf">bar</span><span class="p">(</span><span class="nv">Chart</span><span class="p">)]).</span>
</pre></div>
</div>
<p>that returns a chart representation of the probability.</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">P</span><span class="p">,[</span><span class="nf">bar</span><span class="p">(</span><span class="nv">Chart</span><span class="p">)]).</span>
</pre></div>
</div>
<p>returns in <code class="code docutils literal notranslate"><span class="pre">Chart</span></code> a diagram with one bar for the number of successes and one bar for the number of failures.</p>
<p>The options of <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg/5</span></code>, <code class="code docutils literal notranslate"><span class="pre">mc_sample_arg_first/5</span></code>, <code class="code docutils literal notranslate"><span class="pre">mc_mh_sample_arg/6</span></code>, <code class="code docutils literal notranslate"><span class="pre">mc_rejection_sample_arg/6</span></code>, can be used for visualizing the results of sampling arguments.</p>
<p>An example is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample_arg</span><span class="p">(</span><span class="nf">reach</span><span class="p">(</span><span class="s s-Atom">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nv">S</span><span class="p">),</span><span class="mi">50</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">ValList</span><span class="p">,[</span><span class="nf">bar</span><span class="p">(</span><span class="nv">Chart</span><span class="p">)]).</span>
</pre></div>
</div>
<p>of <a class="reference external" href="http://cplint.eu/e/markov_chain.pl">markov_chain.pl</a>.</p>
<p>The same result can be achieved with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample_arg</span><span class="p">(</span><span class="nf">reach</span><span class="p">(</span><span class="s s-Atom">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nv">S</span><span class="p">),</span><span class="mi">50</span><span class="p">,</span><span class="nv">S</span><span class="p">,</span><span class="nv">ValList</span><span class="p">),</span><span class="nf">argbar</span><span class="p">(</span><span class="nv">ValList</span><span class="p">,</span><span class="nv">Chart</span><span class="p">)</span>
</pre></div>
</div>
<p>Drawing a graph is particularly interesting when sampling values for continuous arguments of goals.
In this case, you can use the samples to draw the probability density function of the argument.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">histogram</span><span class="p">(</span><span class="o">+</span><span class="nv">List</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">Chart</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>draws a histogram of the samples in <code class="code docutils literal notranslate"><span class="pre">List</span></code> that must be a list of pairs of the
form <code class="code docutils literal notranslate"><span class="pre">[V]-W</span></code> or <code class="code docutils literal notranslate"><span class="pre">V-W</span></code> where <code class="code docutils literal notranslate"><span class="pre">V</span></code> is a sampled value and <code class="code docutils literal notranslate"><span class="pre">W</span></code> is its weight,
or a list of sampled values.
This is the format of the list of samples returned by argument sampling predicates.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">density</span><span class="p">(</span><span class="o">+</span><span class="nv">List</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">Chart</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>draws a line chart of the density of the samples in <code class="code docutils literal notranslate"><span class="pre">List</span></code> that must take the same form as for <code class="code docutils literal notranslate"><span class="pre">histogram/3</span></code>.</p>
<p>In <code class="code docutils literal notranslate"><span class="pre">histogram/3</span></code> and <code class="code docutils literal notranslate"><span class="pre">density/3</span></code> <code class="code docutils literal notranslate"><span class="pre">Options</span></code> is a list of options, the following are recognised:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">min(+Min:float)</span></code> the minimum value of domain, default value the minimum in <code class="code docutils literal notranslate"><span class="pre">List</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max(+Max:float)</span></code> the maximum value of domain, default value the maximum in <code class="code docutils literal notranslate"><span class="pre">List</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">nbins(+NBins:int)</span></code> the number of bins for dividing the domain, default value 40</p></li>
</ul>
<p>In this way you can specify the limits and the number of intervals of the <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>The predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">densities</span><span class="p">(</span><span class="o">+</span><span class="nv">PriorList</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">PostList</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">Chart</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>draws a line chart of the density of two sets of samples, usually prior and post observations.
The samples in <code class="code docutils literal notranslate"><span class="pre">PriorList</span></code> and <code class="code docutils literal notranslate"><span class="pre">PostList</span></code> must take the same form as <code class="code docutils literal notranslate"><span class="pre">List</span></code> for <code class="code docutils literal notranslate"><span class="pre">histogram/3</span></code>.
The same options as for <code class="code docutils literal notranslate"><span class="pre">histogram/3</span></code> and <code class="code docutils literal notranslate"><span class="pre">density/3</span></code> are recognized.</p>
<p>For example, the query</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span>  <span class="nf">mc_sample_arg</span><span class="p">(</span><span class="nf">value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nv">X</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">L0</span><span class="p">,[]),</span><span class="nf">histogram</span><span class="p">(</span><span class="nv">L0</span><span class="p">,</span><span class="nv">Chart</span><span class="p">,[]).</span>
</pre></div>
</div>
<p>from <a class="reference external" href="http://cplint.eu/e/gauss_mean_est.pl">gauss_mean_est.pl</a>, takes 1000 samples of argument <code class="code docutils literal notranslate"><span class="pre">X</span></code> of <code class="code docutils literal notranslate"><span class="pre">value(0,X)</span></code> and draws the density of the samples using an histogram.</p>
<p>Instead</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">mc_sample_arg</span><span class="p">(</span><span class="nf">value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nv">Y</span><span class="p">),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">Y</span><span class="p">,</span><span class="nv">L0</span><span class="p">,[]),</span>
<span class="nf">mc_lw_sample_arg</span><span class="p">(</span><span class="nf">value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nv">X</span><span class="p">),</span>
<span class="p">(</span><span class="nf">value</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span><span class="nf">value</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)),</span><span class="mi">1000</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="nv">L</span><span class="p">),</span>
<span class="nf">densities</span><span class="p">(</span><span class="nv">L0</span><span class="p">,</span><span class="nv">L</span><span class="p">,</span><span class="nv">Chart</span><span class="p">).</span>
</pre></div>
</div>
<p>from <a class="reference external" href="http://cplint.eu/e/gauss_mean_est.pl">gauss_mean_est.pl</a> takes 1000 amples of argument <code class="code docutils literal notranslate"><span class="pre">X</span></code> of <code class="code docutils literal notranslate"><span class="pre">value(0,X)</span></code> before and after observing <code class="code docutils literal notranslate"><span class="pre">(value(1,9),value(2,8)</span></code> and draws the prior and posterior densities of the samples using a line chart.</p>
<p>Predicates <code class="code docutils literal notranslate"><span class="pre">histogram/3</span></code>, <code class="code docutils literal notranslate"><span class="pre">density/3</span></code> and <code class="code docutils literal notranslate"><span class="pre">densities/4</span></code> each have a version with one argument less that is equivalent to the predicate called with an empty option list.</p>
</section>
<section id="using-r">
<h4>Using R<a class="headerlink" href="#using-r" title="Permalink to this headline">¶</a></h4>
<p>You have to load library <code class="code docutils literal notranslate"><span class="pre">cplint_r</span></code> (a SWI-Prolog pack) with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">cplint_r</span><span class="p">)).</span>
</pre></div>
</div>
<p>Then you can use predicates</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">bar_r</span><span class="o">/</span><span class="mi">1</span>
<span class="s s-Atom">bar_r</span><span class="o">/</span><span class="mi">2</span>
<span class="s s-Atom">argbar_r</span><span class="o">/</span><span class="mi">1</span>
</pre></div>
</div>
<p>that work as their C3.js counterpart but do not return the graph as an argument as the graph is printed with a different mechanism.</p>
<p>You also have</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">histogram_r</span><span class="p">(</span><span class="o">+</span><span class="nv">List</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">Options</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>that works as <code class="code docutils literal notranslate"><span class="pre">histogram/3</span></code>.</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">density_r</span><span class="p">(</span><span class="o">+</span><span class="nv">List</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>is like <code class="code docutils literal notranslate"><span class="pre">density/3</span></code> with the number of bins is determined by R.</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">densities_r</span><span class="p">(</span><span class="o">+</span><span class="nv">PriorList</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">PostList</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>is like <code class="code docutils literal notranslate"><span class="pre">densities/3</span></code> with the number of bins is determined by R.</p>
<p>See <a class="reference external" href="http://cplint.eu/e/gauss_mean_est_R.pl">gauss_mean_est_R.pl</a> for an example of use of these predicates.</p>
</section>
</section>
<section id="parameters-for-inference">
<h3>Parameters for Inference<a class="headerlink" href="#parameters-for-inference" title="Permalink to this headline">¶</a></h3>
<p>The inference modules have a number of parameters in order to control their behavior.
They can be set with the directive</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">set_pita</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">parameter&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">value&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">set_mc</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">parameter&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">value&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>after initialization (<code class="code docutils literal notranslate"><span class="pre">:-pita.</span></code> or <code class="code docutils literal notranslate"><span class="pre">:-mc.</span></code>) but outside <code class="code docutils literal notranslate"><span class="pre">:-begin/end_lpad.</span></code>
The current value can be read with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">setting_pita</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">parameter&gt;</span><span class="p">,</span><span class="nv">Value</span><span class="p">).</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">setting_mc</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">parameter&gt;</span><span class="p">,</span><span class="nv">Value</span><span class="p">).</span>
</pre></div>
</div>
<p>from the top-level.
The available parameters common to both <code class="code docutils literal notranslate"><span class="pre">pita</span></code> and <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">epsilon_parsing</span></code>: if (1 - the sum of the probabilities of all the head atoms) is larger than <code class="code docutils literal notranslate"><span class="pre">epsilon_parsing</span></code>, then <code class="code docutils literal notranslate"><span class="pre">pita</span></code> adds the null event to the head. Default value <code class="code docutils literal notranslate"><span class="pre">0.00001</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">single_var</span></code>: determines how non ground clauses are treated: if <code class="code docutils literal notranslate"><span class="pre">true</span></code>, a single random variable is assigned to the whole non ground clause, if <code class="code docutils literal notranslate"><span class="pre">false</span></code>, a different random variable is assigned to every grounding of the clause. Default value <code class="code docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>
<p>Moreover, <code class="code docutils literal notranslate"><span class="pre">pita</span></code> has the parameters</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">depth_bound</span></code>: if <code class="code docutils literal notranslate"><span class="pre">true</span></code>, the depth of the derivation of the goal is limited to the value of the <code class="code docutils literal notranslate"><span class="pre">depth</span></code> parameter. Default value <code class="code docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">depth</span></code>: maximum depth of derivations when <code class="code docutils literal notranslate"><span class="pre">depth_bound</span></code> is set to <code class="code docutils literal notranslate"><span class="pre">true</span></code>. Default value <code class="code docutils literal notranslate"><span class="pre">5</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">prism_memoization</span></code>: <code class="code docutils literal notranslate"><span class="pre">false</span></code>: original prism semantics, <code class="code docutils literal notranslate"><span class="pre">true</span></code>: semantics with memoization</p></li>
</ul>
<p>If <code class="code docutils literal notranslate"><span class="pre">depth_bound</span></code> is set to <code class="code docutils literal notranslate"><span class="pre">true</span></code>, derivations are depth-bounded so you can query also programs containing infinite loops, for example programs where queries have an infinite number of explanations.
However the probability that is returned is guaranteed only to be a lower bound, see for example <a class="reference external" href="http://cplint.eu/e/markov_chaindb.pl">markov_chaindb.pl</a></p>
<p><code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> has the parameters</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">min_error</span></code>: minimal width of the binomial proportion confidence interval for the probability of the query. When the confidence interval for the probability of the query is below <code class="code docutils literal notranslate"><span class="pre">min_error</span></code>, the computation stops. Default value <code class="code docutils literal notranslate"><span class="pre">0.01</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">k</span></code>: the number of samples to take before checking whether the the binomial proportion confidence interval is below <code class="code docutils literal notranslate"><span class="pre">min_error</span></code>. Default value <code class="code docutils literal notranslate"><span class="pre">1000</span></code>. <code class="code docutils literal notranslate"><span class="pre">max_samples</span></code>: the maximum number of samples to take. This is used when the probability of the query is very close to 0 or 1. In fact <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> also checks for the validity of the the binomial proportion confidence interval: if less than 5 failures or successes are sampled, even if the width of the confidence interval is less than <code class="code docutils literal notranslate"><span class="pre">min_error</span></code>, the computation continues. This would lead to non-termination in cases where the probability is 0 or 1. <code class="code docutils literal notranslate"><span class="pre">max_samples</span></code> ensures termination. Default value <code class="code docutils literal notranslate"><span class="pre">10e4</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">prism_memoization</span></code>: <code class="code docutils literal notranslate"><span class="pre">false</span></code>: original prism semantics, <code class="code docutils literal notranslate"><span class="pre">true</span></code>: semantics with memoization</p></li>
</ul>
<p>The example <a class="reference external" href="http://cplint.eu/e/markov_chain.pl">markov_chain.pl</a> shows that <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> can perform inference in presence of an infinite number of explanations for the goal.
Differently from <code class="code docutils literal notranslate"><span class="pre">pita</span></code>, no depth bound is necessary, as the probability of selecting the infinite computation branch is 0.
However, also <code class="code docutils literal notranslate"><span class="pre">mcintyre</span></code> may not terminate if loops not involving probabilistic predicates are present.</p>
<p>If you want to set the seed of the random number generator, you can use SWI-Prolog predicates <code class="code docutils literal notranslate"><span class="pre">setrand/1</span></code> and <code class="code docutils literal notranslate"><span class="pre">getrand/1</span></code>, see <a class="reference external" href="http://www.swi-prolog.org/pldoc/doc_for?object=setrand/1">SWI-Prolog manual</a>.</p>
</section>
<section id="decision-theory">
<h3>Decision Theory<a class="headerlink" href="#decision-theory" title="Permalink to this headline">¶</a></h3>
<p>cplint allows also to represent decision theory problem following the syntax of Dtproblog <span id="id36">[<a class="reference internal" href="#id71" title="Guy Van den Broeck, Ingo Thon, Martijn Van Otterlo, and Luc De Raedt. Dtproblog: a decision-theoretic probabilistic prolog. In Twenty-Fourth AAAI Conference on Artificial Intelligence. 2010.">VdBTVODR10</a>]</span>.</p>
<p>Decision facts can be expressed with the operator <code class="code docutils literal notranslate"><span class="pre">?::</span></code></p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?</span> <span class="o">::</span> <span class="s s-Atom">umbrella</span><span class="p">.</span>
</pre></div>
</div>
<p>Utility facts can be expressed with <code class="code docutils literal notranslate"><span class="pre">utility/2</span></code> where the first parameter is the fact and the second its utility</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">utility</span><span class="p">(</span><span class="s s-Atom">broken_umbrella</span><span class="p">,</span><span class="o">-</span><span class="mi">40</span><span class="p">).</span>
</pre></div>
</div>
<p>In order to compute the best strategy, you can use <code class="code docutils literal notranslate"><span class="pre">dt_solve/2</span></code></p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">dt_solve</span><span class="p">(</span><span class="nv">Strategy</span><span class="p">,</span><span class="nv">Value</span><span class="p">).</span>
</pre></div>
</div>
<p>which returns in <code class="code docutils literal notranslate"><span class="pre">Strategy</span></code> a set of decision facts and in <cite>Value</cite> the value of the computed best strategy.</p>
</section>
</section>
<section id="learning">
<h2>Learning<a class="headerlink" href="#learning" title="Permalink to this headline">¶</a></h2>
<p>The following learning algorithms are available:</p>
<ul class="simple">
<li><p>EMBLEM (EM over Bdds for probabilistic Logic programs Efficient Mining): an implementation of EM for learning parameters that computes expectations directly on BDDs <span id="id37">[<a class="reference internal" href="#id62" title="Elena Bellodi and Fabrizio Riguzzi. EM over binary decision diagrams for probabilistic logic programs. Technical Report CS-2011-01, Dipartimento di Ingegneria, Università di Ferrara, Italy, 2011. URL: http://ml.unife.it/wp-content/uploads/Papers/BelRig-CILC11.pdf.">BR11</a>, <a class="reference internal" href="#id67" title="Elena Bellodi and Fabrizio Riguzzi. Expectation maximization over binary decision diagrams for probabilistic logic programs. Intelligent Data Analysis, 17(2):343–363, 2013.">BR13a</a>, <a class="reference internal" href="#id61" title="Elena Bellodi and Fabrizio Riguzzi. Expectation Maximization over binary decision diagrams for probabilistic logic programs. Intelligent Data Analysis, 17(2):343-363, 2013. URL: http://ds.ing.unife.it/~friguzzi/Papers/BelRig13-IDA-IJ.pdf.">BR13b</a>]</span></p></li>
<li><p>SLIPCOVER (Structure LearnIng of Probabilistic logic programs by searChing OVER the clause space): an algorithm for learning the structure of programs by searching the clause space and the theory space separately <span id="id38">[<a class="reference internal" href="#id63" title="Elena Bellodi and Fabrizio Riguzzi. Structure learning of probabilistic logic programs by searching the clause space. Theory and Practice of Logic Programming, 15(2):169-212, 2015. URL: http://arxiv.org/abs/1309.2080, doi:10.1017/S1471068413000689.">BR15</a>]</span></p></li>
<li><p>LEMUR (LEarning with a Monte carlo Upgrade of tRee search): an algorithm for learning the structure of programs by searching the clase space using Monte-Carlo tree search <span id="id39">[<a class="reference internal" href="#id64" title="Nicola Di Mauro, Elena Bellodi, and Fabrizio Riguzzi. Bandit-based Monte-Carlo structure learning of probabilistic logic programs. Mach. Learn., 100(1):127-156, July 2015. URL: http://ds.ing.unife.it/~friguzzi/Papers/DiMBelRig-ML15.pdf, doi:10.1007/s10994-015-5510-3.">DMBR15</a>]</span></p></li>
</ul>
<section id="input">
<h3>Input<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h3>
<p>To execute the learning algorithms, prepare a Prolog file divided in five parts</p>
<ul class="simple">
<li><p>preamble</p></li>
<li><p>background knowledge, i.e., knowledge valid for all interpretations</p></li>
<li><p>LPAD/CPL-program for you which you want to learn the parameters (optional)</p></li>
<li><p>language bias information</p></li>
<li><p>example interpretations</p></li>
</ul>
<p>The preamble must come first, the order of the other parts can be changed.</p>
<p>For example, consider the Bongard problems of <span id="id40">[<a class="reference internal" href="#id65" title="L. De Raedt and W. Van Laer. Inductive constraint logic. In Proceedings of the 6th Conference on Algorithmic Learning Theory (ALT 1995), volume 997 of LNAI, 80-94. Fukuoka, Japan, 1995. Springer.">DRVL95</a>]</span>. <a class="reference external" href="http://cplint.eu/e/bongard.pl">bongard.pl</a> and <a class="reference external" href="http://cplint.eu/e/bongardkeys.pl">bongardkeys.pl</a> represent a Bongard problem for SLIPCOVER.
<a class="reference external" href="http://cplint.eu/example/lemur/bongard.pl">bongard.pl</a> and <a class="reference external" href="http://cplint.eu/example/lemur/bongardkeys.pl">bongardkeys.pl</a> represent a Bongard problem for LEMUR.</p>
<section id="preamble">
<h4>Preamble<a class="headerlink" href="#preamble" title="Permalink to this headline">¶</a></h4>
<p>In the preamble, the SLIPCOVER library is loaded with (<a class="reference external" href="http://cplint.eu/e/bongard.pl">bongard.pl</a>):</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">slipcover</span><span class="p">)).</span>
</pre></div>
</div>
<p>Now you can initialize SLIPCOVER with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="s s-Atom">sc</span><span class="p">.</span>
</pre></div>
</div>
<p>At this point you can start setting parameters for SLIPCOVER such as for example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">set_sc</span><span class="p">(</span><span class="s s-Atom">megaex_bottom</span><span class="p">,</span><span class="mi">20</span><span class="p">).</span>
<span class="o">:-</span> <span class="nf">set_sc</span><span class="p">(</span><span class="s s-Atom">max_iter</span><span class="p">,</span><span class="mi">2</span><span class="p">).</span>
<span class="o">:-</span> <span class="nf">set_sc</span><span class="p">(</span><span class="s s-Atom">max_iter_structure</span><span class="p">,</span><span class="mi">5</span><span class="p">).</span>
<span class="o">:-</span> <span class="nf">set_sc</span><span class="p">(</span><span class="s s-Atom">verbosity</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>We will see later the list of available parameters.</p>
<p>In the preamble, the LEMUR library is loaded with (<a class="reference external" href="http://cplint.eu/example/lemur/bongard.pl">bongard.pl</a>):</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">lemur</span><span class="p">)).</span>
</pre></div>
</div>
<p>Now you can initialize LEMUR with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="s s-Atom">lemur</span><span class="p">.</span>
</pre></div>
</div>
<p>At this point you can start setting parameters for LEMUR such as for example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">set_lm</span><span class="p">(</span><span class="s s-Atom">verbosity</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>A parameter that is particularly important for both SLIPCOVER and LEMUR is <code class="code docutils literal notranslate"><span class="pre">verbosity</span></code>: if set to 1, nothing is printed and learning is fastest, if set to 3 much information is printed and learning is slowest, 2 is in between. This ends the preamble.</p>
</section>
<section id="background-and-initial-lpad-cpl-program">
<h4>Background and Initial LPAD/CPL-program<a class="headerlink" href="#background-and-initial-lpad-cpl-program" title="Permalink to this headline">¶</a></h4>
<p>Now you can specify the background knowledge with a fact of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">bg</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">list</span> <span class="s s-Atom">of</span> <span class="s s-Atom">terms</span> <span class="s s-Atom">representing</span> <span class="s s-Atom">clauses&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>where the clauses must be deterministic.
Alternatively, you can specify a set of clauses by including them in a section between <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">begin_bg.</span></code> and <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">end_bg.</span></code>
For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="s s-Atom">begin_bg</span><span class="p">.</span>

<span class="nf">replaceable</span><span class="p">(</span><span class="s s-Atom">gear</span><span class="p">).</span>
<span class="nf">replaceable</span><span class="p">(</span><span class="s s-Atom">wheel</span><span class="p">).</span>
<span class="nf">replaceable</span><span class="p">(</span><span class="s s-Atom">chain</span><span class="p">).</span>
<span class="nf">not_replaceable</span><span class="p">(</span><span class="s s-Atom">engine</span><span class="p">).</span>
<span class="nf">not_replaceable</span><span class="p">(</span><span class="s s-Atom">control_unit</span><span class="p">).</span>
<span class="nf">component</span><span class="p">(</span><span class="nv">C</span><span class="p">)</span><span class="o">:-</span> <span class="nf">replaceable</span><span class="p">(</span><span class="nv">C</span><span class="p">).</span>
<span class="nf">component</span><span class="p">(</span><span class="nv">C</span><span class="p">)</span><span class="o">:-</span> <span class="nf">not_replaceable</span><span class="p">(</span><span class="nv">C</span><span class="p">).</span>

<span class="o">:-</span> <span class="s s-Atom">end_bg</span><span class="p">.</span>
</pre></div>
</div>
<p>from the <a class="reference external" href="http://cplint.eu/e/mach.pl">mach.pl</a> example.
If you specify both a <code class="code docutils literal notranslate"><span class="pre">bg/1</span></code> fact and a section, the clauses of the two will be combined.</p>
<p>Moreover, you can specify an initial program with a fact of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">in</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">list</span> <span class="s s-Atom">of</span> <span class="s s-Atom">terms</span> <span class="s s-Atom">representing</span> <span class="s s-Atom">clauses&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>The initial program is used in parameter learning for providing the structure.
Remember to enclose each clause in parentheses because <code class="code docutils literal notranslate"><span class="pre">:-</span></code> has the highest precedence.</p>
<p>For example, <a class="reference external" href="http://cplint.eu/e/bongard.pl">bongard.pl</a> has the initial program</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span>    <span class="nf">in</span><span class="p">([(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.197575</span> <span class="o">:-</span>
   <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
   <span class="nf">in</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">A</span><span class="p">)),</span>
<span class="p">(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.000303421</span> <span class="o">:-</span>
   <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
   <span class="nf">triangle</span><span class="p">(</span><span class="nv">B</span><span class="p">)),</span>
<span class="p">(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.000448807</span> <span class="o">:-</span>
   <span class="nf">triangle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
   <span class="nf">circle</span><span class="p">(</span><span class="nv">B</span><span class="p">))]).</span>
</pre></div>
</div>
<p>Alternatively, you can specify an input program in a section between <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">begin_in.</span></code> and <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">end_in.</span></code>, as for example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="s s-Atom">begin_in</span><span class="p">.</span>

<span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.197575</span> <span class="o">:-</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">in</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">A</span><span class="p">).</span>
<span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.000303421</span> <span class="o">:-</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">triangle</span><span class="p">(</span><span class="nv">B</span><span class="p">).</span>
<span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.000448807</span> <span class="o">:-</span>
        <span class="nf">triangle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">B</span><span class="p">).</span>

<span class="o">:-</span> <span class="s s-Atom">end_in</span><span class="p">.</span>
</pre></div>
</div>
<p>If you specify both a <code class="code docutils literal notranslate"><span class="pre">in/1</span></code> fact and a section, the clauses of the two will be combined.</p>
<p>The annotations of the head atoms of the initial program can be probabilities, as in the example above, in this case the parameters do not matter as they are first randomized. The type of randomization depends on the setting <code class="code docutils literal notranslate"><span class="pre">alpha</span></code>.
If it takes value 0, a truncated Dirichlet process is used to initialize the parameters: the probability of being true of each Boolean random variable used to represent multivalued random variables is sampled and independently uniformly in <span class="math notranslate nohighlight">\([0,1]\)</span>.</p>
<p>If it takes a value <span class="math notranslate nohighlight">\(\geq 0\)</span>, the parameters are sampled from a symmetric Dirichlet distribution, i.e. a Dirichlet distribution with vector of parameters <cite>((alpha,ldots,alpha))</cite>.</p>
<p>The annotations of the head atoms of the initial program can also be <code class="code docutils literal notranslate"><span class="pre">p(&lt;prob&gt;)</span></code> with <code class="code docutils literal notranslate"><span class="pre">&lt;prob&gt;</span></code> a probability, in this case the parameter is fixed so it is not tuned by learning, as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">in</span><span class="p">([(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.5</span> <span class="o">:-</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">in</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">A</span><span class="p">)),</span>
        <span class="p">(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="nf">p</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">:-</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">triangle</span><span class="p">(</span><span class="nv">B</span><span class="p">))]).</span>
</pre></div>
</div>
<p>The annotations of the head atoms of the initial program can also be <code class="code docutils literal notranslate"><span class="pre">t(&lt;prob&gt;,&lt;args&gt;)</span></code> with <code class="code docutils literal notranslate"><span class="pre">&lt;prob&gt;</span></code> either a probability, in this case it is the initial value of the parameter, or a variable, in this case the parameter is initially randomized, and <code class="code docutils literal notranslate"><span class="pre">&lt;args&gt;</span></code> a tuple of variables that also appear in the clause.
In this case a different parameter is learned for every grounding of <code class="code docutils literal notranslate"><span class="pre">&lt;args&gt;</span></code> that make the body true.</p>
<p>For example, we can set the initial value of the parameter of the second clause to 0.9 with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">in</span><span class="p">([(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.5</span> <span class="o">:-</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">in</span><span class="p">(</span><span class="nv">B</span><span class="p">,</span><span class="nv">A</span><span class="p">)),</span>
        <span class="p">(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="nf">t</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span> <span class="o">:-</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">triangle</span><span class="p">(</span><span class="nv">B</span><span class="p">))]).</span>
</pre></div>
</div>
<p>With the program below we learn a different parameter for every instantiation of <code class="code docutils literal notranslate"><span class="pre">C</span></code> in the second clause:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">in</span><span class="p">([(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="mf">0.5</span> <span class="o">:-</span>
        <span class="nf">circle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">in</span><span class="p">(</span><span class="k">_</span><span class="nv">B</span><span class="p">,</span><span class="nv">A</span><span class="p">)),</span>
        <span class="p">(</span><span class="s s-Atom">pos</span><span class="p">:</span><span class="nf">t</span><span class="p">(</span><span class="k">_</span><span class="p">,</span><span class="nv">C</span><span class="p">)</span> <span class="o">:-</span>
        <span class="nf">triangle</span><span class="p">(</span><span class="nv">A</span><span class="p">),</span>
        <span class="nf">config</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">C</span><span class="p">))]).</span>
</pre></div>
</div>
</section>
<section id="language-bias">
<h4>Language Bias<a class="headerlink" href="#language-bias" title="Permalink to this headline">¶</a></h4>
<p>The language bias part contains the declarations of the input and output predicates.
Output predicates are declared as</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">output</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">predicate&gt;/&lt;arity&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>and indicate the predicate whose atoms you want to predict.
Derivations for the atoms for this predicates in the input data are built by the system.
These are the predicates for which new clauses are generated.
Input predicates are those whose atoms you are not interested in predicting.
You can declare closed world input predicates with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">input_cw</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">predicate&gt;/&lt;arity&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>For these predicates, the only true atoms are those in the interpretations and those derivable from them using the background knowledge, the clauses in the input or in the hypothesized program are not used to derive atoms for these predicates. Moreover, clauses of the background knowledge that define closed world input predicates and that call an output predicate in the body will not be used for deriving examples.</p>
<p>Open world input predicates are declared with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">input</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">predicate&gt;/&lt;arity&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>In this case, if a subgoal for such a predicate is encountered when deriving a subgoal for the output predicates, both the facts in the interpretations, those derivable from them and the background knowledge, the background clauses and the clauses of the input program are used.</p>
<p>Then, you have to specify the language bias by means of mode declarations in the style of <a class="reference external" href="https://www.doc.ic.ac.uk/~shm/progol.html">Progol</a>.</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">modeh</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">recall&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">predicate&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">arg1&gt;</span><span class="p">,...)).</span>
</pre></div>
</div>
<p>specifies the atoms that can appear in the head of clauses, while</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">modeb</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">recall&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">predicate&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">arg1&gt;</span><span class="p">,...)).</span>
</pre></div>
</div>
<p>specifies the atoms that can appear in the body of clauses. <code class="code docutils literal notranslate"><span class="pre">&lt;recall&gt;</span></code> can be an integer or <code class="code docutils literal notranslate"><span class="pre">*</span></code>. <code class="code docutils literal notranslate"><span class="pre">&lt;recall&gt;</span></code> indicates how many atoms for the predicate specification are retained in the bottom clause during a saturation step. <code class="code docutils literal notranslate"><span class="pre">*</span></code> stands for all those that are found.
Otherwise the indicated number is randomly chosen.</p>
<p>For SLIPCOVER, two specialization modes are available: <code class="code docutils literal notranslate"><span class="pre">bottom</span></code> and <code class="code docutils literal notranslate"><span class="pre">mode</span></code>. In the first, a bottom clause is built and the literals to be added during refinement are taken from it. In the latter, no bottom clause is built and the literals to be added during refinement are generated directly from the mode declarations. LEMUR has only specialization <code class="code docutils literal notranslate"><span class="pre">mode</span></code>.</p>
<p>Arguments of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">+&lt;type</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>specifies that the argument should be an input variable of type <code class="code docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>, i.e., a variable replacing a <code class="code docutils literal notranslate"><span class="pre">+&lt;type&gt;</span></code> argument in the head or a <code class="code docutils literal notranslate"><span class="pre">-&lt;type&gt;</span></code> argument in a preceding literal in the current hypothesized clause.</p>
<p>Another argument form is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">-&lt;type</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for specifying that the argument should be a output variable of type <code class="code docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>.
Any variable can replace this argument, either input or output.
The only constraint on output variables is that those in the head of the current hypothesized clause must appear as output variables in an atom of the body.</p>
<p>Other forms are</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">#&lt;type</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for specifying an argument which should be replaced by a constant of type <code class="code docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code> in the bottom clause but should not be used for replacing input variables of the following literals when building the bottom clause or</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">-#&lt;type</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for specifying an argument which should be replaced by a constant of type <code class="code docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code> in the bottom clause and that should be used for replacing input variables of the following literals when building the bottom clause.</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="s s-Atom">constant</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>for specifying a constant.</p>
<p>Note that arguments of the form <code class="code docutils literal notranslate"><span class="pre">#&lt;type&gt;</span></code> <code class="code docutils literal notranslate"><span class="pre">-#&lt;type&gt;</span></code> are not available in specialization mode <code class="code docutils literal notranslate"><span class="pre">mode</span></code>, if you want constants to appear in the literals you have to indicate them one by one in the mode declarations.</p>
<p>An example of language bias for the Bongard domain is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">output</span><span class="p">(</span><span class="s s-Atom">pos</span><span class="o">/</span><span class="mi">0</span><span class="p">).</span>

<span class="nf">input_cw</span><span class="p">(</span><span class="s s-Atom">triangle</span><span class="o">/</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">input_cw</span><span class="p">(</span><span class="s s-Atom">square</span><span class="o">/</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">input_cw</span><span class="p">(</span><span class="s s-Atom">circle</span><span class="o">/</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">input_cw</span><span class="p">(</span><span class="s s-Atom">in</span><span class="o">/</span><span class="mi">2</span><span class="p">).</span>
<span class="nf">input_cw</span><span class="p">(</span><span class="s s-Atom">config</span><span class="o">/</span><span class="mi">2</span><span class="p">).</span>

<span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="s s-Atom">pos</span><span class="p">).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">triangle</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">square</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">circle</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">in</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">in</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">config</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">obj</span><span class="p">,</span><span class="s s-Atom">-#dir</span><span class="p">)).</span>
</pre></div>
</div>
<p>SLIPCOVER and LEMUR also require facts for the <code class="code docutils literal notranslate"><span class="pre">determination/2</span></code> Aleph-style predicate that indicate which predicates can appear in the body of clauses.
For example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">determination</span><span class="p">(</span><span class="s s-Atom">pos</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="s s-Atom">triangle</span><span class="o">/</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">determination</span><span class="p">(</span><span class="s s-Atom">pos</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="s s-Atom">square</span><span class="o">/</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">determination</span><span class="p">(</span><span class="s s-Atom">pos</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="s s-Atom">circle</span><span class="o">/</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">determination</span><span class="p">(</span><span class="s s-Atom">pos</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="s s-Atom">in</span><span class="o">/</span><span class="mi">2</span><span class="p">).</span>
<span class="nf">determination</span><span class="p">(</span><span class="s s-Atom">pos</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="s s-Atom">config</span><span class="o">/</span><span class="mi">2</span><span class="p">).</span>
</pre></div>
</div>
<p>state that <code class="code docutils literal notranslate"><span class="pre">triangle/1</span></code> can appear in the body of clauses for <code class="code docutils literal notranslate"><span class="pre">pos/0</span></code>.</p>
<p>SLIPCOVER and LEMUR also allow mode declarations of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">modeh</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">r&gt;</span><span class="p">,[</span><span class="o">&lt;</span><span class="s s-Atom">s1&gt;</span><span class="p">,...,</span><span class="o">&lt;</span><span class="s s-Atom">sn&gt;</span><span class="p">],[</span><span class="o">&lt;</span><span class="s s-Atom">a1&gt;</span><span class="p">,...,</span><span class="o">&lt;</span><span class="s s-Atom">an&gt;</span><span class="p">],[</span><span class="o">&lt;</span><span class="nv">P1</span><span class="o">/</span><span class="nv">Ar1</span><span class="s s-Atom">&gt;</span><span class="p">,...,</span><span class="o">&lt;</span><span class="nv">Pk</span><span class="o">/</span><span class="nv">Ark</span><span class="s s-Atom">&gt;</span><span class="p">]).</span>
</pre></div>
</div>
<p>These mode declarations are used to generate clauses with more than two head atoms.
In them, <code class="code docutils literal notranslate"><span class="pre">&lt;s1&gt;,...,&lt;sn&gt;</span></code> are schemas, <code class="code docutils literal notranslate"><span class="pre">&lt;a1&gt;,...,&lt;an&gt;</span></code> are atoms such that <code class="code docutils literal notranslate"><span class="pre">&lt;ai&gt;</span></code> is obtained from <code class="code docutils literal notranslate"><span class="pre">&lt;si&gt;</span></code> by replacing placemarkers with variables, <code class="code docutils literal notranslate"><span class="pre">&lt;Pi/Ari&gt;</span></code> are the predicates admitted in the body. <code class="code docutils literal notranslate"><span class="pre">&lt;a1&gt;,...,&lt;an&gt;</span></code> are used to indicate which variables should be shared by the atoms in the head.
An example of such a mode declaration (from <code class="code docutils literal notranslate"><span class="pre">uwcselearn.pl</span></code>) is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">modeh</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span>
<span class="p">[</span><span class="nf">advisedby</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">person</span><span class="p">,</span><span class="o">+</span><span class="s s-Atom">person</span><span class="p">),</span><span class="nf">tempadvisedby</span><span class="p">(</span><span class="o">+</span><span class="s s-Atom">person</span><span class="p">,</span><span class="o">+</span><span class="s s-Atom">person</span><span class="p">)],</span>
<span class="p">[</span><span class="nf">advisedby</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">),</span><span class="nf">tempadvisedby</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">)],</span>
<span class="p">[</span><span class="s s-Atom">professor</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="s s-Atom">student</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="s s-Atom">hasposition</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">inphase</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
<span class="s s-Atom">publication</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">taughtby</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="s s-Atom">ta</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="s s-Atom">courselevel</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">yearsinprogram</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>
</pre></div>
</div>
<p>If you want to specify negative literals for addition in the body of clauses, you should define a new predicate in the background as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">not_worn</span><span class="p">(</span><span class="nv">C</span><span class="p">)</span><span class="o">:-</span>
        <span class="nf">component</span><span class="p">(</span><span class="nv">C</span><span class="p">),</span>
        <span class="s s-Atom">\+</span> <span class="nf">worn</span><span class="p">(</span><span class="nv">C</span><span class="p">).</span>
<span class="nf">one_worn</span><span class="o">:-</span>
<span class="nf">worn</span><span class="p">(</span><span class="k">_</span><span class="p">).</span>
<span class="nf">none_worn</span><span class="o">:-</span>
<span class="s s-Atom">\+</span> <span class="s s-Atom">one_worn</span><span class="p">.</span>
</pre></div>
</div>
<p>from <a class="reference external" href="http://cplint.eu/e/mach.pl">mach.pl</a> and add the new predicate in a <code class="code docutils literal notranslate"><span class="pre">modeb/2</span></code> fact</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="nf">not_worn</span><span class="p">(</span><span class="o">-</span><span class="s s-Atom">comp</span><span class="p">)).</span>
<span class="nf">modeb</span><span class="p">(</span><span class="s s-Atom">*</span><span class="p">,</span><span class="s s-Atom">none_worn</span><span class="p">).</span>
</pre></div>
</div>
<p>Note that successful negative literals do not instantiate the variables, so if you want a variable appearing in a negative literal to be an output variable you must instantiate before calling the negative literals.
The new predicates must also be declared as input</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">input_cw</span><span class="p">(</span><span class="s s-Atom">not_worn</span><span class="o">/</span><span class="mi">1</span><span class="p">).</span>
<span class="nf">input_cw</span><span class="p">(</span><span class="s s-Atom">none_worn</span><span class="o">/</span><span class="mi">0</span><span class="p">).</span>
</pre></div>
</div>
<p>Lookahead can also be specified with facts of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">lookahead</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">literal&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">list</span> <span class="s s-Atom">of</span> <span class="s s-Atom">literals&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>In this case when a literal matching <code class="code docutils literal notranslate"><span class="pre">&lt;literal&gt;</span></code> is added to the body of clause during refinement, then also the literals matching <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> will be added. An example of such declaration (from <a class="reference external" href="http://cplint.eu/e/muta.pl">muta.pl</a>) is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">lookahead</span><span class="p">(</span><span class="nf">logp</span><span class="p">(</span><span class="k">_</span><span class="p">),[(</span><span class="k">_</span><span class="s s-Atom">=</span><span class="k">_</span><span class="p">))]).</span>
</pre></div>
</div>
<p>Note that <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> is copied with <code class="code docutils literal notranslate"><span class="pre">copy_term/2</span></code> before matching, so variables in common between <code class="code docutils literal notranslate"><span class="pre">&lt;literal&gt;</span></code> and <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> may not be in common in the refined clause.</p>
<p>It is also possible to specify that a literal can only be added together with other literals with facts of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">lookahead_cons</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">literal&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">list</span> <span class="s s-Atom">of</span> <span class="s s-Atom">literals&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>In this case <code class="code docutils literal notranslate"><span class="pre">&lt;literal&gt;</span></code> is added to the body of clause during refinement only together with literals matching <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code>.
An example of such declaration is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">lookahead_cons</span><span class="p">(</span><span class="nf">logp</span><span class="p">(</span><span class="k">_</span><span class="p">),[(</span><span class="k">_</span><span class="s s-Atom">=</span><span class="k">_</span><span class="p">))]).</span>
</pre></div>
</div>
<p>Also here <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> is copied with <code class="code docutils literal notranslate"><span class="pre">copy_term/2</span></code> before matching, so variables in common between <code class="code docutils literal notranslate"><span class="pre">&lt;literal&gt;</span></code> and <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> may not be in common in the refined clause.</p>
<p>Moreover, we can specify lookahead with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">lookahead_cons_var</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">literal&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">list</span> <span class="s s-Atom">of</span> <span class="s s-Atom">literals&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>In this case <code class="code docutils literal notranslate"><span class="pre">&lt;literal&gt;</span></code> is added to the body of clause during refinement only together with literals matching <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> and <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> is not copied before matching, so variables in common between <code class="code docutils literal notranslate"><span class="pre">&lt;literal&gt;</span></code> and <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">literals&gt;</span></code> are in common also in the refined clause. This is allowed only with <code class="code docutils literal notranslate"><span class="pre">specialization</span></code> set to <code class="code docutils literal notranslate"><span class="pre">bottom</span></code>.
An example of such declaration is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">lookahead_cons_var</span><span class="p">(</span><span class="nf">logp</span><span class="p">(</span><span class="nv">B</span><span class="p">),[(</span><span class="nv">B</span><span class="s s-Atom">=</span><span class="k">_</span><span class="p">))]).</span>
</pre></div>
</div>
</section>
<section id="example-interpretations">
<h4>Example Interpretations<a class="headerlink" href="#example-interpretations" title="Permalink to this headline">¶</a></h4>
<p>The last part of the file contains the data.
You can specify data with two modalities: models and keys.
In the models type, you specify an example model (or interpretation or megaexample) as a list of Prolog facts initiated by <code class="code docutils literal notranslate"><span class="pre">begin(model(&lt;name&gt;)).</span></code> and terminated by <code class="code docutils literal notranslate"><span class="pre">end(model(&lt;name&gt;)).</span></code> as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">begin</span><span class="p">(</span><span class="nf">model</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span>
<span class="s s-Atom">pos</span><span class="p">.</span>
<span class="nf">triangle</span><span class="p">(</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="s s-Atom">o5</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">square</span><span class="p">(</span><span class="s s-Atom">o4</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="s s-Atom">o4</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">circle</span><span class="p">(</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="s s-Atom">o2</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="s s-Atom">o1</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="s s-Atom">o1</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">end</span><span class="p">(</span><span class="nf">model</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span>
</pre></div>
</div>
<p>The interpretations may contain a fact of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">prob</span><span class="p">(</span><span class="mf">0.3</span><span class="p">).</span>
</pre></div>
</div>
<p>assigning a probability (0.3 in this case) to the interpretations.
If this is omitted, the probability of each interpretation is considered equal to <span class="math notranslate nohighlight">\(1/n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the total number of interpretations. <code class="code docutils literal notranslate"><span class="pre">prob/1</span></code> can be used to set a different multiplicity for the interpretations.</p>
<p>The facts in the interpretation are loaded in SWI-Prolog database by adding an extra initial argument equal to the name of the model.
After each interpretation is loaded, a fact of the form <code class="code docutils literal notranslate"><span class="pre">int(&lt;id&gt;)</span></code> is asserted, where <code class="code docutils literal notranslate"><span class="pre">id</span></code> is the name of the interpretation.
This can be used in order to retrieve the list of interpretations.</p>
<p>Alternatively, with the keys modality, you can directly write the facts and the first argument will be interpreted as a model identifier.
The above interpretation in the keys modality is</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">square</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o4</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o4</span><span class="p">,</span><span class="s s-Atom">o5</span><span class="p">).</span>
<span class="nf">circle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o2</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
<span class="nf">in</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o2</span><span class="p">,</span><span class="s s-Atom">o3</span><span class="p">).</span>
<span class="nf">triangle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o1</span><span class="p">).</span>
<span class="nf">config</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s s-Atom">o1</span><span class="p">,</span><span class="s s-Atom">up</span><span class="p">).</span>
</pre></div>
</div>
<p>which is contained in the <a class="reference external" href="http://cplint.eu/e/bongardkeys.pl">bongardkeys.pl</a>.
This is also how model <code class="code docutils literal notranslate"><span class="pre">2</span></code> above is stored in SWI-Prolog database.
The two modalities, models and keys, can be mixed in the same file.
Facts for <code class="code docutils literal notranslate"><span class="pre">int/1</span></code> are not asserted for interpretations in the key modality but can be added by the user explicitly.</p>
<p>Note that you can add background knowledge that is not probabilistic directly to the file writing the clauses taking into account the model argument.
For example (<code class="code docutils literal notranslate"><span class="pre">carc.pl</span></code>) contains</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">connected</span><span class="p">(</span><span class="k">_</span><span class="nv">M</span><span class="p">,</span><span class="nv">Ring1</span><span class="p">,</span><span class="nv">Ring2</span><span class="p">)</span><span class="o">:-</span>
        <span class="nv">Ring1</span> <span class="s s-Atom">\=</span> <span class="nv">Ring2</span><span class="p">,</span>
        <span class="nf">member</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">Ring1</span><span class="p">),</span>
        <span class="nf">member</span><span class="p">(</span><span class="nv">A</span><span class="p">,</span><span class="nv">Ring2</span><span class="p">),</span> <span class="p">!.</span>

<span class="nf">symbond</span><span class="p">(</span><span class="nv">Mod</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">T</span><span class="p">)</span><span class="o">:-</span> <span class="nf">bond</span><span class="p">(</span><span class="nv">Mod</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">T</span><span class="p">).</span>
<span class="nf">symbond</span><span class="p">(</span><span class="nv">Mod</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">T</span><span class="p">)</span><span class="o">:-</span> <span class="nf">bond</span><span class="p">(</span><span class="nv">Mod</span><span class="p">,</span><span class="nv">B</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<p>where the first argument of all the atoms is the model.</p>
<p>Example <a class="reference external" href="http://cplint.eu/e/registration.pl">registration.pl</a> contains for example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">party</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="nv">P</span><span class="p">)</span><span class="o">:-</span>
<span class="nf">participant</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="k">_</span><span class="p">,</span> <span class="k">_</span><span class="p">,</span> <span class="nv">P</span><span class="p">,</span> <span class="k">_</span><span class="p">).</span>
</pre></div>
</div>
<p>that defines intensionally the target predicate <code class="code docutils literal notranslate"><span class="pre">party/1</span></code>. Here <code class="code docutils literal notranslate"><span class="pre">M</span></code> is the model and <code class="code docutils literal notranslate"><span class="pre">participant/4</span></code> is defined in the interpretations.
You can also define intensionally the negative examples with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">neg</span><span class="p">(</span><span class="nf">party</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="s s-Atom">yes</span><span class="p">))</span><span class="o">:-</span> <span class="nf">party</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="s s-Atom">no</span><span class="p">).</span>
<span class="nf">neg</span><span class="p">(</span><span class="nf">party</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="s s-Atom">no</span><span class="p">))</span><span class="o">:-</span> <span class="nf">party</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="s s-Atom">yes</span><span class="p">).</span>
</pre></div>
</div>
<p>Then you must indicate how the examples are divided in folds with facts of the form: <code class="code docutils literal notranslate"><span class="pre">fold(&lt;fold_name&gt;,&lt;list</span> <span class="pre">of</span> <span class="pre">model</span> <span class="pre">identifiers&gt;)</span></code>, as for example</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">train</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,...]).</span>
<span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">test</span><span class="p">,[</span><span class="mi">490</span><span class="p">,</span><span class="mi">491</span><span class="p">,...]).</span>
</pre></div>
</div>
<p>As the input file is a Prolog program, you can define intensionally the folds as in</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">all</span><span class="p">,</span><span class="nv">F</span><span class="p">)</span><span class="o">:-</span>
<span class="nf">findall</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span><span class="nf">int</span><span class="p">(</span><span class="nv">I</span><span class="p">),</span><span class="nv">F</span><span class="p">).</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">fold/2</span></code> is dynamic so you can also write (<a class="reference external" href="http://cplint.eu/e/registration.pl">registration.pl</a>)</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">all</span><span class="p">,</span><span class="nv">F</span><span class="p">),</span>
        <span class="nf">sample</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="nv">F</span><span class="p">,</span><span class="nv">FTr</span><span class="p">,</span><span class="nv">FTe</span><span class="p">),</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">rand_train</span><span class="p">,</span><span class="nv">FTr</span><span class="p">)),</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">fold</span><span class="p">(</span><span class="s s-Atom">rand_test</span><span class="p">,</span><span class="nv">FTe</span><span class="p">)).</span>
</pre></div>
</div>
<p>which however must be inserted after the input interpretations otherwise the facts for <code class="code docutils literal notranslate"><span class="pre">int/1</span></code> will not be available and the fold <code class="code docutils literal notranslate"><span class="pre">all</span></code> would be empty.
This command uses <code class="code docutils literal notranslate"><span class="pre">sample(N,List,Sampled,Rest)</span></code> exported from <code class="code docutils literal notranslate"><span class="pre">slipcover</span></code> that samples <code class="code docutils literal notranslate"><span class="pre">N</span></code> elements from <code class="code docutils literal notranslate"><span class="pre">List</span></code> and returns the sampled elements in <code class="code docutils literal notranslate"><span class="pre">Sampled</span></code> and the rest in <code class="code docutils literal notranslate"><span class="pre">Rest</span></code>.
If <code class="code docutils literal notranslate"><span class="pre">List</span></code> has <code class="code docutils literal notranslate"><span class="pre">N</span></code> elements or less, <code class="code docutils literal notranslate"><span class="pre">Sampled</span></code> is equal to <code class="code docutils literal notranslate"><span class="pre">List</span></code> and <code class="code docutils literal notranslate"><span class="pre">Rest</span></code> is empty.</p>
</section>
</section>
<section id="commands">
<h3>Commands<a class="headerlink" href="#commands" title="Permalink to this headline">¶</a></h3>
<section id="parameter-learning">
<h4>Parameter Learning<a class="headerlink" href="#parameter-learning" title="Permalink to this headline">¶</a></h4>
<p>To execute EMBLEM, prepare an input file in the editor panel as indicated above and call</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce_par</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">list</span> <span class="s s-Atom">of</span> <span class="s s-Atom">folds&gt;</span><span class="p">,</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">folds&gt;</span></code> is a list of the folds for training and <code class="code docutils literal notranslate"><span class="pre">P</span></code> will contain the input program with updated parameters.</p>
<p>For example <a class="reference external" href="http://cplint.eu/e/bongard.pl">bongard.pl</a>, you can perform parameter learning on the <code class="code docutils literal notranslate"><span class="pre">train</span></code> fold with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce_par</span><span class="p">([</span><span class="s s-Atom">train</span><span class="p">],</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
</section>
<section id="structure-learning">
<h4>Structure Learning<a class="headerlink" href="#structure-learning" title="Permalink to this headline">¶</a></h4>
<p>To execute SLIPCOVER, prepare an input file in the editor panel as indicated above and call</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">induce</span><span class="p">(</span><span class="o">+</span><span class="nv">List_of_folds</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">P</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">List_of_folds</span></code> is a list of the folds for training and <code class="code docutils literal notranslate"><span class="pre">P</span></code> will contain the learned program.</p>
<p>For example <a class="reference external" href="http://cplint.eu/e/bongard.pl">bongard.pl</a>, you can perform structure learning on the <code class="code docutils literal notranslate"><span class="pre">train</span></code> fold with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce</span><span class="p">([</span><span class="s s-Atom">train</span><span class="p">],</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>A program can also be tested on a test set with <code class="code docutils literal notranslate"><span class="pre">test/7</span></code> or <code class="code docutils literal notranslate"><span class="pre">test_prob/6</span></code> as described below.</p>
<p>Between two executions of <code class="code docutils literal notranslate"><span class="pre">induce/2</span></code> you should exit SWI-Prolog to have a clean database.</p>
<p>To execute LEMUR, prepare an input file in the editor panel as indicated above and call</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">induce_lm</span><span class="p">(</span><span class="o">+</span><span class="nv">List_of_folds</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">P</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">List_of_folds</span></code> is a list of the folds for training and <code class="code docutils literal notranslate"><span class="pre">P</span></code> will contain the learned program.</p>
<p>For example <a class="reference external" href="http://cplint.eu/example/lemur/bongard.pl">bongard.pl</a>, you can perform structure learning on the <code class="code docutils literal notranslate"><span class="pre">train</span></code> fold with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce_lm</span><span class="p">([</span><span class="s s-Atom">train</span><span class="p">],</span><span class="nv">P</span><span class="p">).</span>
</pre></div>
</div>
<p>Between two executions of <code class="code docutils literal notranslate"><span class="pre">induce_lm/2</span></code> you should exit SWI-Prolog to have a clean database.</p>
</section>
<section id="testing">
<h4>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h4>
<p>A program can be tested on a test set in SLIPCOVER and LEMUR with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span><span class="p">(</span><span class="o">+</span><span class="nv">Program</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">List_of_folds</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">LL</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCROC</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">ROC</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCPR</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">PR</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">test_prob</span><span class="p">(</span><span class="o">+</span><span class="nv">Program</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">List_of_folds</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">NPos</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">NNeg</span><span class="o">:</span><span class="s s-Atom">int</span><span class="p">,</span><span class="o">-</span><span class="nv">LL</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">ExampleList</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>where <code class="code docutils literal notranslate"><span class="pre">Program</span></code> is a list of terms representing clauses and <code class="code docutils literal notranslate"><span class="pre">List_of_folds</span></code> is a list of folds.</p>
<p><code class="code docutils literal notranslate"><span class="pre">test/7</span></code> returns the log likelihood of the test examples in <code class="code docutils literal notranslate"><span class="pre">LL</span></code>, the Area Under the ROC curve in <code class="code docutils literal notranslate"><span class="pre">AUCROC</span></code>, a dictionary containing the list of points (in the form of Prolog pairs <code class="code docutils literal notranslate"><span class="pre">x-y</span></code>) of the ROC curve in <code class="code docutils literal notranslate"><span class="pre">ROC</span></code>, the Area Under the PR curve in <code class="code docutils literal notranslate"><span class="pre">AUCPR</span></code>, a dictionary containing the list of points of the PR curve in <code class="code docutils literal notranslate"><span class="pre">PR</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">test_prob/6</span></code> returns the log likelihood of the test examples in <code class="code docutils literal notranslate"><span class="pre">LL</span></code>, the numbers of positive and negative examples in <code class="code docutils literal notranslate"><span class="pre">NPos</span></code> and <code class="code docutils literal notranslate"><span class="pre">NNeg</span></code> and the list <code class="code docutils literal notranslate"><span class="pre">ExampleList</span></code> containing pairs <code class="code docutils literal notranslate"><span class="pre">Prob-Ex</span></code> where <code class="code docutils literal notranslate"><span class="pre">Ex</span></code> is <code class="code docutils literal notranslate"><span class="pre">a</span></code> for <code class="code docutils literal notranslate"><span class="pre">a</span></code> a positive example and <code class="code docutils literal notranslate"><span class="pre">\+(a)</span></code> for <code class="code docutils literal notranslate"><span class="pre">a</span></code> a negative example and <code class="code docutils literal notranslate"><span class="pre">Prob</span></code> is the probability of example <code class="code docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Then you can draw the curves in <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH using C3.js using</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">compute_areas_diagrams</span><span class="p">(</span><span class="o">+</span><span class="nv">ExampleList</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCROC</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">ROC</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCPR</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">PR</span><span class="o">:</span><span class="s s-Atom">dict</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>(from pack <a class="reference external" href="http://www.swi-prolog.org/pack/list?p=auc">auc.pl</a>) that takes as input a list <code class="code docutils literal notranslate"><span class="pre">ExampleList</span></code> of pairs probability-literal of the form that is returned by <code class="code docutils literal notranslate"><span class="pre">test_prob/6</span></code>.</p>
<p>For example, to test on fold <code class="code docutils literal notranslate"><span class="pre">test</span></code> the program learned on fold <code class="code docutils literal notranslate"><span class="pre">train</span></code> you can run the query</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">induce_par</span><span class="p">([</span><span class="s s-Atom">train</span><span class="p">],</span><span class="nv">P</span><span class="p">),</span>
<span class="nf">test</span><span class="p">(</span><span class="nv">P</span><span class="p">,[</span><span class="s s-Atom">test</span><span class="p">],</span><span class="nv">LL</span><span class="p">,</span><span class="nv">AUCROC</span><span class="p">,</span><span class="nv">ROC</span><span class="p">,</span><span class="nv">AUCPR</span><span class="p">,</span><span class="nv">PR</span><span class="p">).</span>
</pre></div>
</div>
<p>Or you can test the input program on the fold <code class="code docutils literal notranslate"><span class="pre">test</span></code> with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="nf">in</span><span class="p">(</span><span class="nv">P</span><span class="p">),</span><span class="nf">test</span><span class="p">(</span><span class="nv">P</span><span class="p">,[</span><span class="s s-Atom">test</span><span class="p">],</span><span class="nv">LL</span><span class="p">,</span><span class="nv">AUCROC</span><span class="p">,</span><span class="nv">ROC</span><span class="p">,</span><span class="nv">AUCPR</span><span class="p">,</span><span class="nv">PR</span><span class="p">).</span>
</pre></div>
</div>
<p>In <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH, by including</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_rendering</span><span class="p">(</span><span class="s s-Atom">c3</span><span class="p">).</span>
<span class="o">:-</span> <span class="nf">use_rendering</span><span class="p">(</span><span class="s s-Atom">lpad</span><span class="p">).</span>
</pre></div>
</div>
<p>in the code before <code class="code docutils literal notranslate"><span class="pre">:-</span> <span class="pre">sc.</span></code> the curves will be shown as graphs using C3.js and the output program will be pretty printed.</p>
<p>You can also draw the curves in <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH using R by loading library <code class="code docutils literal notranslate"><span class="pre">cplint_r</span></code> with</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">use_module</span><span class="p">(</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">cplint_r</span><span class="p">)).</span>
</pre></div>
</div>
<p>and using</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">test_r</span><span class="p">(</span><span class="o">+</span><span class="nv">Program</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">+</span><span class="nv">List_of_folds</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">LL</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCROC</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCPR</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>or predicate</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="nf">compute_areas_diagrams_r</span><span class="p">(</span><span class="o">+</span><span class="nv">ExampleList</span><span class="o">:</span><span class="s s-Atom">list</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCROC</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">,</span><span class="o">-</span><span class="nv">AUCPR</span><span class="o">:</span><span class="s s-Atom">float</span><span class="p">)</span> <span class="o">is</span> <span class="s s-Atom">det</span>
</pre></div>
</div>
<p>that takes as input a list <code class="code docutils literal notranslate"><span class="pre">ExampleList</span></code> of pairs probability-literal of the form that is returned by <code class="code docutils literal notranslate"><span class="pre">test_prob/6</span></code>.</p>
</section>
</section>
<section id="parameters-for-learning">
<h3>Parameters for Learning<a class="headerlink" href="#parameters-for-learning" title="Permalink to this headline">¶</a></h3>
<p>Parameters are set with commands of the form</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="o">:-</span> <span class="nf">set_sc</span><span class="p">(</span><span class="o">&lt;</span><span class="s s-Atom">parameter&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="s s-Atom">value&gt;</span><span class="p">).</span>
</pre></div>
</div>
<p>The available parameters are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">specialization</span></code>: (values: <code class="code docutils literal notranslate"><span class="pre">{bottom,mode}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">bottom</span></code>, valid for SLIPCOVER) specialization mode.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">depth_bound</span></code>: (values: <code class="code docutils literal notranslate"><span class="pre">{true,false}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">true</span></code>) if <code class="code docutils literal notranslate"><span class="pre">true</span></code>, the depth of the derivation of the goal is limited to the value of the <code class="code docutils literal notranslate"><span class="pre">depth</span></code> parameter.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">depth</span></code> (values: integer, default value: 2): depth of derivations if <code class="code docutils literal notranslate"><span class="pre">depth_bound</span></code> is set to <code class="code docutils literal notranslate"><span class="pre">true</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">single_var</span></code> (values: <code class="code docutils literal notranslate"><span class="pre">{true,false}</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">false</span></code>): if set to <code class="code docutils literal notranslate"><span class="pre">true</span></code>, there is a random variable for each clause, instead of a different random variable for each grounding of each clause</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">epsilon_em</span></code> (values: real, default value: 0.1): if the difference in the log likelihood in two successive parameter EM iteration is smaller than <code class="code docutils literal notranslate"><span class="pre">epsilon_em</span></code>, then EM stops</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">epsilon_em_fraction</span></code> (values: real, default value: 0.01): if the difference in the log likelihood in two successive parameter EM iteration is smaller than <code class="code docutils literal notranslate"><span class="pre">epsilon_em_fraction*(-current</span> <span class="pre">log</span> <span class="pre">likelihood)</span></code>, then EM stops</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">iter</span></code> (values: integer, defualt value: 1): maximum number of iteration of EM parameter learning. If set to -1, no maximum number of iterations is imposed</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">iterREF</span></code> (values: integer, defualt value: 1, valid for SLIPCOVER and LEMUR): maximum number of iteration of EM parameter learning for refinements. If set to -1, no maximum number of iterations is imposed.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">random_restarts_number</span></code> (values: integer, default value: 1, valid for EMBLEM, SLIPCOVER and LEMUR): number of random restarts of parameter EM learning</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">random_restarts_REFnumber</span></code> (values: integer, default value: 1, valid for SLIPCOVER and LEMUR): number of random restarts of parameter EM learning for refinements</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">seed</span></code> (values: seed(integer) or seed(random), default value <code class="code docutils literal notranslate"><span class="pre">seed(3032)</span></code>): seed for the Prolog random functions, see <a class="reference external" href="http://www.swi-prolog.org/pldoc/man?predicate=set_random/1">SWI-Prolog manual</a></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">c_seed</span></code> (values: unsigned integer, default value 21344)): seed for the C random functions</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">logzero</span></code> (values: negative real, default value <span class="math notranslate nohighlight">\(\log(0.000001)\)</span>: value assigned to <span class="math notranslate nohighlight">\(\log(0)\)</span></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_iter</span></code> (values: integer, default value: 10, valid for SLIPCOVER): number of interations of beam search</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_var</span></code> (values: integer, default value: 4, valid for SLIPCOVER and LEMUR): maximum number of distinct variables in a clause</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">beamsize</span></code> (values: integer, default value: 100, valid for SLIPCOVER): size of the beam</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">megaex_bottom</span></code> (values: integer, default value: 1, valid for SLIPCOVER): number of mega-examples on which to build the bottom clauses</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">initial_clauses_per_megaex</span></code> (values: integer, default value: 1, valid for SLIPCOVER): number of bottom clauses to build for each mega-example (or model or interpretation)</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">d</span></code> (values: integer, default value: 1, valid for SLIPCOVER): number of saturation steps when building the bottom clause</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mcts_beamsize</span></code> (values: integer, default value: 3, valid for LEMUR): size of the Monte-Carlo tree search beam</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mcts_visits</span></code> (values: integer, default value: +1e20, valid for LEMUR): maximum number of visits</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">max_iter_structure</span></code> (values: integer, default value: 10000, valid for SLIPCOVER): maximum number of theory search iterations</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">background_clauses</span></code> (values: integer, default value: 50, valid for SLIPCOVER): maximum numbers of background clauses</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">maxdepth_var</span></code> (values: integer, default value: 2, valid for SLIPCOVER and LEMUR): maximum depth of variables in clauses (as defined in <span id="id43">[<a class="reference internal" href="#id66" title="William W. Cohen. Pac-learning non-recursive prolog clauses. Artif. Intell., 79(1):1-38, 1995.">Coh95</a>]</span>).</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mcts_max_depth</span></code> (values: integer, default value: 8, valid for LEMUR): maximum depth of default policy search</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mcts_c</span></code> (values: real, default value: 0.7, valid for LEMUR): value of parameter <span class="math notranslate nohighlight">\(C\)</span> in the computation of UCT</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mcts_iter</span></code> (values: integer, default value: 20, valid for LEMUR): number of Monte-Carlo tree search iterations</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">mcts_maxrestarts</span></code> (values: integer, default value: 20, valid for LEMUR): maximum number of Monte-Carlo tree search restarts</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">neg_ex</span></code> (values: <code class="code docutils literal notranslate"><span class="pre">given</span></code>, <code class="code docutils literal notranslate"><span class="pre">cw</span></code>, default value: <code class="code docutils literal notranslate"><span class="pre">cw</span></code>): if set to <code class="code docutils literal notranslate"><span class="pre">given</span></code>, the negative examples in training and testing are taken from the test folds interpretations, i.e., those examples <code class="code docutils literal notranslate"><span class="pre">ex</span></code> stored as <code class="code docutils literal notranslate"><span class="pre">neg(ex)</span></code>; if set to <code class="code docutils literal notranslate"><span class="pre">cw</span></code>, the negative examples in training and testing are generated according to the closed world assumption, i.e., all atoms for target predicates that are not positive examples. The set of all atoms is obtained by collecting the set of constants for each type of the arguments of the target predicate, so the target predicates must have at least one fact for <code class="code docutils literal notranslate"><span class="pre">modeh/2</span></code> or <code class="code docutils literal notranslate"><span class="pre">modebb/2</span></code> also for parameter learning.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">alpha</span></code> (values: floating point <span class="math notranslate nohighlight">\(\geq 0\)</span>, default value: 0): parameter of the symmetric Dirichlet distribution used to initialize the parameters. If it takes value 0, a truncated Dirichlet process is used to sample parameters: the probability of being true of each Boolean random variable used to represent multivalued random variables is sampled uniformly and independently in [0,1]. If it takes a value <span class="math notranslate nohighlight">\(\geq 0\)</span>, the parameters are sampled from a symmetric Dirichlet distribution, i.e. a Dirichlet distribution with vector of parameters <span class="math notranslate nohighlight">\(\alpha,\ldots,\alpha\)</span>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">verbosity</span></code> (values: integer in [1,3], default value: 1): level of verbosity of the algorithms.</p></li>
</ul>
</section>
</section>
<section id="download-query-results-through-an-api">
<h2>Download Query Results through an API<a class="headerlink" href="#download-query-results-through-an-api" title="Permalink to this headline">¶</a></h2>
<p>In cplint on SWISH the results of queries can also be downloaded programmatically by directly approaching the Pengine API.
Example client code is <a class="reference external" href="https://github.com/friguzzi/swish/tree/master/client">available</a>.
For example, the <code class="code docutils literal notranslate"><span class="pre">swish-ask.sh</span></code> client can be used with bash to download the results for a query in CSV.</p>
<p>The call below downloads a CSV file for the coin example</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>bash swish-ask.sh --server<span class="o">=</span>http://cplint.eu e/coin.pl Prob <span class="s2">&quot;prob(heads(coin),Prob)&quot;</span>
</pre></div>
</div>
<p>The script can ask queries against Prolog scripts stored in <a class="reference external" href="http://cplint.eu">http://cplint.eu</a> by specifying the script on the commandline.
User defined files stored in <code class="code docutils literal notranslate"><span class="pre">cplint</span></code> on SWISH (locations of type <a class="reference external" href="http://cplint.eu/p/coin_user.pl">http://cplint.eu/p/coin_user.pl</a>) can be directly used, for example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>bash swish-ask.sh --server<span class="o">=</span>http://cplint.eu coin_user.pl Prob <span class="s2">&quot;prob(heads(coin),Prob)&quot;</span>
</pre></div>
</div>
<p>Example programs can be used by specifying the folder portion of the url of the example, as in the first coin example above where the url for the program is <a class="reference external" href="http://cplint.eu/e/coin.pl">http://cplint.eu/e/coin.pl</a>.</p>
<p>You can also use an url for the program as in</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>bash swish-ask.sh --server<span class="o">=</span>http://cplint.eu <span class="se">\</span>
https://raw.githubusercontent.com/friguzzi/swish/<span class="se">\</span>
master/e/coin.pl Prob <span class="s2">&quot;prob(heads(coin),Prob)&quot;</span>
</pre></div>
</div>
<p>Results can be downloaded in JSON using the option <code class="code docutils literal notranslate"><span class="pre">--json-s</span></code> or <code class="code docutils literal notranslate"><span class="pre">--json-html</span></code>. With the first the output is in a simple string format where Prolog terms are sent using quoted write, the latter serialize responses as HTML strings.
E.g.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>bash swish-ask.sh --json-s --server<span class="o">=</span>http://cplint.eu <span class="se">\</span>
        coin_user.pl Prob <span class="s2">&quot;prob(heads(coin),Prob)&quot;</span>
</pre></div>
</div>
<p>The JSON format can also be modified.
See <a class="reference external" href="http://www.swi-prolog.org/pldoc/doc_for?object=pengines%3Aevent_to_json/4">http://www.swi-prolog.org/pldoc/doc_for?object=pengines%3Aevent_to_json/4</a>.</p>
<p>Prolog can exploit the Pengine API directly. For example, the above can be called as:</p>
<div class="highlight-cplint notranslate"><div class="highlight"><pre><span></span><span class="s s-Atom">?-</span> <span class="p">[</span><span class="nf">library</span><span class="p">(</span><span class="s s-Atom">pengines</span><span class="p">)].</span>
<span class="s s-Atom">?-</span> <span class="nf">pengine_rpc</span><span class="p">(</span><span class="s s-Atom">&#39;http://cplint.eu&#39;</span><span class="p">,</span>
        <span class="nf">prob</span><span class="p">(</span><span class="nf">heads</span><span class="p">(</span><span class="s s-Atom">coin</span><span class="p">),</span><span class="nv">Prob</span><span class="p">),</span>
        <span class="p">[</span> <span class="nf">src_url</span><span class="p">(</span><span class="s s-Atom">&#39;https://raw.githubusercontent.com/friguzzi/swish/\</span>
<span class="s s-Atom">                master/e/coin.pl&#39;</span><span class="p">),</span>
                <span class="nf">application</span><span class="p">(</span><span class="s s-Atom">swish</span><span class="p">)</span>
<span class="p">]).</span>

<span class="nv">Prob</span> <span class="o">=</span> <span class="mf">0.51</span><span class="p">.</span>
</pre></div>
</div>
</section>
<section id="example-files">
<h2>Example Files<a class="headerlink" href="#example-files" title="Permalink to this headline">¶</a></h2>
<p>The <code class="code docutils literal notranslate"><span class="pre">pack/cplint/prolog/examples</span></code> folder in SWI-Prolog home contains some example programs.
The subfolder <code class="code docutils literal notranslate"><span class="pre">learning</span></code> contains some learning examples.
The <code class="code docutils literal notranslate"><span class="pre">pack/cplint/docs</span></code> folder contains this manual in latex, html and pdf.</p>
</section>
<section id="manual-in-pdf">
<h2>Manual in PDF<a class="headerlink" href="#manual-in-pdf" title="Permalink to this headline">¶</a></h2>
<p>A PDF version of the manual is available at <a class="reference external" href="http://friguzzi.github.io/cplint/_build/latex/cplint.pdf">http://friguzzi.github.io/cplint/_build/latex/cplint.pdf</a>.</p>
</section>
<section id="license">
<h2>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<p>cplint follows the Artistic License 2.0 that you can find in cplint root folder.
The copyright is by Fabrizio Riguzzi.</p>
<p>The library <a class="reference external" href="http://web.mit.edu/sage/export/tmp/y/usr/share/doc/polybori/cudd/cuddIntro.html">CUDD</a> for manipulating BDDs has the following license:</p>
<p>Copyright (c) 1995-2004, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:</p>
<ul class="simple">
<li><p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p></li>
<li><p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p></li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
“AS IS” AND ANY EXPRESS OR IMPLIED WARRAN-TIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="id45"><dl class="citation">
<dt class="label" id="id47"><span class="brackets"><a class="fn-backref" href="#id29">BARZ20</a></span></dt>
<dd><p>Elena Bellodi, Marco Alberti, Fabrizio Riguzzi, and Riccardo Zese. MAP inference for probabilistic logic programming. <em>Theory and Practice of Logic Programming</em>, 20(5):641â€“655, 2020. URL: <a class="reference external" href="https://arxiv.org/abs/2008.01394">https://arxiv.org/abs/2008.01394</a>, <a class="reference external" href="https://doi.org/10.1017/S1471068420000174">doi:10.1017/S1471068420000174</a>.</p>
</dd>
<dt class="label" id="id62"><span class="brackets"><a class="fn-backref" href="#id37">BR11</a></span></dt>
<dd><p>Elena Bellodi and Fabrizio Riguzzi. EM over binary decision diagrams for probabilistic logic programs. Technical Report CS-2011-01, Dipartimento di Ingegneria, Università di Ferrara, Italy, 2011. URL: <a class="reference external" href="http://ml.unife.it/wp-content/uploads/Papers/BelRig-CILC11.pdf">http://ml.unife.it/wp-content/uploads/Papers/BelRig-CILC11.pdf</a>.</p>
</dd>
<dt class="label" id="id67"><span class="brackets"><a class="fn-backref" href="#id37">BR13a</a></span></dt>
<dd><p>Elena Bellodi and Fabrizio Riguzzi. Expectation maximization over binary decision diagrams for probabilistic logic programs. <em>Intelligent Data Analysis</em>, 17(2):343–363, 2013.</p>
</dd>
<dt class="label" id="id61"><span class="brackets"><a class="fn-backref" href="#id37">BR13b</a></span></dt>
<dd><p>Elena Bellodi and Fabrizio Riguzzi. Expectation Maximization over binary decision diagrams for probabilistic logic programs. <em>Intelligent Data Analysis</em>, 17(2):343–363, 2013. URL: <a class="reference external" href="http://ds.ing.unife.it/~friguzzi/Papers/BelRig13-IDA-IJ.pdf">http://ds.ing.unife.it/~friguzzi/Papers/BelRig13-IDA-IJ.pdf</a>.</p>
</dd>
<dt class="label" id="id63"><span class="brackets"><a class="fn-backref" href="#id38">BR15</a></span></dt>
<dd><p>Elena Bellodi and Fabrizio Riguzzi. Structure learning of probabilistic logic programs by searching the clause space. <em>Theory and Practice of Logic Programming</em>, 15(2):169–212, 2015. URL: <a class="reference external" href="http://arxiv.org/abs/1309.2080">http://arxiv.org/abs/1309.2080</a>, <a class="reference external" href="https://doi.org/10.1017/S1471068413000689">doi:10.1017/S1471068413000689</a>.</p>
</dd>
<dt class="label" id="id66"><span class="brackets"><a class="fn-backref" href="#id43">Coh95</a></span></dt>
<dd><p>William W. Cohen. Pac-learning non-recursive prolog clauses. <em>Artif. Intell.</em>, 79(1):1–38, 1995.</p>
</dd>
<dt class="label" id="id49"><span class="brackets"><a class="fn-backref" href="#id6">DRKT07</a></span></dt>
<dd><p>L. De Raedt, A. Kimmig, and H. Toivonen. ProbLog: a probabilistic Prolog and its application in link discovery. In <em>International Joint Conference on Artificial Intelligence</em>, 2462–2467. 2007.</p>
</dd>
<dt class="label" id="id65"><span class="brackets"><a class="fn-backref" href="#id40">DRVL95</a></span></dt>
<dd><p>L. De Raedt and W. Van Laer. Inductive constraint logic. In <em>Proceedings of the 6th Conference on Algorithmic Learning Theory (ALT 1995)</em>, volume 997 of LNAI, 80–94. Fukuoka, Japan, 1995. Springer.</p>
</dd>
<dt class="label" id="id64"><span class="brackets"><a class="fn-backref" href="#id39">DMBR15</a></span></dt>
<dd><p>Nicola Di Mauro, Elena Bellodi, and Fabrizio Riguzzi. Bandit-based Monte-Carlo structure learning of probabilistic logic programs. <em>Mach. Learn.</em>, 100(1):127–156, July 2015. URL: <a class="reference external" href="http://ds.ing.unife.it/~friguzzi/Papers/DiMBelRig-ML15.pdf">http://ds.ing.unife.it/~friguzzi/Papers/DiMBelRig-ML15.pdf</a>, <a class="reference external" href="https://doi.org/10.1007/s10994-015-5510-3">doi:10.1007/s10994-015-5510-3</a>.</p>
</dd>
<dt class="label" id="id59"><span class="brackets"><a class="fn-backref" href="#id26">FC90</a></span></dt>
<dd><p>Robert M Fung and Kuo-Chu Chang. Weighing and integrating evidence for stochastic simulation in bayesian networks. In <em>Fifth Annual Conference on Uncertainty in Artificial Intelligence</em>, 209–220. North-Holland Publishing Co., 1990.</p>
</dd>
<dt class="label" id="id54"><span class="brackets"><a class="fn-backref" href="#id10">IRR12</a></span></dt>
<dd><p>Muhammad Asiful Islam, CR Ramakrishnan, and IV Ramakrishnan. Inference in probabilistic logic programs with continuous random variables. <em>Theory and Practice of Logic Programming</em>, 12:505–523, 7 2012. <a class="reference external" href="https://doi.org/10.1017/S1471068412000154">doi:10.1017/S1471068412000154</a>.</p>
</dd>
<dt class="label" id="id58"><span class="brackets">NR14</span><span class="fn-backref">(<a href="#id19">1</a>,<a href="#id20">2</a>,<a href="#id21">3</a>)</span></dt>
<dd><p>Arun Nampally and CR Ramakrishnan. Adaptive mcmc-based inference in probabilistic logic programs. <em>arXiv preprint arXiv:1403.6036</em>, 2014. URL: <a class="reference external" href="http://arxiv.org/pdf/1403.6036.pdf">http://arxiv.org/pdf/1403.6036.pdf</a>.</p>
</dd>
<dt class="label" id="id51"><span class="brackets">NDLDR16</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>Davide Nitti, Tinne De Laet, and Luc De Raedt. Probabilistic logic programming for hybrid relational domains. <em>Mach. Learn.</em>, 103(3):407–449, 2016. URL: <a class="reference external" href="http://dx.doi.org/10.1007/s10994-016-5558-8">http://dx.doi.org/10.1007/s10994-016-5558-8</a>, <a class="reference external" href="https://doi.org/10.1007/s10994-016-5558-8">doi:10.1007/s10994-016-5558-8</a>.</p>
</dd>
<dt class="label" id="id60"><span class="brackets"><a class="fn-backref" href="#id31">Pea00</a></span></dt>
<dd><p>J. Pearl. <em>Causality</em>. Cambridge University Press, 2000.</p>
</dd>
<dt class="label" id="id52"><span class="brackets"><a class="fn-backref" href="#id9">Poo97</a></span></dt>
<dd><p>David Poole. The independent choice logic for modelling multiple agents under uncertainty. <em>Artificial Intelligence</em>, 94(1-2):7–56, 1997.</p>
</dd>
<dt class="label" id="id56"><span class="brackets"><a class="fn-backref" href="#id14">Rig13</a></span></dt>
<dd><p>Fabrizio Riguzzi. MCINTYRE: a Monte Carlo system for probabilistic logic programming. <em>Fundamenta Informaticae</em>, 124(4):521–541, 2013. URL: <a class="reference external" href="http://ds.ing.unife.it/~friguzzi/Papers/Rig13-FI-IJ.pdf">http://ds.ing.unife.it/~friguzzi/Papers/Rig13-FI-IJ.pdf</a>, <a class="reference external" href="https://doi.org/10.3233/FI-2013-847">doi:10.3233/FI-2013-847</a>.</p>
</dd>
<dt class="label" id="id55"><span class="brackets"><a class="fn-backref" href="#id13">RS10</a></span></dt>
<dd><p>Fabrizio Riguzzi and Terrance Swift. Tabling and Answer Subsumption for Reasoning on Logic Programs with Annotated Disjunctions. In <em>Technical Communications of the International Conference on Logic Programming</em>, volume 7 of Leibniz International Proceedings in Informatics (LIPIcs), 162–171. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2010. <a class="reference external" href="https://doi.org/10.4230/LIPIcs.ICLP.2010.162">doi:10.4230/LIPIcs.ICLP.2010.162</a>.</p>
</dd>
<dt class="label" id="id50"><span class="brackets"><a class="fn-backref" href="#id7">SK97</a></span></dt>
<dd><p>Taisuke Sato and Yoshitaka Kameya. Prism: a language for symbolic-statistical modeling. In <em>International Joint Conference on Artificial Intelligence</em>, 1330–1339. 1997.</p>
</dd>
<dt class="label" id="id53"><span class="brackets">SK01</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id16">2</a>)</span></dt>
<dd><p>Taisuke Sato and Yoshitaka Kameya. Parameter learning of logic programs for symbolic-statistical modeling. <em>J. Artif. Intell. Res.</em>, 15:391–454, 2001.</p>
</dd>
<dt class="label" id="id46"><span class="brackets">SRV+15</span><span class="fn-backref">(<a href="#id29">1</a>,<a href="#id30">2</a>)</span></dt>
<dd><p>Dimitar Sht. Shterionov, Joris Renkens, Jonas Vlasselaer, Angelika Kimmig, Wannes Meert, and Gerda Janssens. The most probable explanation for probabilistic logic programs with annotated disjunctions. In Jesse Davis and Jan Ramon, editors, <em>International Conference on Inductive Logic Programming</em>, volume 9046 of LNCS, 139–153. Berlin, Heidelberg, 2015. Springer. <a class="reference external" href="https://doi.org/10.1007/978-3-319-23708-4_10">doi:10.1007/978-3-319-23708-4_10</a>.</p>
</dd>
<dt class="label" id="id71"><span class="brackets"><a class="fn-backref" href="#id36">VdBTVODR10</a></span></dt>
<dd><p>Guy Van den Broeck, Ingo Thon, Martijn Van Otterlo, and Luc De Raedt. Dtproblog: a decision-theoretic probabilistic prolog. In <em>Twenty-Fourth AAAI Conference on Artificial Intelligence</em>. 2010.</p>
</dd>
<dt class="label" id="id69"><span class="brackets"><a class="fn-backref" href="#id1">VDB06</a></span></dt>
<dd><p>J. Vennekens, M. Denecker, and M. Bruynooghe. Representing causal information about a probabilistic process. In <em>Proceedings of the 10th European Conference on Logics in Artificial Intelligence</em>, LNAI. Springer, September 2006.</p>
</dd>
<dt class="label" id="id70"><span class="brackets"><a class="fn-backref" href="#id1">VDB09</a></span></dt>
<dd><p>J. Vennekens, Marc Denecker, and Maurice Bruynooghe. CP-logic: a language of causal probabilistic events and its relation to logic programming. <em>Theory Pract. Log. Program.</em>, 9(3):245–308, 2009.</p>
</dd>
<dt class="label" id="id68"><span class="brackets"><a class="fn-backref" href="#id1">VV03</a></span></dt>
<dd><p>J. Vennekens and S. Verbaeten. Logic programs with annotated disjunctions. Technical Report CW386, K. U. Leuven, 2003.</p>
</dd>
<dt class="label" id="id48"><span class="brackets">VVB04</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p>J. Vennekens, S. Verbaeten, and M. Bruynooghe. Logic programs with annotated disjunctions. In <em>International Conference on Logic Programming</em>, volume 3131 of LNCS, 195–209. Springer, 2004.</p>
</dd>
<dt class="label" id="id57"><span class="brackets"><a class="fn-backref" href="#id18">VN51</a></span></dt>
<dd><p>John Von Neumann. Various techniques used in connection with random digits. <em>Nat. Bureau Stand. Appl. Math. Ser.</em>, 12:36–38, 1951.</p>
</dd>
</dl>
</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">cplint - SWI-Prolog Version</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#predicate-reference">Predicate Reference</a></li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#example-of-use">Example of use</a></li>
<li><a class="reference internal" href="#testing-the-installation">Testing the installation</a></li>
<li><a class="reference internal" href="#datasets">Datasets</a></li>
<li><a class="reference internal" href="#support">Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#syntax">Syntax</a><ul>
<li><a class="reference internal" href="#discrete-probability-distributions">Discrete Probability Distributions</a><ul>
<li><a class="reference internal" href="#problog-syntax">ProbLog Syntax</a></li>
<li><a class="reference internal" href="#prism-syntax">PRISM Syntax</a></li>
</ul>
</li>
<li><a class="reference internal" href="#continuous-probability-densities">Continuous Probability Densities</a><ul>
<li><a class="reference internal" href="#distributional-clauses-syntax">Distributional Clauses Syntax</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
<li><a class="reference internal" href="#inference">Inference</a><ul>
<li><a class="reference internal" href="#unconditional-queries">Unconditional Queries</a><ul>
<li><a class="reference internal" href="#drawing-bdds">Drawing BDDs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conditional-queries-on-discrete-variables">Conditional Queries on Discrete Variables</a></li>
<li><a class="reference internal" href="#conditional-queries-on-continuous-variables">Conditional Queries on Continuous Variables</a></li>
<li><a class="reference internal" href="#mpe-map-and-viterbi-inference">MPE, MAP and Viterbi Inference</a><ul>
<li><a class="reference internal" href="#drawing-bdds-for-map-mpe">Drawing BDDs for MAP/MPE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#causal-inference">Causal Inference</a></li>
<li><a class="reference internal" href="#graphing-the-results">Graphing the Results</a><ul>
<li><a class="reference internal" href="#using-c3-js">Using C3.js</a></li>
<li><a class="reference internal" href="#using-r">Using R</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parameters-for-inference">Parameters for Inference</a></li>
<li><a class="reference internal" href="#decision-theory">Decision Theory</a></li>
</ul>
</li>
<li><a class="reference internal" href="#learning">Learning</a><ul>
<li><a class="reference internal" href="#input">Input</a><ul>
<li><a class="reference internal" href="#preamble">Preamble</a></li>
<li><a class="reference internal" href="#background-and-initial-lpad-cpl-program">Background and Initial LPAD/CPL-program</a></li>
<li><a class="reference internal" href="#language-bias">Language Bias</a></li>
<li><a class="reference internal" href="#example-interpretations">Example Interpretations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#commands">Commands</a><ul>
<li><a class="reference internal" href="#parameter-learning">Parameter Learning</a></li>
<li><a class="reference internal" href="#structure-learning">Structure Learning</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parameters-for-learning">Parameters for Learning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#download-query-results-through-an-api">Download Query Results through an API</a></li>
<li><a class="reference internal" href="#example-files">Example Files</a></li>
<li><a class="reference internal" href="#manual-in-pdf">Manual in PDF</a></li>
<li><a class="reference internal" href="#license">License</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="#">cplint 4.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">cplint - SWI-Prolog Version</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Riguzzi Fabrizio, Azzolini Damiano.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>
