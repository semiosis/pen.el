HTTP/1.1 200 OK
date: Mon, 06 May 2024 01:30:05 GMT
last-modified: Fri, 10 May 2019 15:25:44 GMT
etag: "7165-5888a2e1f1d0f-gzip"
accept-ranges: bytes
vary: Accept-Encoding
x-csd-backend: 22
content-length: 4039
content-type: text/html
x-csd-server: tumtum.cs.umd.edu:8447
x-csd-frontend: haproxy03

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title> Functors </title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" type="image/x-icon" href="./../favicon.ico"/>
  <link rel="stylesheet" href="./../styles/tufte.css" />
  <link rel="stylesheet" href="./../styles/pastie.css" />
</head>
<body>
  <article>
    <h1> Functors </h1>
    <section><p>This lec­ture is adjusted from Niki Vazou who adjusted from Ran­jit Jhala who adjusted from Gra­ham Hut­ton.</p></section><h2 class="heading">Mapping Over Lists</h2><section><p>As a brief review, let’s recall map­ping over lists. Let’s sup­pose we want to take a list of inte­gers and add one to each inte­ger in the list. We might define that as fol­lows</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">inc</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- Note: [Int] is spe­cial syn­tax for [] Int</span>
<span class="nf">inc</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">inc</span> <span class="p">(</span><span class="n">i</span><span class="kt">:</span><span class="n">is</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="kt">:</span> <span class="n">inc</span> <span class="n">is</span>
</pre></div></div><p>When we load this func­tion into our trusty Haskell REPL we get</p><div class="highlight"><div class="source"><pre><span></span><span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="n">inc</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div><p>Let’s now sup­pose we want to take a list of inte­gers and square each inte­ger in the list. We might write the fol­low­ing:</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">square</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">square</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">square</span> <span class="p">(</span><span class="n">i</span><span class="kt">:</span><span class="n">is</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span> <span class="kt">:</span> <span class="n">square</span> <span class="n">is</span>
</pre></div></div><p>In our REPL we get</p><div class="highlight"><div class="source"><pre><span></span><span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="n">square</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
</pre></div></div><p>Being good pro­gram­mers, we real­ize there is a com­mon pat­tern in these two tasks. In par­tic­u­lar, we see that there is a func­tion <code>f</code> (either <code>inc</code> or <code>square</code> that we want to apply to each ele­ment in the list. There­fore, we write the fol­low­ing func­tion</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">imap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">imap</span> <span class="n">f</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">imap</span> <span class="n">f</span> <span class="p">(</span><span class="n">i</span><span class="kt">:</span><span class="n">is</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">i</span><span class="p">)</span> <span class="kt">:</span> <span class="n">imap</span> <span class="n">f</span> <span class="n">is</span>
</pre></div></div><p>Now we can rewrite our two func­tions above</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">inc&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">inc&#39;</span> <span class="ow">=</span> <span class="n">imap</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>

<span class="nf">square&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">square&#39;</span> <span class="ow">=</span> <span class="n">imap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
  <span class="c1">-- Note: we could also do imap (^2) b/c of Haskell&#39;s</span>
  <span class="c1">-- han­dling of infix func­tions</span>
</pre></div></div><p>and</p><div class="highlight"><div class="source"><pre><span></span><span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="n">inc&#39;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="n">square&#39;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
</pre></div></div><p>Why stop at lists of inte­gers? Let’s gen­er­al­ize map so that we can map over lists of any type.</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">i</span><span class="kt">:</span><span class="n">is</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">i</span><span class="p">)</span> <span class="kt">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">is</span>
</pre></div></div></section><h2 class="heading">Mapping Over Trees</h2><section><p>Let’s now con­sider binary trees, defined as</p><div class="highlight"><div class="source"><pre><span></span><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Leaf</span> <span class="o">|</span> <span class="kt">Bin</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
   <span class="kr">deriv­ing</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div></div><p>Sim­i­lar to lists, we want to take a tree and have a func­tion that incre­ments each ele­ment and another that squares each ele­ment in the tree.</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">tinc</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="kt">Int</span>
<span class="nf">tinc</span> <span class="kt">Leaf</span>         <span class="ow">=</span> <span class="kt">Leaf</span>
<span class="nf">tinc</span> <span class="p">(</span><span class="kt">Bin</span> <span class="n">i</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">Bin</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">tinc</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">tinc</span> <span class="n">r</span><span class="p">)</span>

<span class="nf">tsquare</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="kt">Int</span>
<span class="nf">tsquare</span> <span class="kt">Leaf</span>         <span class="ow">=</span> <span class="kt">Leaf</span>
<span class="nf">tsquare</span> <span class="p">(</span><span class="kt">Bin</span> <span class="n">i</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">Bin</span> <span class="p">(</span><span class="n">i</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">tsquare</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">tsquare</span> <span class="n">r</span><span class="p">)</span>
</pre></div></div><p>Again, we notice a pat­tern. For both func­tions, we apply some <code>f</code> to the value con­tained at a node and recur­sively apply it to both sub­trees; if we reach a leaf we sim­ply return that leaf. Let’s define map for trees. (Notice this time I skipped right to the gen­er­al­ized ver­sion.)</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">tmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">b</span>
<span class="nf">tmap</span> <span class="n">f</span> <span class="kt">Leaf</span>        <span class="ow">=</span> <span class="kt">Leaf</span>
<span class="nf">tmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Bin</span> <span class="n">i</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bin</span> <span class="p">(</span><span class="n">f</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="n">tmap</span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">tmap</span> <span class="n">f</span> <span class="n">r</span><span class="p">)</span>
</pre></div></div></section><h2 class="heading">The Functor Typeclass</h2><section><p>Let’s com­pare the types <code>tmap</code> and <code>map</code>.</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">tmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">b</span>
<span class="nf">map</span>  <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">b</span>
</pre></div></div><p>These look very sim­i­lar. Can we abstract them into one idea? This looks like a job for type­classes!</p><div class="highlight"><div class="source"><pre><span></span><span class="kr">class</span> <span class="kt">Func­tor</span> <span class="n">m</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div></div><p>In this case, we define the type­class <code>Func­tor</code> for which there is one func­tion <code>fmap</code>. We say a type <code>m</code> is an instance of the <code>Func­tor</code> type­class if we define a func­tion <code>fmap</code> for it which given a func­tion <code>f</code> from type <code>a</code> to type <code>b</code>, and a type <code>m</code> of <code>a</code>, we get back a type <code>m</code> of <code>b</code>. For instance, if <code>m</code> is the <code>List</code> type we have</p><div class="highlight"><div class="source"><pre><span></span><span class="kr">instance</span> <span class="kt">Func­tor</span> <span class="kt">List</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="n">i</span><span class="kt">:</span><span class="n">is</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">i</span><span class="p">)</span> <span class="kt">:</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">is</span>
</pre></div></div><p>and if <code>m</code> is <code>Tree</code> then we have</p><div class="highlight"><div class="source"><pre><span></span><span class="kr">instance</span> <span class="kt">Func­tor</span> <span class="kt">Tree</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Leaf</span>     <span class="ow">=</span> <span class="kt">Leaf</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Bin</span> <span class="n">i</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bin</span> <span class="p">(</span><span class="n">f</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">r</span><span class="p">)</span>
</pre></div></div><p>And there a bunch more instances of Func­tor in Haskell!</p><div class="highlight"><div class="source"><pre><span></span><span class="kr">instance</span> <span class="kt">Func­tor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Noth­ing</span>  <span class="ow">=</span> <span class="kt">Noth­ing</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Func­tor</span> <span class="kt">IO</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="n">io</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">io</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div></div></section><h2 class="heading">The Functor Laws</h2><section><p>Recall that Haskell type­classes can also have “laws”, which is to say prop­er­ties of the type­class func­tions which should be pre­served for valid instances. For exam­ple, for a type to be an instance of the “Num” type­class in Haskell, <code>+</code> over that type should be asso­cia­tive.</p><p>For the <code>Func­tor</code> type­class, there are two laws which hold for valid instances of the type class. The first law states that map­ping the iden­tity func­tion over the func­tor should sim­ply return the orig­i­nal value. In Haskell terms</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">fmap</span> <span class="n">id</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div></div><p>We can see eas­ily see this is true for <code>List</code> and <code>Tree</code>.</p><div class="highlight"><div class="source"><pre><span></span><span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">id</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">id</span> <span class="p">(</span><span class="kt">Bin</span> <span class="mi">2</span> <span class="p">(</span><span class="kt">Leaf</span><span class="p">)</span> <span class="p">(</span><span class="kt">Leaf</span><span class="p">))</span>
<span class="kt">Bin</span> <span class="mi">2</span> <span class="p">(</span><span class="kt">Leaf</span><span class="p">)</span> <span class="p">(</span><span class="kt">Leaf</span><span class="p">)</span>
</pre></div></div><p>The sec­ond law is a bit harder. It states that map­ping the com­po­si­tion of two func­tions <code>f</code> and <code>g</code> over a func­tor should be the same as first map­ping <code>g</code> over the func­tor and then map­ping <code>f</code> over it. In Haskell terms</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">g</span><span class="p">)</span>
</pre></div></div><p>So for list this might look like</p><div class="highlight"><div class="source"><pre><span></span><span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="ow">-&gt;</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="ow">-&gt;</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
<span class="kt">Pre­lude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">((</span><span class="nf">\</span><span class="n">x</span><span class="ow">-&gt;</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span><span class="ow">-&gt;</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
</pre></div></div></section><h2 class="heading">Why Functors?</h2><section><p>So, why func­tors? We’ve seen that may com­mon types, like <code>[]</code>, <code>Maybe</code>, <code>Trees</code>, and <code>IO</code> can be made valid instances of the <code>Func­tor</code> type­class. This in itself exposes the first real value of type­classes. Sim­i­lar to inter­faces in Java, this allows us to write func­tions over func­tors that will work for any of the com­mon types listed above. This type of abstrac­tion can make code shorter and more under­stand­able.</p><p>How­ever, there is a sec­ond, more sub­tle advan­tage of Func­tors. Let’s explain this one by an exam­ple with our <code>Tree</code> type­class from ear­lier. Let’s cre­ate a huge tree.</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">cre­ate­Tree</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="kt">Int</span>
<span class="nf">cre­ate­Tree</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Leaf</span>
<span class="nf">cre­ate­Tree</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Bin</span> <span class="n">n</span> <span class="n">l</span> <span class="n">r</span>
  <span class="kr">where</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">cre­ate­Tree</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r</span> <span class="ow">=</span> <span class="n">cre­ate­Tree</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="nf">tree</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span>
<span class="nf">tree</span> <span class="ow">=</span> <span class="n">cre­ate­Tree</span> <span class="mi">30</span>
</pre></div></div><p><code>tree</code> has over 1 bil­lion nodes in it!</p><p>Sup­pose we now want to add 1 to each ele­ment in the tree, mul­ti­ply each ele­ment in the tree by 2, and then sum the result. We can do that using our <code>tmap</code> from ear­lier.</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">mapped­Tree1</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span>
<span class="nf">mapped­Tree1</span> <span class="ow">=</span> <span class="n">tmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">tmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="n">tree</span><span class="p">)</span>

<span class="nf">sum­Tree</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">sum­Tree</span> <span class="kt">Leaf</span>        <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">sum­Tree</span> <span class="p">(</span><span class="kt">Bin</span> <span class="n">i</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">sum­Tree</span> <span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">sum­Tree</span> <span class="n">r</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">print</span> <span class="o">$</span> <span class="n">sum­Tree</span> <span class="n">mapped­Tree1</span>
</pre></div></div><p>This works, but can we do bet­ter? Well, do we have to call <code>tmap</code> twice to cre­ate <code>mapped­Tree1</code>? No, let’s write a new imple­men­ta­tion, <code>mapped­Tree2</code>, using func­tion com­po­si­tion.</p><div class="highlight"><div class="source"><pre><span></span><span class="nf">mapped­Tree2</span> <span class="ow">::</span> <span class="kt">Tree</span> <span class="kt">Int</span>
<span class="nf">mapped­Tree2</span> <span class="ow">=</span> <span class="n">tmap</span> <span class="p">((</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="n">tree</span>
</pre></div></div><p>This is bet­ter! Now we only iter­ate over the nodes once and only allo­cate one new tree instead of two!</p><p>This is a great opti­miza­tion, but it did require some inge­nu­ity on our part. What if this could be done auto­mat­i­cally? Look­ing more closely at <code>mapped­Tree1</code> and <code>mapped­Tree2</code>, we see that this trans­for­ma­tion is really just the com­po­si­tion rule for func­tors. So indeed, for func­tors, our com­piler can auto­mat­i­cally per­form this opti­miza­tion, regard­less of which spe­cific func­tor instance (trees, lists, options, etc.).</p><p>This exam­ple exposes the sec­ond advan­tage of func­tors. Func­tors allow us to auto­mat­i­cally per­form rewrit­ing due to the com­po­si­tion rule to reduce our cals to <code>fmap</code>.</p></section><h2 class="heading">Exercises for Home</h2><section><ul><li><p>Define an instance of <code>Func­tor</code> which does not obey the iden­tity law. Now write one that does not obey the com­po­si­tion law.</p></li></ul></section>
  </article>
  <footer>
    <section>
      <p><a href="https://www.umd.edu/web-accessibility" title="UMD Web Accessibility">Web Accessibility</a></p>
    </section>
  </footer>
</body>
</html>
