HTTP/1.1 200 OK
Date: Wed, 13 Dec 2023 02:47:52 GMT
Server: Apache/2.4.29
Strict-Transport-Security: max-age=63072000
X-Frame-Options: sameorigin
X-Content-Type-Options: nosniff
Access-Control-Allow-Origin: (null)
Accept-Ranges: bytes
Cache-Control: max-age=0
Expires: Wed, 13 Dec 2023 02:47:52 GMT
Vary: Accept-Encoding
Content-Length: 58932
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html
Content-Language: en

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>GNU APL</title>
    <meta name='description' content='APL'/>
    <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'/>
    <link rel='stylesheet' type='text/css' href='apl-intro.css'/>
  </head>

  <body>
  <h1 class="toc_H1">A Quick Tour of GNU APL</h1>
    <table>
<tr class="toc_H2"><td class="toc_c1"> 1<td class="toc_c2">
    <a class="toc_a2" href="#CH_1"> Document Conventions </a>

<tr class="toc_H2"><td class="toc_c1"> 2<td class="toc_c2">
    <a class="toc_a2" href="#CH_2"> Starting and stopping the APL interpreter </a>

<tr class="toc_H2"><td class="toc_c1"> 3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3"> APL Statements </a>

<tr class="toc_H3"><td class="toc_c1"> 3.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1"> Constants (Literals) </a>

<tr class="toc_H4"><td class="toc_c1"> 3.1.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.1"> Scalar Constants </a>

<tr class="toc_H5"><td class="toc_c1"> 3.1.1.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.1.1"> Scalar Text Constants </a>

<tr class="toc_H5"><td class="toc_c1"> 3.1.1.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.1.2"> Numeric Scalar Constants </a>

<tr class="toc_H4"><td class="toc_c1"> 3.1.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.2"> Vector Constants </a>

<tr class="toc_H4"><td class="toc_c1"> 3.1.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.3"> Mixed Constants </a>

<tr class="toc_H4"><td class="toc_c1"> 3.1.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.4"> Nested Constants </a>

<tr class="toc_H4"><td class="toc_c1"> 3.1.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.5"> Multi-Line Strings </a>

<tr class="toc_H4"><td class="toc_c1"> 3.1.6<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.1.6"> Summary and Remarks </a>

<tr class="toc_H3"><td class="toc_c1"> 3.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.2"> APL Names </a>

<tr class="toc_H4"><td class="toc_c1"> 3.2.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.2.1"> User-defined Names </a>

<tr class="toc_H4"><td class="toc_c1"> 3.2.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.2.2"> Names of System Functions and System Variables </a>

<tr class="toc_H4"><td class="toc_c1"> 3.2.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.2.3"> Names of Primitive APL Functions </a>

<tr class="toc_H3"><td class="toc_c1"> 3.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.3"> Functions and Operators </a>

<tr class="toc_H4"><td class="toc_c1"> 3.3.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.3.1"> Niladic Functions </a>

<tr class="toc_H4"><td class="toc_c1"> 3.3.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.3.2"> Monadic Functions </a>

<tr class="toc_H4"><td class="toc_c1"> 3.3.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.3.3"> Dyadic Functions </a>

<tr class="toc_H4"><td class="toc_c1"> 3.3.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.3.4"> Monadic Operators </a>

<tr class="toc_H4"><td class="toc_c1"> 3.3.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.3.5"> Dyadic Operators </a>

<tr class="toc_H3"><td class="toc_c1"> 3.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4"> General APL Values </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.1"> Reshape and Shape: ⍴ </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.2"> Catenate and Ravel: , and ⍪ </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.3"> Universal Character Set (monadic ⎕UCS) </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.4"> Construction of arbitrary simple values </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.5"> Construction of arbitrary nested values </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.6<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.6"> Displaying the structure of values </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.7<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.7"> Vector Notation versus Catenation </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.8<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.8"> Scalar Extension </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.9<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.9"> List of Built-in Scalar Functions </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.10<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.10"> List of Other Built-in Functions </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.11<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.11"> List of Built-in Monadic APL Operator </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.12<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.12"> List of Built-In Dyadic APL Operators </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.13<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.13"> Functions and Operators with Axis Argument </a>

<tr class="toc_H4"><td class="toc_c1"> 3.4.14<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14"> System Functions </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.1"> Z ← ⎕AF B : Atomic Function </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.2"> Z ← A ⎕AT B : Attributes </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.3"> Z ← A ⎕CR B : Character Representation </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.4"> Z ← ⎕DL B : Delay </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.5"> Z ← A ⎕DLX B : Donald Knuth's Dancing Links </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.6<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.6"> Z ← A ⎕EA B : Execute Alternate </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.7<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.7"> Z ← A ⎕EB B : Execute Both </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.8<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.8"> Z ← ⎕EC B : Execute Controlled </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.9<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.9"> Z ← ⎕ENV B : ENvironment Variables </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.10<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.10"> Z ← A ⎕ES B : Event Simulate </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.11<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.11"> Z ← ⎕EX B : EXpunge </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.12<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.12"> Z ← A ⎕FFT B : Fast Fourier Transform </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.13<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.13"> ⎕FIO[X] B : File I/O functions </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.14<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.14"> Z ← ⎕FX B : FiX </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.15<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.15"> Z ← ⎕GTK B : Gtk GUI </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.16<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.16"> Z ← A ⎕JSON B : JSON parser </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.17<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.17"> Z ← A ⎕MAP B : MAP (replace) ravel elements </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.18<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.18"> Z ← ⎕INP B : INPut from script </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.19<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.19"> Z ← ⎕NA B : Name Association </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.20<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.20"> Z ← ⎕NC B : Name Class </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.21<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.21"> Z ← A ⎕NL B : Name List </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.22<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.22"> Z ← A ⎕PLOT B : Plot a Value </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.23<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.23"> Z ← A ⎕PNG B : Process PNG files and Pixel Images </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.24<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.24"> Z ← A ⎕RE B : Regular expression </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.25<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.25"> Z ← A ⎕RVAL B : Random APL value </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.26<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.26"> Z ← [A] ⎕SI B : State Indicator </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.27<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.27"> Z ← ⎕SQL[CMD] B : SQL functions </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.28<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.28"> Z ← ⎕SVC B : Shared Variable Control </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.29<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.29"> Z ← ⎕SVO B : Shared Variable Offer </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.30<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.30"> Z ← ⎕SVQ B : Shared Variable Query </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.31<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.31"> Z ← ⎕SVR B : Shared Variable Retraction </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.32<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.32"> Z ← ⎕SVS B : Shared Variable State </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.33<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.33"> Z ← [A] ⎕STOP B : STOP vector </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.34<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.34"> Z ← A ⎕TF B : Transfer Form </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.35<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.35"> Z ← ⎕XML B : XML parser </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.36<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.36"> Z ← ⎕TRACE B : TRACE vector </a>

<tr class="toc_H5"><td class="toc_c1"> 3.4.14.37<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.4.14.37"> Z ← ⎕UCS B : Universal Char Set </a>

<tr class="toc_H3"><td class="toc_c1"> 3.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.5"> Variables </a>

<tr class="toc_H4"><td class="toc_c1"> 3.5.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.5.1"> The Variables ⎕ and ⍞ </a>

<tr class="toc_H5"><td class="toc_c1"> 3.5.1.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.5.1.1"> Input and Output with ⍞ </a>

<tr class="toc_H5"><td class="toc_c1"> 3.5.1.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.5.1.2"> Input and Output with ⎕ </a>

<tr class="toc_H5"><td class="toc_c1"> 3.5.1.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.5.1.3"> ⎕ Input in Application Programs </a>

<tr class="toc_H3"><td class="toc_c1"> 3.6<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.6"> Indexing </a>

<tr class="toc_H3"><td class="toc_c1"> 3.7<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.7"> Execution of APL Statements </a>

<tr class="toc_H3"><td class="toc_c1"> 3.8<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8"> Defined Functions </a>

<tr class="toc_H4"><td class="toc_c1"> 3.8.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.1"> Function Header </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.1.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.1.1"> Creating and displaying defined functions: ⎕FX and ⎕CR </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.1.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.1.2"> Result Specification </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.1.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.1.3"> Local Variables </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.1.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.1.4"> The Del Editor </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.1.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.1.5"> Function Body </a>

<tr class="toc_H4"><td class="toc_c1"> 3.8.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.2"> How Functions and Operators are Evaluated </a>

<tr class="toc_H4"><td class="toc_c1"> 3.8.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.3"> Branching </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.3.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.3.1"> Labels </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.3.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.3.2"> Computed Branch (inside a function) </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.3.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.3.3"> Computed Branch (outside a function) </a>

<tr class="toc_H5"><td class="toc_c1"> 3.8.3.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_3.8.3.4"> Escape (Unwind) </a>

<tr class="toc_H2"><td class="toc_c1"> 4<td class="toc_c2">
    <a class="toc_a2" href="#CH_4"> Commands </a>

<tr class="toc_H3"><td class="toc_c1"> 4.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1"> Standard Commands </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.1"> )CLEAR </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.2"> )COPY </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.3"> )COPY_ONCE </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.4"> )DROP </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.5"> )ERASE </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.6<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.6"> )FNS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.7<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.7"> )LIB </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.8<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.8"> )LOAD </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.9<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.9"> )NMS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.10<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.10"> )OPS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.11<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.11"> )SAVE </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.12<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.12"> )SI </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.13<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.13"> )SIC </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.14<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.14"> )SINL </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.15<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.15"> )SIS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.16<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.16"> )VARS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.1.17<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.1.17"> )WSID </a>

<tr class="toc_H3"><td class="toc_c1"> 4.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2"> IBM APL2 Commands </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.1"> )CHECK </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.2"> )CONTINUE </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.3"> )HELP </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.4"> )HOST </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.5"> )IN </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.6<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.6"> )MORE </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.7<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.7"> )OUT </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.8<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.8"> )OFF </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.9<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.9"> )PCOPY </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.10<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.10"> )PIN </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.11<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.11"> )RESET </a>

<tr class="toc_H4"><td class="toc_c1"> 4.2.12<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.2.12"> )SYMBOLS </a>

<tr class="toc_H3"><td class="toc_c1"> 4.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3"> Additional GNU APL Commands </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.1<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.1"> )DUMP </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.2<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.2"> )DUMP-HTML </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.3<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.3"> ]HIST </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.4<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.4"> )LIBS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.5<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.5"> )QLOAD </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.6<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.6"> )VALUES </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.7<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.7"> ]BOXING </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.8<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.8"> ]COLOR </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.9<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.9"> ]DOXY </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.10<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.10"> ]EXPECT </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.11<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.11"> ]KEYB </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.12<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.12"> ]LOG </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.13<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.13"> ]NEXTFILE </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.14<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.14"> ]OWNERS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.15<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.15"> ]SVARS </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.16<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.16"> ]SYMBOL </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.17<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.17"> ]USERCMD </a>

<tr class="toc_H4"><td class="toc_c1"> 4.3.18<td class="toc_c2">
    <a class="toc_a2" href="#CH_4.3.18"> ]XTERM </a>

    </table>
    <hr>

   
   
   <h1>A Quick Tour of GNU APL</h1><P>July 30, 2023, SVN version 1722:1723
   </P><BR>Please report errors in this document to  <a href=mailto:bug-apl@gnu.org>bug-apl@gnu.org</a><BR><BR>
   
   
   Copyright (©) 2013-2023 Dr. Jürgen Sauermann and friends.
   <br>
   
   This document is part of GNU APL and may be distributed under the terms of<br>
   
   the GNU Free Documentation License, see
   <A href=http://www.gnu.org/licenses/fdl.html>
   http://www.gnu.org/licenses/fdl.html</A>
   <br>
   <br>
   
   <h2><a id="CH_1"></a>
   1 Document Conventions</h2>
   
   Your keyboard input is rendered in bold blue and the response from your
   computer in black like this:
   
   <pre class=input_T>This is what you type on the keyboard</pre>
   <pre class=output>and this is the response you get</pre>
   
   <h2><a id="CH_2"></a>
   2 Starting and stopping the APL interpreter</h2>
   
   APL is an easy-to-learn language. This quick start manual is an introduction
   to APL in a few simple steps. We assume that you are using GNU APL and that
   you have installed it according to the README files that come with it.
   <br>
   
   <br>
   
   The APL interpreter is a normal program and is started like that: by entering
   its name in a shell (preferably <B>bash</B>.
   <br>
   
   <pre class=input_T>$ apl</pre>
   <pre class=output>                    ______ _   __ __  __    ___     ____   __ 
                   / ____// | / // / / /   /   |   / __ \ / / 
                  / / __ /  |/ // / / /   / /| |  / /_/ // /  
                 / /_/ // /|  // /_/ /   / ___ | / ____// /___
                 \____//_/ |_/ \____/   /_/  |_|/_/    /_____/
                                       
                        Welcome to GNU APL version 1.8
                                       
                Copyright (C) 2008-2022  Dr. Jürgen Sauermann
                       Banner by FIGlet: www.figlet.org
                                       
                This program comes with ABSOLUTELY NO WARRANTY;
                         for details run: ./apl --gpl.
                                       
     This program is free software, and you are welcome to redistribute it
         according to the GNU Public License (GPL) version 3 or later.
                                       


   </pre>
   
   The interpreter prints a start-up banner like above and then enters an endless
   loop which APL programmers refer to as <B>immediate execution mode</B> and
   others as <B>REPL</B> (an abbreviation for
   <B>R</B>ead-<B>E</B>valuate-<B>P</B>rint-<B>L</B>oop).
   <br>
   <br>
   
   In immediate execution mode the interpreter reads one input line, either
   interactively from the user, or from a file if GNU APL is run as a script.
   It then processes (or <B>E</B>valuates in <B>REPL</B>) the input line and
   prints some result output (which may be empty for some input lines).
   Depending on the details of the processing of the line entered, the
   interpreter will either:
   
   <ul>
   <li>remain in immediate execution mode (the <B>L</B>oop in <B>REPL</B>), or</li>
   <li>enter another mode called definition mode, or</li>
   <li>exit the interpreter</li>
   </ul>
   
   
   The following state machine describes this top-level behaviour of an APL
   interpreter, and some user inputs that trigger mode changes:
   
   <pre>
   
                                ┌───────┐
                                │ Start │
                                └───────┘
                                    ↓
                                    ↓
                   ╔═══════════════════════════════╗      )OFF      ┌──────┐
         → → → → → ║   Immediate Execution Mode    ║→ → → → → → → → │ EXIT │
        ↑          ║        (Read in REPL)         ║                └──────┘
        ↑          ╚═══════════════════════════════╝
        ↑             ↓        ↑    ↑           ↓
        ↑             ↓       ^C    ↑           ∇ (enter definition mode)
        ↑             ↓        ↑    ↑           ↓
        ↑   ╔════════════════════╗  ↑  ╔═════════════════╗
        ↑   ║   Execution Mode   ║  ↑  ║ Definition Mode ║
        ↑   ║ (Evaluate in REPL) ║  ↑  ║   (∇-editor)    ║
        ↑   ╟────────────────────╢  ↑  ╚═════════════════╝
        ↑   ║  (Print in REPL)   ║  ↑           ↓
        ↑   ╚════════════════════╝  ↓           ∇ (leave definition mode)
        ↑             ↓             ↓           ↓
         ← ← ← ← ← ← ←               ← ← ← ← ← ←
   </pre>
   
   In the first case, i.e. the interpreter remains in immediate execution mode,
   the whole process starts over again; the next lines is read, processed, printed,
   and so on.
   
   The second case (leaving immediate execution mode) is explained in a later
   chapter.
   
   The first non-blank character of the line entered in immediate execution mode
   determines what happens next:
   
   <ul>
   <li>if the first non-blank character is <B>)</B> then the line is interpreted and
       processed as an APL command. Commands are discussed in chapter "Commands"
       below. In GNU APL some commands start with <B>]</B>, which is a non-standard
       extension.</li>
   <br>
   
   <li>if the first non-blank character is <B>∇</B> then an APL function editor
       (the ∇-editor) is started and editing of a new or already existing
       user-defined function begins until ∇ is typed again. User-defined
       functions are simply called <B>defined function</B>s in APL jargon.
       The construction and editing of defined functions is discussed in chapter
       <B>Defined Functions</B> below.</li>
   <br>
   
   <li>Otherwise the line is considered a sequence of APL statements and the
       interpreter enters <B>execution mode</B> (which corresponds to the
       <B>E</B>valuate in <B>REPL</B>) in which APL code is being executed.
       The execution mode may have its own loops which may be interrupted
       with ^C. The execution mode is left automatically after the last APL
       statement was processed, or after an APL error had occurred. APL
       statements are discussed in chapter "APL Statements" below.</li>
   </ul>
   
   
   The most important command at the moment is )OFF which ends the apl interpreter:
   
   <pre class=input_T>      )OFF</pre>
   <pre class=output>Goodbye.
$</pre>
   
   Pressing control-C or control-D (i.e. the standard way to end programs)
   merely stops the execution of the current APL statement in execution mode,
   but does not end the interpreter. This behavior is similar to a shell where
   control-C stops the current program but does not exit from the shell.
   
   <h2><a id="CH_3"></a>
   3 APL Statements</h2>
   
   APL statements are constructed from:
   <ul>
   <li>APL constants (numbers and characters)</li>
   <li>Names (of functions and/or variables)</li>
   <li>other characters: ← → [ ; ] ( ) and :</li>
   </ul>
   
   
   Several statements on the same line are separated by the APL character ◊
   (called Diamond). Before discussing the execution of statements we will
   introduce their components, i.e. constants and names.
   
   <h3><a id="CH_3.1"></a>
   3.1 Constants (Literals)</h3>
   
   Constants, also called literals, are used in APL statements for denoting
   fixed values.
   
   <h4><a id="CH_3.1.1"></a>
   3.1.1 Scalar Constants</h4>
   
   The simplest constants are scalar constants, similar to atoms in Chemistry.
   From these scalar constants more complex constants can be created. There are
   also scalar APL values which are not constants; a definition of the term
   scalar will be given later. For the moment think of a scalar as a single
   data item.
   
   <h5><a id="CH_3.1.1.1"></a>
   3.1.1.1 Scalar Text Constants</h5>
   
   The simplest scalar constants are scalar text constants. A scalar text
   constant defines a single character.
   <br>
   
   As we will discuss in more detail later, if you enter a constant
   (and nothing else) in immediate execution mode then
   the interpreter will output the same constant, although in a slightly
   different fashion.
   <br>
   
   A scalar text constant (aka. a single character) is entered by enclosing the
   character in single quotes. The character A, for example, is entered as 'A'
   and the interpreter answers with printing A (removing the quotes around it):
   
<pre class=input_T line=602>      'A'</pre>
<pre class=output>A
</pre>
   
   
   The quote character itself is entered by doubling it inside the quotes
   that enclose it:
   
<pre class=input_T line=602>      ''''</pre>
<pre class=output>'
</pre>
   
   
   <h5><a id="CH_3.1.1.2"></a>
   3.1.1.2 Numeric Scalar Constants</h5>
   
   A numeric scalar constant is a single number. The simplest numeric scalar
   constant is an integer, entered as a sequence of decimal digits:
   
<pre class=input_T line=602>      42</pre>
<pre class=output>42
</pre>
   
   
   Fractional numbers are entered with a decimal point and a fractional part:
   
<pre class=input_T line=602>      42.5</pre>
<pre class=output>42.5
</pre>
   
   
   The integral part can be omitted:
   
<pre class=input_T line=602>      .5</pre>
<pre class=output>0.5
</pre>
   
   
   An optional scaling by a power of 10 (aka. scientific notation) can be applied
   with the character E, followed by the exponent. The E is case insensitive,
   therefore e will also work:
   
<pre class=input_T line=602>      42.5E3</pre>
<pre class=output1>42500
</pre>
<pre class=input_ line=603>      42e3</pre>
<pre class=output>42000
</pre>
   
   
   Negative numbers use a leading ¯ (Overbar); a minus sign is NOT the sign of
   a number but a function that negates a value. The result is often the same,
   but you should always use the overbar for negative numbers:
   
<pre class=input_T line=602>      ¯42.5E3</pre>
<pre class=output>¯42500
</pre>
   
   
   The exponent in scientific notation can also be negative (in this case using
   - gives a different result):
   
<pre class=input_T line=602>      42.5E¯3</pre>
<pre class=output1>0.0425
</pre>
<pre class=input_ line=603>      42.5E-3</pre>
<pre class=errput>VALUE ERROR
      42.5 E-3
           ^
</pre>
   
   
   The error in the second statement above occurs because:
   <ol>
   <li>in APL the minus sign (i.e. - as opposed to ¯) is a primitive function and
       never part of a number, and therefore</li>
   <li>the <B>E</B> is not an exponent belonging to 42.5. Instead <B>E</B> is taken
       as the name of a variable (which does not exist in this example) and that
       causes the error. Using - instead of ¯ is a frequent mistake of APL
       beginners.</li>
   </ol>
   
   Complex numbers can be entered in 3 different formats. The standard format
   (standard because is also the format used by the interpreter when printing
   complex numbers) is to specify the real and imaginary parts of a complex
   number separated by the letter J (or j):
   
<pre class=input_T line=602>      3J4       ⍝ a complex number of magnitude 5</pre>
<pre class=output1>3J4
</pre>
<pre class=input_ line=603>      0.6j0.8   ⍝ the same, but scaled to magnitude 1</pre>
<pre class=output>0.6J0.8
</pre>
   
   
   One alternative format is to specify the number as its magnitude and its
   angle in degrees (from 0° to 360°), separated by the letter D or d (which
   stands for for "degrees"). Since arccos(0.6) = 53.130102354, we get the
   same complex numbers:
   
<pre class=input_T line=602>      5D53.130102354   ⍝ magnitude 5, angle 53.130102354°</pre>
<pre class=output1>3J4
</pre>
<pre class=input_ line=603>      1d53.130102354   ⍝ the same, but scaled to magnitude 1</pre>
<pre class=output>0.6J0.8
</pre>
   
   
   The other alternative format is to specify the number as its magnitude and its
   angle in radians (from 0 to 2&pi;), separated by the letter R or r (for "radians").
   Since 53.130102354 &pi; / 180 = 0.927295218 we get the same numbers:
   
<pre class=input_T line=602>      5R0.927295218   ⍝ magnitude 5, angle 0.927295218 radians</pre>
<pre class=output1>3J4
</pre>
<pre class=input_ line=603>      1r0.927295218   ⍝ the same, but scaled to magnitude 1</pre>
<pre class=output>0.6J0.8
</pre>
   
   
   Please keep in mind that whitespace characters (space, tab, etc.) are NOT
   permitted in numbers.
   
   <h4><a id="CH_3.1.2"></a>
   3.1.2 Vector Constants</h4>
   
   Vector constants are created by writing several scalar constants on the
   same line, separated by one or more spaces between them. A single complex
   number is a scalar even if has two components (its real and imaginary parts).
   Multiple separating spaces between scalars are treated like single spaces:
   
<pre class=input_T line=602>      1   2 3</pre>
<pre class=output1>1 2 3
</pre>
<pre class=input_ line=603>      'A' 'B' 'C'</pre>
<pre class=output>ABC
</pre>
   
   
   Sequences of character scalars can be written with quotes around the sequence
   rather than quotes around each character. The rules for scalar character
   constants apply here as well:
   
<pre class=input_T line=602>      'ABC'</pre>
<pre class=output1>ABC
</pre>
<pre class=input_ line=603>      'A''B''C'</pre>
<pre class=output1>A'B'C
</pre>
<pre class=input_ line=603>      "A'B'C"</pre>
<pre class=output>A'B'C
</pre>
   
   
   You cannot enter numeric vector constants with less than two elements because
   numeric vector constants with one element would be a numeric scalar constant,
   and a numeric vector constants with no elements would be completely empty.
   
   You can enter an empty character vector constant (a vector with no elements)
   like this:
   
<pre class=input_T line=602>      ''</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      ""</pre>
<pre class=output>

</pre>
   
   
   You normally cannot enter character vector constants with one element for
   the same reason as for numeric vector constants: it would be a scalar
   constant rather than a vector. This can become cumbersome when dealing with
   text; if the length of a character sequence is one then the text is a scalar,
   otherwise it is a vector. For this reason GNU APL provides a non-standard
   extension using double quotes instead of single quotes. This extension has
   slightly different and sometimes more convenient rules than texts in single
   quotes:
   
   <ul>
   <li>double quoted characters are always vectors (even if their length is 1)</li>
   <li>single quotes stand for themselves and need not be doubled</li>
   <li>for some problematic characters C-like sequences are defined:
       <ul>
       <li><B>\0</B> produces <B>NUL</B> (null,            ASCII code  0) </li>
       <li><B>\a</B> produces <B>BEL</B> (bell,            ASCII code  7) </li>
       <li><B>\b</B> produces <B>BS</B>  (backspace,       ASCII code  8) </li>
       <li><B>\t</B> produces <B>TAB</B> (tab,             ASCII code  9) </li>
       <li><B>\n</B> produces <B>NL</B>  (newline,         ASCII code 10) </li>
       <li><B>\v</B> produces <B>VT</B>  (vertical tab,    ASCII code 11) </li>
       <li><B>\f</B> produces <B>FF</B>  (form feed,       ASCII code 12) </li>
       <li><B>\r</B> produces <B>CR</B>  (carriage return, ASCII code 13) </li>
       <li><B>\[</B> produces <B>ESC</B> (escape,          ASCII code 27) </li>
       <li><B>\"</B> produces <B>"</B>   (double quote,    ASCII code 34) </li>
       <li><B>\\</B> produces <B>\</B>   (backslash,       ASCII code 92) </li>
       </ul>
   
   </li>
   </ul>
   
   
   Examples:
   
<pre class=input_T line=602>      "A"   ⍝ 1-element vector</pre>
<pre class=output1>A
</pre>
<pre class=input_ line=603>      "'"   ⍝ a quote (')</pre>
<pre class=output1>'
</pre>
<pre class=input_ line=603>      "A\"B\\C"   ⍝ 'A', double quote, 'B', backslash, 'C'</pre>
<pre class=output>A"B\C
</pre>
   
   
   Finally, in the old APL1 (ISO 8485 standard) there was no way to express
   an empty numeric vector and one had to use expressions like <B>⍳0</B> or
   <B>0⍴0</B> for them. In modern interpreters, however, the symbol <B>⍬</B> may
   be used to denote an empty numeric vector (i.e. of length 0). In APL1 empty
   numeric vectors were often expressed as '', frequently as ''⍴V to get the
   first item of vector or matrix into a scalar. That worked, but these days
   one would use the cleaner <B>⍬⍴V</B> instead.
   
   
   <h4><a id="CH_3.1.3"></a>
   3.1.3 Mixed Constants</h4>
   
   The first APL interpreters (and the first APL standard, ISO 8485) only allowed
   constants and values whose components were either all numeric scalars, or all
   character scalars. The examples given so far were of that kind.
   
   The current APL standard, ISO 13751, also llows a mix of characters and numbers
   in constants and values, for example:
   
<pre class=input_T line=602>      1 2 'A' 'B' 3 4</pre>
<pre class=output>1 2 AB 3 4
</pre>
   
   
   Such values are called <B>mixed</B>.
   
   <h4><a id="CH_3.1.4"></a>
   3.1.4 Nested Constants</h4>
   
   The vector constants discussed so far were <B>simple</B>, which means that their
   components were (numeric or character) scalars. Since ISO 13751, another
   APL value can be used instead of a scalar. Such constants or values are called 
   <B>nested</B>. The nested components of constants are vectors that are
   either quoted texts (aka. <B>strings</B>) or, if numeric, surrounded by
   parentheses instead of quotes:
   
<pre class=input_T line=602>      1 2 'AB' 3 4   ⍝ (nested) string 'AB'</pre>
<pre class=output1> 1 2 AB 3 4 
</pre>
<pre class=input_ line=603>      1 2 (10 11) 3 4     ⍝ nested numeric vector (10 11)</pre>
<pre class=output> 1 2  10 11  3 4 
</pre>
   
   
   In the normal output formatting of APL like above, the nesting of items is
   displayed as additional blanks which makes it sometimes difficult to recognize
   the exact nesting structure. The quotes and parentheses that group the items
   of a nested literal on input are replaced by blanks on output. That blurs
   the output, in particular when the nesting becomes deeper (i.e. when a nested
   value contains nested items). Nested values differ from non-nested values
   comprised of the same scalars only by the number spaces between the scalars,
   which is difficult to see if the values are long or dee[ly nested.
   
   For that reason, APL interpreters often come with functions, either built-in
   or defined functions that displays the structure of nested values in a better
   way. In IBM APL2 these functions are called DISPLAY and DISPLAYC (in workspace
   DISPLAY, the two functions slightly differ in style). In GNU APL the functions
   are built-in and are several subfunctions of dyadic ⎕CR (e.g. 4 ⎕CR and 8 ⎕CR,
   also slightly differing in style). In GNU APL, ⎕CR is a collection of more
   than 40 subfunctions, some of which play the roles of <B>DISPLAY</B> in IBM APL2.
   For example:
   
<pre class=input_T line=602>      1 2 'AB' 3 4       ⍝ standard output formatting</pre>
<pre class=output1> 1 2 AB 3 4 
</pre>
<pre class=input_ line=603>      4 ⎕CR 1 2 'AB' 3 4      ⍝ same value in 4⎕CR style</pre>
<pre class=output1>┏→━━━━━━━━━━━┓
┃1 2 ┏→━┓ 3 4┃
┃    ┃AB┃    ┃
┃    ┗━━┛    ┃
┗ϵ━━━━━━━━━━━┛
</pre>
<pre class=input_ line=603>      8 ⎕CR 1 2 'AB' 3 4      ⍝ same value in 8⎕CR style</pre>
<pre class=output1>┌→───────────┐
│1 2 ┌→─┐ 3 4│
│    │AB│    │
│    └──┘    │
└ϵ───────────┘
</pre>
<pre class=input_ line=603>      1 2 (10 11) 3 4         ⍝ standard output formatting</pre>
<pre class=output1> 1 2  10 11  3 4 
</pre>
<pre class=input_ line=603>      4 ⎕CR 1 2 (10 11) 3 4   ⍝ same value in 4⎕CR style</pre>
<pre class=output1>┏→━━━━━━━━━━━━━━┓
┃1 2 ┏→━━━━┓ 3 4┃
┃    ┃10 11┃    ┃
┃    ┗━━━━━┛    ┃
┗ϵ━━━━━━━━━━━━━━┛
</pre>
<pre class=input_ line=603>      8 ⎕CR 1 2 (10 11) 3 4   ⍝ same value in 8⎕CR style</pre>
<pre class=output>┌→──────────────┐
│1 2 ┌→────┐ 3 4│
│    │10 11│    │
│    └─────┘    │
└ϵ──────────────┘
</pre>
   
   
   Some users prefer that APL output is always displayed in the format of 8 ⎕CR
   (or in one of the other styles that ⎕CR provides). This can be achived by a
   GNU APL command:
   
<pre class=input_T line=602>      1 2 'AB' 3 4   ⍝ by default: standard output formatting</pre>
<pre class=output1> 1 2 AB 3 4 
</pre>
<pre class=input_ line=603>      ⍝ display results automatically in 8 ⎕CR format</pre>
<pre class=input_ line=603>      ]BOXING 8</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      1 2 'AB' 3 4</pre>
<pre class=output1>┌→───────────┐
│1 2 ┌→─┐ 3 4│
│    │AB│    │
│    └──┘    │
└ϵ───────────┘
</pre>
<pre class=input_ line=603>      ⍝ back to the standard format</pre>
<pre class=input_ line=603>      ]BOXING OFF</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      1 2 'AB' 3 4</pre>
<pre class=output1> 1 2 AB 3 4 
</pre>
   <pre class=output></pre>
   
   <h4><a id="CH_3.1.5"></a>
   3.1.5 Multi-Line Strings</h4>
   
   In APL1 a text with several lines would normally be expressed as a two
   dimensinal character matrix:
   
<pre class=input_T line=602>      3 5⍴"Peter", "Paul ", "Mary "   ⍝ 3-line APL1 text matrix</pre>
<pre class=output>Peter
Paul 
Mary 
</pre>
   
   
   That approach becomes rather cumbersome and inefficient when the number
   of text rows is large (a single long line would "blow up" the other lines
   to its length, yielding a larger than necessary matrix that consist mostly
   of trailing spaces).  In the days of APL1 that was sort of acceptable
   because the focus was more on numerical computations rather than text
   processing and the rare texts were mostly used as short decorators
   for the numbers displayed.
   
   Things have changed since then and with the advent of nested values in APL2
   one would express long texts as a vector of nested strings rather than as
   character matrices:
   
<pre class=input_T line=602>      "Peter" "Paul" "Mary"   ⍝ nested 3-item APL2 vector (note the lack of trailing input spaces and the output indentation)</pre>
<pre class=output1> Peter Paul Mary 
</pre>
   
   
<pre class=input_ line=603>      ⊃ "Peter" "Paul" "Mary"   ⍝ back to APL1 text matrix (not indented)</pre>
<pre class=output>Peter
Paul 
Mary 
</pre>
   
   
   Even though this improves over APL1, it is still cumbersome if the number
   of lines is large or not known beforehand. In that case one often finds,
   even in APL2, constructs like:
   
<pre class=input_T line=602>      TEXT←3⍴0      ⍝ reserve space for 3 lines</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      TEXT[1]←⊂'Peter'   ⍝ ⊂ turns text vector 'Peter' into a nested scalar</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      TEXT[2]←⊂'Paul'</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      TEXT[3]←⊂'Mary'</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      ⊃ TEXT</pre>
<pre class=output>Peter
Paul 
Mary 
</pre>
   
   
   Or, even worse (since the execution time increases quadratically with the
   number of lines):
   
<pre class=input_T line=602>      TEXT←⍬        ⍝ start with an empty vector</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      TEXT ← TEXT, ⊂'Peter'   ⍝ append line 'Peter'</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      TEXT ← TEXT, ⊂'Paul'    ⍝ append line 'Paul' (no trailing space needed)</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      TEXT ← TEXT, ⊂'Mary'    ⍝ append line 'Mary  (no trailing space needed)</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      ⊃ TEXT</pre>
<pre class=output>Peter
Paul 
Mary 
</pre>
   
   
   To further improve and simplify the specification of multi-line texts, which
   is a problem that often occur in real life APL programs, GNU APL has adopted
   the concept
   of multi-line strings from the Python language or from the bash shell.
   A multi-line string starts and ends with triple quotes and the lines
   between become a nested text vector:
   
   <pre class=input_T>      TEXT ←  """
→      Peter
→      Paul
→      Mary
→            """
      8 ⎕CR TEXT</pre>
   <pre class=output>┌→────────────────────┐
│┌→────┐ ┌→───┐ ┌→───┐│
││Peter│ │Paul│ │Mary││
│└─────┘ └────┘ └────┘│
└ϵ────────────────────┘</pre>
   
<pre class=input_T line=602>      ⊃ TEXT</pre>
<pre class=output>Peter
Paul 
Mary 
</pre>
   
   
   Note the → prompt (from APL), which indicates that a multi-line string has
   started but not yet ended. The characters in the triple quotes shall be
   either " or else \<br>
    in the trailing triple quotes
   (the same holds, BTW also for normal GNU APL strings. Intelligent editors
   are able to jump back and forth between matching quotes, but only if the
   leading quote differs from the trailing quote. Use this capability with care,
   since it undermines the portability of APL code written for GNU APL.
   
   
   <h4><a id="CH_3.1.6"></a>
   3.1.6 Summary and Remarks</h4>
   
   Constants are used for creating fixed APL values. There are many APL values
   that cannot be expressed by constants, for example numeric vectors with only
   one components, or higher-dimensional values like matrices. These values
   can only be created using functions (as explained further down).
   
   <h3><a id="CH_3.2"></a>
   3.2 APL Names</h3>
   
   APL knows 3 kinds of names:
   
   <ul>
   <li>user defined names,</li>
   <li>names of system functions and variables, and</li>
   <li>names of primitive APL functions (or primitives for short)</li>
   </ul>
   
   
   <h4><a id="CH_3.2.1"></a>
   3.2.1 User-defined Names</h4>
   
   User-defined names start with a letter (A-Z or a-z) or one of the 3 characters
   _ (underscore), ∆ (delta), or ⍙ (delta-underline. The starting
   character may be followed by letters, digits, or one of the characters
   ¯ (overbar), _, ∆, or ⍙. The ∆ and ⍙ characters are often used to separate
   some common prefix (for example the name of a library) from the functions
   and variables that are somehow related (for example the functions and
   variables that belong to a library). User-defined Names are case-sensitive,
   i.e. <B>Foo</B> and <B>FOO</B> are different names.
   
   User-defined names are used to denote APL variables, defined functions,
   defined operators, or labels in defined functions or operators.
   
   <h4><a id="CH_3.2.2"></a>
   3.2.2 Names of System Functions and System Variables</h4>
   
   The names of system functions start with the APL character ⎕ (quad) followed by
   a small number of letters. System names are case-insensitive, i.e. <B>⎕IO</B> is
   the same as <B>⎕io</B>. Older APL programmers seem to prefer uppercase,
   presumably because the first APL interpreters had no lowercase characters.
   
   Only a handful of system functions and variables are standardized in the ISO
   standards 8485 and 13751, but every APL interpreter adds many more. Those that
   are not defined in the standards differ considerably between APL interpreters
   from different vendors even if their names are the same. Adding non-standard
   system functions and variables are the standard way of adding featurres to
   the APL language; they usually add functions whose implementation in APL would
   be inefficient or cumbersome.
   
   <h4><a id="CH_3.2.3"></a>
   3.2.3 Names of Primitive APL Functions</h4>
   
   The names of primitive functions are single APL characters that different from
   all characters allowed in user-defined names.
   
   Almost all the primitive APL functions (and hence their names) are
   identical in all APL interpreters and are standardized in ISO standard 13751.
   
   Apart from the differences mentioned above, there is no real difference
   between system functions and primitive APL functions.
   
   <h3><a id="CH_3.3"></a>
   3.3 Functions and Operators</h3>
   
   In APL functions can have no, one, or two arguments.
   Functions with no argument are called <B>niladic</B>, functions with one argument
   are called <B>monadic</B>, and functions with two arguments are called
   <B>dyadic</B>.
   
   Some monadic or dyadic functions can have another, optional, argument used for
   specifying an axis (a dimension along which the function is computed). In
   standard APL, only primitive APL functions can have an axis argument, but
   GNU APL also supports an axis argument for defined functions.
   
   Most dyadic functions can also be called with only one argument. These functions
   are called <B>nomadic</B>. This basically means that the same function name is
   used for two different functions. The two functions are often related. For
   example, ÷ is nomadic; its dyadic variant A ÷ B (called divide) divides A by B
   while its monadic variant (called inverse) divides 1 by B. Another way of
   putting this is: a nomadic function is a dyadic function whose left argument
   is optional (and omitting it changes its behaviour).
   
   <h4><a id="CH_3.3.1"></a>
   3.3.1 Niladic Functions</h4>
   
   A niladic function takes no arguments. A niladic function call is simply the
   name of the niladic function. For example, ⎕TS is a niladic system function
   that returns the current time as year, month, day, hours, minutes, seconds,
   and milliseconds:
   
<pre class=input_T line=602>      ⎕TS</pre>
<pre class=output>2023 7 30 19 13 15 612
</pre>
   
   
   <h4><a id="CH_3.3.2"></a>
   3.3.2 Monadic Functions</h4>
   
   A <B>monadic function</B> takes one arguments. A monadic function call consists
   of the name of the function followed by its sole argument. For example, the
   monadic variant of the nomadic function ÷ computes the inverse of its argument:
   
<pre class=input_T line=602>      ÷ 2</pre>
<pre class=output1>0.5
</pre>
<pre class=input_ line=603>      ÷ 2J2</pre>
<pre class=output>0.25J¯0.25
</pre>
   
   
   If the optional axis argument mentioned above is supported, then it is
   placed to the right of the function name.
   
   <h4><a id="CH_3.3.3"></a>
   3.3.3 Dyadic Functions</h4>
   
   A <B>dyadic function</B> takes two arguments. A dyadic function call consists
   of the second (aka. left) argument, followed by the name of the function,
   followed by its other (aka. right)  argument. For example, the
   dyadic variant of the nomadic function ÷ computes the left argument divided
   by the right argument:
   
<pre class=input_T line=602>      4 ÷ 2</pre>
<pre class=output1>2
</pre>
<pre class=input_ line=603>      4J4 ÷ 2J2</pre>
<pre class=output>2
</pre>
   
   
   As the last example above shows, APL automatically converts numbers to their
   simplest form, i.e. from complex to real, from floating point to integer,
   and from integer to Boolean. At least it looks like that. A value that
   is, for example, printed like an integer may internally still be a real
   or even a complex number.
   
   In older APL interpreters there used to be a function ⎕DR (data representation)
   that would tell if an APL value was complex, real, integer, or Boolean.
   For mixed arrays introduced by ISO 13751 that does not make too much sense
   anymore and the function has disappeared.
   
   <h4><a id="CH_3.3.4"></a>
   3.3.4 Monadic Operators</h4>
   
   APL operators are functions that have one or two value arguments like monadic
   or dyadic functions, but in addition one or two function arguments.
   The attribute <B>monadic</B> resp. <B>dyadic</B> of an operator refers to the
   number of function arguments for the operator and not to the number of value
   arguments. If <B>OP1</B> is a monadic operator then <B>(f OP1)</B> is a so-called
   <B>derived function</B>; depending on the operator its derived functions can
   be monadic or dyadic.
   <br>
   
   <br>
   
   A <B>monadic operator</B> is therefore an operator that has one function argument,
   and a <B>dyadic operator</B> is an operator that has two function arguments.
   As far as built-in APL operators are concerned, one of them (the inner/outer
   matrix product .) is dyadic and all others are monadic.
   
   A monadic operator, together with its function, defines a new function: the
   <B>the derived function</B>. Likewise, a dyadic operator, together with both
   its functions, defines a derived function of that operator. Derived functions
   of the same operator but with different function arguments are, of course,
   different, but they are either all monadic functions or all dyadic functions.
   <br>
   
   <br>
   
   We take the presumably most frequently used operator, <B>reduction</B>, as
   example. The APL symbol for the reduction operator is / (slash). The function
   argument of a monadic operator is the function immediately left of the operator
   symbol. The reduction operator is monadic (taking one function argument),
   the function provided as function argument must be dyadic, and the derived
   function is monadic. The derived function of reduction with function argument
   f is also called f-reduction.
   <br>
   
   <br>
   
   When the value argument of f-reduction is a vector, then f-reduction computes
   the result of placing f between the vector elements:
   <br>
   
   <br>
   
   f-reduction v1 v2 ... vn ↔ v1 f v2 f ... vn
   <br>
   
   <br>
   
   If function f is + (addition) then f-reduction of a vector is the sum of
   its elements:
<pre class=input_T line=602>      +/1 2 3 4 5 6</pre>
<pre class=output>21
</pre>
   
   
   Likewise, if f is ⌈ (maximum) then f-reduction of a vector is the largest of
   its elements:
<pre class=input_T line=602>      ⌈/2 5 12 4 0</pre>
<pre class=output>12
</pre>
   
   
   The f-reduction of a matrix is a vector with the f-reduction  of each row:
<pre class=input_T line=602>      3 3⍴1 2 3 4 5 6 7 8 9</pre>
<pre class=output1>1 2 3
4 5 6
7 8 9
</pre>
<pre class=input_ line=603>      +/ (3 3⍴1 2 3 4 5 6 7 8 9)</pre>
<pre class=output>6 15 24
</pre>
   
   
   f-reduction is one of the functions that support an axis argument.
   The axis argument of f-reduction tells along which axis (i.e. rows or columns
   in the case of a matrix) the f-reduction shall be performed:
   
<pre class=input_T line=602>      +/[2] (3 3⍴1 2 3 4 5 6 7 8 9)</pre>
<pre class=output1>6 15 24
</pre>
<pre class=input_ line=603>      +/[1] (3 3⍴1 2 3 4 5 6 7 8 9)</pre>
<pre class=output>12 15 18
</pre>
    
   
   In GNU APL, user defined monadic operators can have an axis argument, which
   is, like for their built-in pendants, placed in brackets right of the operator
   symbol.
   
   <h4><a id="CH_3.3.5"></a>
   3.3.5 Dyadic Operators</h4>
   
   A dyadic operator s like a monadic operator but has two function arguments
   instead of one.
   If <B>OP2</B> is a dyadic operator then <B>(f OP1 g)</B> is its
   <B>derived function</B>. Depending on the operator, its derived functions
   can be monadic or dyadic. For some dyadic operators their "function
   arguments" may or must be APL values and not functions.
   
   The APL symbol for the inner product operator is . (dot). The function arguments
   of the inner product are placed immediately left and immediately right of the
   dot. If A and B are matrices, then <B>A +.× B</B> is the normal matrix product:
   
<pre class=input_T line=602>      A←3 3⍴1 2 3 4 5 6 7 8 9</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      A</pre>
<pre class=output1>1 2 3
4 5 6
7 8 9
</pre>
<pre class=input_ line=603>      A +.× A</pre>
<pre class=output> 30  36  42
 66  81  96
102 126 150
</pre>
   
   
   In general, for two matrices A and B and functions f and g, the inner product
   f.g is a matrix. The element in row i and column j in that matrix is obtained
   by applying function g to row i of A and column j of B and then to perform
   f-reduction of the (row f column) vector.
   
   Another way of looking at f.g (or at dyadic operators in general) is to
   consider (.g) as a derived monadic operator and f.g as f/(.g).
   However, dyadic operators cannot have an axis argument.
   
   <h3><a id="CH_3.4"></a>
   3.4 General APL Values</h3>
   
   The constants introduced so far were examples of APL values. However, many
   APL values can not be written as constants. In this chapter we will introduce
   APL values in a more formal way and we will show how arbitrary APL values
   can be constructed.
   
   An APL value is defined by two things: a list of scalars that is called
   the <B>ravel</B> of the value, and another list that is called the <B>shape</B>
   of the value. The shape determines how the ravel is arranged in order to
   produce an APL value.
   
   For example, the same ravel <B>1 2 3 4 5 6</B> can be arranged (or "shaped")
   in 5 different ways:
   <br>
   
   <br>
   
   1. as a 6-element vector:
   <B><pre>
      1 2 3 4 5 6
   </pre></B>
   
   2. as a 1 by 6 matrix:
   <B><pre>
      1 2 3 4 5 6
   </pre></B>
   
   3. as a 2 by 3 matrix:
   <B><pre>
      1 2 3
      4 5 6
   </pre></B>
   
   4. as a 3 by 2 matrix:
   <B><pre>
      1 2
      3 4
      5 6
   </pre></B>
   
   5. as a 6 by 1 matrix:
   <B><pre>
      1
      2
      3
      4
      5
      6
   </pre></B>
   <br>
   
   In this example, the shape selects between the 5 possible arrangements
   of the ravel. The ravel and the shape are not entirely independent.
   Instead the following relation is satisfied by every APL value:
   <br>
   
   <br>
   
   <B>The product of all shape elements is equal to the number of ravel elements</B>
   <br>
   
   <br>
   
   The number of shape elements, also called the <B>rank</B> of the value,
   determines into how many elements the shape has:
   <br>
   
   <br>
   
   <table cellspacing="0" cellpadding="0"><tr> <th> Rank <th> Commonly called
     <tr> <td class=tab> 0    <td class=tabC> Scalar (no shape dimension)
     <tr> <td class=tab> 1    <td class=tabC> Vector (one shape dimension)
     <tr> <td class=tab> 2    <td class=tabC> Matrix (two shape dimensions)
     <tr> <td class=tab> 3    <td class=tabC> Cube   (three shape dimensions)
     <tr> <td class=tab> ...  <td class=tabC> values with higher ranks (more than 3 shape dimensions)
   </table>
   
   <br>
   
   A value also has a <B>depth</B> which tells the level of nesting. Simple scalars
   have a depth if 0. All other values have a depth of
   (1 + the maximum depth of all ravel elements). Unlike the shape, which can be
   imposed on a value, the depth is a consequence of the rank (scalar or not) and
   the ravel of the value.
   
   APL programming is the art of creating new APL values from other APL values.
   The starting point are the constants discussed above and the new APL values
   are created from existing APL values by calling functions with the existing
   APL values as function arguments.
   
   You have probably heard that APL has a large number of built-in functions.
   As a consequence, the same new APL value can usually be created in many
   different ways. APL programmers tend to prefer the ways that contains the
   smallest number of function calls, even though that is is not always the
   "cleanest" way.
   
   It is not always obvious how to create a particular APL value. Therefore we
   present a (somewhat awkward) method that always works. This method uses only
   a handful of built-in APL functions that - no surprise - belong to the most
   frequently used functions in APL programs.
   
   <h4><a id="CH_3.4.1"></a>
   3.4.1 Reshape and Shape: ⍴</h4>
   
   Reshape is a simple, but powerful, function that creates values of arbitrary
   shapes. The function call A ⍴ B returns a new APL value Z with shape A and
   a ravel constructed from the ravel of value B as follows.
   
   Let len_B be the number of elements in the ravel of B, and
   let len_Z be the number of elements in the ravel of Z.
   
   <ul>
   <li>If len_Z = len_B, then the ravel of Z are the ravel of B.</li>
   <li>If len_Z < len_B, then the ravel of Z are the first len_Z elements
       of the ravel of B.</li>
   <li>If len_Z > len_B, then the ravel of B is appended to itself until one
       of the cases above occurs.</li>
   </ul>
   
   
   Note that the shape of B plays no role in the computation of function reshape.
   Most frequently scalars and vectors are being reshaped.
   
   We can now enter the 5 examples above (which are all cases where
   len_Z = len_B) in APL:
   
<pre class=input_T line=602>      6 ⍴ 1 2 3 4 5 6</pre>
<pre class=output1>1 2 3 4 5 6
</pre>
<pre class=input_ line=603>      1 6 ⍴ 1 2 3 4 5 6</pre>
<pre class=output1>1 2 3 4 5 6
</pre>
<pre class=input_ line=603>      2 3 ⍴ 1 2 3 4 5 6</pre>
<pre class=output1>1 2 3
4 5 6
</pre>
<pre class=input_ line=603>      3 2 ⍴ 1 2 3 4 5 6</pre>
<pre class=output1>1 2
3 4
5 6
</pre>
<pre class=input_ line=603>      6 1 ⍴ 1 2 3 4 5 6</pre>
<pre class=output>1
2
3
4
5
6
</pre>
   
   
   An examples with len_Z < len_B) is this:
   
<pre class=input_T line=602>      2 2 ⍴ 1 2 3 4 5 6</pre>
<pre class=output>1 2
3 4
</pre>
   
   
   The most powerful case is len_Z > len_B, in particular when len_B is small:
   
<pre class=input_T line=602>      10 10 ⍴ 1 2</pre>
<pre class=output>1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
</pre>
   
   
   Another illustrative example is the creation of a unity matrix. Will will later
   repeat the creation of a unity matrix with other functions. Creating a
   unity matrix with function reshape is somewhat less "clean" than other
   methods, but short and effective (and therefore frequently seen in APL code):
   
<pre class=input_T line=602>      5 5 ⍴ 1 0 0 0 0 0</pre>
<pre class=output>1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0
0 0 0 0 1
</pre>
   
   
   The monadic variant of ⍴ is called <B>Shape</B> and returns the shape of its
   right argument:
   
<pre class=input_T line=602>      ⍴ 1 0 0 0 0 0</pre>
<pre class=output1>6
</pre>
<pre class=input_ line=603>      ⍴ (5 5⍴1 0 0 0 0 0)</pre>
<pre class=output>5 5
</pre>
   
   
   The parentheses in the last example are not required, but were added for
   clarity. Like in other languages, expressions in parentheses are evaluated
   first and the result replaces the parentheses and their content.
   The shape of a scalar is an empty vector. Empty vectors produce
   an empty APL output:
   
<pre class=input_T line=602>      ⍴ 5     ⍝ Shape of a numeric scalar (output is an empty vector)</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      ⍴ ' '   ⍝ Shape of a character scalar (output is an empty vector)</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      ⍴ ''    ⍝ Shape of an empty vector</pre>
<pre class=output>0
</pre>
   
   
   <h4><a id="CH_3.4.2"></a>
   3.4.2 Catenate and Ravel: , and ⍪</h4>
   
   The next important function on the way to arbitrary APL values is "catenate",
   or dyadic , (comma). The function call A , B appends values A and B. If A
   and B are scalars or vectors then the result is somewhat obvious:
   
<pre class=input_T line=602>      1 1 1 , 2 2 2   ⍝ append vector 1 1 1 and vector 2 2 2</pre>
<pre class=output1>1 1 1 2 2 2
</pre>
<pre class=input_ line=603>      1 1 1 , 'bbb'   ⍝ append vector 1 1 1 and vector 'bbb'</pre>
<pre class=output>1 1 1 bbb
</pre>
   
   
   If A or B is a matrix or a value with even higher rank, then there are
   different ways to catenate two values. This is where the optional comes
   into play. The axis argument determines along which axis
   the concatenation shall take place:
   
<pre class=input_T line=602>      2 2⍴'A'</pre>
<pre class=output1>AA
AA
</pre>
<pre class=input_ line=603>      2 2⍴'B'</pre>
<pre class=output1>BB
BB
</pre>
<pre class=input_ line=603>      (2 2⍴'A') ,[1] (2 2⍴'B')</pre>
<pre class=output1>AA
AA
BB
BB
</pre>
<pre class=input_ line=603>      (2 2⍴'A'),[2] (2 2⍴'B')</pre>
<pre class=output>AABB
AABB
</pre>
   
   
   The axes of a value are the different elements of its shape vector. A scalar
   has no axes, a vector has one axis, a matrix has two axes, and so on. When
   an APL value is printed then the last axis of the value is printed
   horizontally (on the same output line) while the other axes are printed
   vertically (on different output lines). The default axis for concatenate,
   i.e. the axis used when no axis argument is given, is the last axis.
   There is a companion function of , comma) namely ⍪ (comma-bar) that is
   identical to comma if an axis is provided, but uses the first axis rather
   than the last axis if not. Therefore the last two examples could have
   been written without an axis argument like this:
   
<pre class=input_T line=602>      (2 2⍴'A') ⍪ (2 2⍴'B')</pre>
<pre class=output1>AA
AA
BB
BB
</pre>
<pre class=input_ line=603>      (2 2⍴'A') , (2 2⍴'B')</pre>
<pre class=output>AABB
AABB
</pre>
   
   <br>
   
   <br>
   
   <B>Note:</B> There are some more function pairs that differ only by their default
   behavior when no axis argument is given: ⊖ and ⌽, / and ⌿, and  \ and ⍀.
   The variant with - in the symbol takes the first axis by default while the
   other variant takes the last axis.
   
   The monadic variant of , and ⍪ is a monadic function called "ravel" and
   returns the ravel of the value. While function reshape can be used,
   among other things, to create values of higher or lower ranks than vectors,
   function ravel does the opposite: it brings the rank of values with higher
   or lower ranks down to rank 1. In other words, function ravel converts a
   value with arbitrary shape to a vector. If a value is a value already then
   function ravel returns (a copy of) that vector.
   
   <h4><a id="CH_3.4.3"></a>
   3.4.3 Universal Character Set (monadic ⎕UCS)</h4>
   
   Function ⎕UCS is monadic and computes a value with the same shape as its
   right argument. The right argument must be simple (i.e. not nested) values
   whose ravel consists of all integers or all characters. Integers are
   converted to characters with the same Unicode, while characters are converted
   to an integer with the Unicode of the character.
   
   In most cases the characters that you use in strings will be on your
   keyboard, but function ⎕UCS can be used if they are not.
   
   Examples:
   
<pre class=input_T line=602>      ⎕UCS 'APL ⍴⍪ $¥£€⍧ ÄÖÜäöüß'    ⍝ Unicode → integer conversion</pre>
<pre class=output1>65 80 76 32 9076 9066 32 36 165 163 8364 9063 32 196 214 220 228 246 252 223
</pre>
<pre class=input_ line=603>      ⎕UCS 65 80 76 32 9076 9066 32 36 165 163 8364 9063 32 196 214 220 228 246 252 223  ⍝ And back to Unicode</pre>
<pre class=output>APL ⍴⍪ $¥£€⍧ ÄÖÜäöüß
</pre>
   
   
   <h4><a id="CH_3.4.4"></a>
   3.4.4 Construction of arbitrary simple values</h4>
   
   The functions reshape, concatenate, and occasionally ⎕UCS can be combined in
   order to constructing arbitrary simple (i.e. not nested) values. We assume,
   of course, that it is known how the value shall look like. The algorithm
   for constructing the new value is then:
   
   <ol>
     <li>construct the shape vector of the new value from smaller items such 
     as integer scalars or vectors. The integer scalars can be constants or
     other integer vectors computed elsewhere. Concatenate (dyadic ,) the
     smaller pieces as needed. Put everything in parentheses (in many cases the
     parentheses are optional and can be removed, but to be on the safe side we
     leave them in).</li>
   
     <li>construct the ravel of the new value from smaller items such as
     integer scalars, integer vectors, character scalars and character vectors.
     Possibly use ⎕UCS to create character or vectors using their Unicode.
     Concatenate (dyadic ,) the smaller pieces as needed.</li>
   
     <li>reshape the ravel with the shape vector using dyadic ⍴.</li>
   </ol>
   
   
   Steps 1 and 2 are independent, so you can do 2 before 1.
   As an alert reader you will have noticed that you cannot create new
   scalars because a scalar has a shape vector of length 0, and we
   have seen earlier that empty integer constants do not exist.
   
   In older APL interpreters this was solved by using an empty character
   vector instead of an empty integer vector:
   
<pre class=input_T line=602>      '' ⍴ 1 2 3 4 5 6        ⍝ reshape 1 2 3 4 5 6 to a scalar</pre>
<pre class=output1>1
</pre>
<pre class=input_ line=603>      ⍴ ('' ⍴ 1 2 3 4 5 6)    ⍝ shape of '' ⍴ 1 2 3 4 5 6</pre>
<pre class=output>

</pre>
   
   
   This worked well and you will find ''⍴ all over the place in older APL programs.
   In newer APL interpreters, including GNU APL, a constant ⍬ (zilde) was
   introduced. ⍬ is an empty numeric vector. ⍬⍴ is cleaner than ''⍴ because
   a shape should always be an integer vector, but the portability of APL programs
   using ''⍴ is better than that of ⍬⍴.
   <br>
   
   You may also wonder if vectors can be created with the above algorithm (and
   remembering that there are not only no integer vector constants of length 0,
   but also no integer vector constants of length 1).
   The answer is "yes" because the left argument A of A⍴B can be a vector
   or a scalar (the scalar is then treated like a 1-element vector).
   Note also, that when creating arbitrary simple vectors, Step 2 alone
   suffices in most cases. For simple vectors, steps 1 and 3 are only needed
   if the ravel constructed in step 2 has the wrong length.
   
   <h4><a id="CH_3.4.5"></a>
   3.4.5 Construction of arbitrary nested values</h4>
   
   The <B>depth</B> of a nested value is recursively defined as:
   
   <ul>
   <li>0, if the value is a simple scalar</li>
   <li>1, if the value is a simple vector</li>
   <li>N+1, if the value is nested and N is the depth of its deepest ravel element</li>
   </ul>
   
   The monadic APL function ≡ (called <B>Depth</B>) returns the depth of an
   APL value.
   <br>
   
   In the previous chapter we have seen how arbitrary simple values, i.e.
   values of depth 0 or 1 are constructed. We can now create a value of depth
   N + 1 recursively:
   
   <ul>
   <li>construct the shape vector in the same way as for arbitrary simple values.</li>
   
   <li>construct the ravel of the new value from smaller items such as
   integer scalars, integer vectors, character scalars and character vectors,
   and items with a depth N or less. Enclose non-simple ravel items (i.e. items
   with depth > 1) in parentheses.</li>
   
   <li>reshape the ravel with the shape vector using dyadic ⍴.</li>
   </ul>
   
   
   Examples:
   
<pre class=input_T line=602>      1 2 3        ⍝ three element vector</pre>
<pre class=output1>1 2 3
</pre>
<pre class=input_ line=603>      ⍴1 2 3       ⍝ how many elements?</pre>
<pre class=output1>3
</pre>
<pre class=input_ line=603>      ≡1 2 3       ⍝ how deep?</pre>
<pre class=output1>1
</pre>
<pre class=input_ line=603>      1 (2 3)      ⍝ two (!) element vector with nested second element</pre>
<pre class=output1> 1  2 3 
</pre>
<pre class=input_ line=603>      ⍴1 (2 3)     ⍝ how many elements?</pre>
<pre class=output1>2
</pre>
<pre class=input_ line=603>      ≡1 (2 3)     ⍝ how deep?</pre>
<pre class=output1>2
</pre>
<pre class=input_ line=603>      1 (2 (3 4))  ⍝ two element vector with nested second element</pre>
<pre class=output1> 1   2  3 4  
</pre>
<pre class=input_ line=603>      ⍴1 (2 3)     ⍝ how many elements?</pre>
<pre class=output1>2
</pre>
<pre class=input_ line=603>      ≡1 (2 3)     ⍝ how deep?</pre>
<pre class=output>2
</pre>
   
   
   When the APL interpreter prints nested values then it prints extra spaces
   around them. These spaces distinguish nested values from their simple
   counterparts with the same ravel elements, but makes it rather difficult
   to understand values with deeper nesting.
   
   <h4><a id="CH_3.4.6"></a>
   3.4.6 Displaying the structure of values</h4>
   
   We have seen n the examples above that that some APL values look the same
   (e.g. numeric scalars and numeric vectors) or very similar (nested values
   with the same elements in their ravels, like 1 2 3 vs. 1 (2 3) above).
   For that reason, APL interpreters that support nested values typically
   come with a function calls <B>Display</B> that shows the structure of a value
   in a better way. This function is very useful for analyzing problems that
   are caused by different values that look similar:
   
<pre class=input_T line=602>      1 2 3 + 1 2 3      ⍝ add two 3 element vectors</pre>
<pre class=output1>2 4 6
</pre>
<pre class=input_ line=603>      1 2 3 + 1 (2 3)    ⍝ add 3 element vector and 2 element vector</pre>
<pre class=errput>LENGTH ERROR
      1 2 3+1 (2 3)
      ^    ^
</pre>
   
   
   Since the Display function is of such importance, GNU APL has made it a
   built-in function called dyadic ⎕CR. The monadic ⎕CR (character
   representation) is a standard function in all APL interpreters that converts
   APL values and user defined functions into character strings. The left
   argument of dyadic ⎕CR does the same, but its left argument lets you choose
   one of several formats. Format 4 of ⎕CR selects a format that is very similar
   to the output of the <B>Display</B> function in other interpreters:
   
<pre class=input_T line=602>      8 ⎕CR 1         ⍝ show structure of scalar 1</pre>
<pre class=output1>1
</pre>
<pre class=input_ line=603>      8 ⎕CR 1 2 3     ⍝ show structure of simple vector 1 2 3</pre>
<pre class=output1>┌→────┐
│1 2 3│
└─────┘
</pre>
<pre class=input_ line=603>      8 ⎕CR 1 (2 3)   ⍝ show structure of nested vector 1 (2 3)</pre>
<pre class=output1>┌→──────┐
│1 ┌→──┐│
│  │2 3││
│  └───┘│
└ϵ──────┘
</pre>
<pre class=input_ line=603>      8 ⎕CR 1 (2 (3 4))   ⍝ show structure of nested vector 1 (2 (3 4))</pre>
<pre class=output1>┌→──────────┐
│1 ┌→──────┐│
│  │2 ┌→──┐││
│  │  │3 4│││
│  │  └───┘││
│  └ϵ──────┘│
└ϵϵ─────────┘
</pre>
<pre class=input_ line=603>      8 ⎕CR (2 2⍴ 1 2 3 4)    ⍝ show structure of simple matrix 2 2 ⍴ 1 2 3 4</pre>
<pre class=output1>┌→──┐
↓1 2│
│3 4│
└───┘
</pre>
<pre class=input_ line=603>      8 ⎕CR (2 2⍴ 1 2 3 (2 2⍴4))    ⍝ a nested matrix</pre>
<pre class=output>┌→──────┐
↓1     2│
│       │
│3 ┌→──┐│
│  ↓4 4││
│  │4 4││
│  └───┘│
└ϵ──────┘
</pre>
   
   
   8 ⎕CR is a character matrix constructed according to the following rules:
   
   <ul>
   <li>the matrix consists of a <B>frame</B> (solid line) that surrounds
       its <B>content</B>.</li>
   <li>The content is created from the ravel elements of the value that are
     arranged according to the shape of the value.i If a ravel element is a
     nested value then that value is displayed with its own frame (and these rules
     apply recursively.</li>
   <li>The frame can contain additional indicators. If the rank of the value
    is ≥ 1 then the the horizontal top line of the frame contains information
    pertaining to the last dimension of the value. If the rank of the value
    is ≥ 2 then the the vertical left line of the frame contains information 
    pertaining to the other dimensions of the value. The horizontal bottom line
    of the frame is related to the depth of the ravel.</li>
   <li>An arrow (→ on the top line or ↓ on the left line) indicates that the
       corresponding dimension(s) are present and non-empty.</li>
   <li>An ⊖ on the top line or ⌽ on the left line) indicates that the
    corresponding dimension(s) are present but empty. In this case the ravel
    has length 0 and instead of the empty ravel the <B>prototype</B> of the value,
    a concept explained later on, is shown.</li>
   <li>An ∊ on the bottom line indicates that the ravel contains nested elements;
     multiple ∊ indicate deeper nesting.</li>
   </ul>
   
   
   <h4><a id="CH_3.4.7"></a>
   3.4.7 Vector Notation versus Catenation</h4>
   
   For beginners the difference between vector notation (a sequence of items
   separated by spaces) and catenation (a sequence of items separated bi commas)
   can be confusing because often, in particular for simple scalars and vectors,
   both of them produce the same result:
   
<pre class=input_T line=602>      1 2 3</pre>
<pre class=output1>1 2 3
</pre>
<pre class=input_ line=603>      1,2,3</pre>
<pre class=output>1 2 3
</pre>
   
   
   In the example above, vector notation executes faster because no function
   needs to be computed. Sometimes, however, vector notation may produce a
   result other than expected:
   
<pre class=input_T line=602>      1 2 3 (4 5)</pre>
<pre class=output1> 1 2 3  4 5 
</pre>
<pre class=input_ line=603>      8 ⎕CR 1 2 3 (4 5)</pre>
<pre class=output1>┌→──────────┐
│1 2 3 ┌→──┐│
│      │4 5││
│      └───┘│
└ϵ──────────┘
</pre>
<pre class=input_ line=603>      1 2 3,(4 5)</pre>
<pre class=output1>1 2 3 4 5
</pre>
<pre class=input_ line=603>      8 ⎕CR 1 2 3,(4 5)</pre>
<pre class=output>┌→────────┐
│1 2 3 4 5│
└─────────┘
</pre>
   
   
   Vector notation starts with the leftmost item and adds one item for every
   space (or group of spaces). If an item added is not a scalar (like (4 5) in
   the example above) then the item is automatically converted to a nested
   value.
   
   Catenation works differently; in the above example the two vectors 1 2 3 and
   (4 5) are simply catenated to form a vector of length 5.
   
   The parentheses in (4 5) in in the catenation example were redundant, while
   the parentheses in the vector notation were not. Once again 8 ⎕CR helped to
   clarify the matter.
   
   <h4><a id="CH_3.4.8"></a>
   3.4.8 Scalar Extension</h4>
   
   Before continuing we need to introduce a fundamental APL mechanism called
   <B>scalar extension</B>. This mechanism is applied in many places.
   <br>
   
   Almost all built-in APL functions are partial, which means that there are
   arguments for which the function returns an error instead of a result. Some
   of the very few total (i.e. non-partial) functions are monadic ⍴
   and monadic ≡. Typically dyadic function put more requirements on their
   arguments than monadic functions. The reason is that not only must the
   individual left and right arguments satisfy some conditions, but the left
   and right arguments must also fit to each other. For example:
   
<pre class=input_T line=602>      1 2 3 + 1 2 3   ⍝ 1 2 3 is a valid arguments for +</pre>
<pre class=output1>2 4 6
</pre>
<pre class=input_ line=603>      1 2 + 1 2       ⍝ 1 2 is also a valid arguments for +</pre>
<pre class=output1>2 4
</pre>
<pre class=input_ line=603>      1 2 + 1 2 3     ⍝ they cannot be mixed, though</pre>
<pre class=errput>LENGTH ERROR
      1 2+1 2 3
      ^  ^
</pre>
   
   
   The most common requirement of dyadic functions is that the left
   and right argument have the same shape. The sum of two 3 element vectors
   makes sense, while the sum of a 2 element vector and a 3 element vector
   does not:
   
<pre class=input_T line=602>      1 2 3 + 4 5 6    ⍝ OK to add two 3 element vectors</pre>
<pre class=output1>5 7 9
</pre>
<pre class=input_ line=603>      1 2 3 + 4 5      ⍝ not OK to add  2 element vector to 3 element vector</pre>
<pre class=errput>LENGTH ERROR
      1 2 3+4 5
      ^    ^
</pre>
   
   
   Now scalar extension is an exception to most matching shape requirements.
   If one of the arguments of a dyadic function is a scalar, and if the function
   supports scalar extension, then the scalar argument is automatically reshaped
   to the shape of the other argument. (If both arguments were scalar, then they
   have the same shape already and scalar extension would have no noticeable
   effect).
   
<pre class=input_T line=602>      1 2 3 + 4      ⍝ OK by virtue of scalar extension of right argument</pre>
<pre class=output1>5 6 7
</pre>
<pre class=input_ line=603>      1 + 4 5 6      ⍝ OK by virtue of scalar extension of left argument</pre>
<pre class=output>5 6 7
</pre>
   
   
   Scalar extension is applied recursively. If a some ravel element of a
   value A is nested and the corresponding ravel of B is bot (or vice
   versa) then the non-nested element is scalar extended to the other:
   
<pre class=input_T line=602>      1 2 3 4 + 1 2 3      ⍝ expect length error</pre>
<pre class=errput1>LENGTH ERROR
      1 2 3 4+1 2 3
      ^      ^
</pre>
<pre class=input_ line=603>      1 2 (3 4) + 1 2 3    ⍝ 3 is scalar extended to match (3 4)</pre>
<pre class=output> 2 4  6 7 
</pre>
   
   
   <h4><a id="CH_3.4.9"></a>
   3.4.9 List of Built-in Scalar Functions</h4>
   
   The power of APL comes from the large number of built-in functions.
   Most of them belong to a category called scalar functions and below is
   a list of them. Normally the monadic and the dyadic variants are closely
   related and are both scalar functions. An exception is ∼ where the monadic
   form is a scalar function while the dyadic form is not.
   <br>
   
   <br>
   
   <table class=table1 cellspacing="0" cellpadding="0"> <tr>
     <th class="tab12" colspan="2">Dyadic: Z←A FUN B
     <th class="tab3"> FUN
     <th class="tab45" colspan="2">Monadic: Z←FUN B
   
    <tr>
     <th class="tab1"> Name/Description
     <th class="tab2"> Example(s)
     <th class="tab3"> &nbsp;
     <th class="tab4"> Name/Description
     <th class="tab5" colspan="5"> Example(s)
   
    <tr>
     <td class=tab1><B>Plus</B><br>
   Z is A plus B
     <td class=tab12><pre class=input4 line=595>      2 + 3</pre>
<pre class=output4>5
</pre>
   
     <td class=tab3> +
     <td class=tab4><B>Conjugate</B><br>
   
           Z is the complex<br>
   
           conjugate of B
     <td class=tab5><pre class=input4 line=595>      + 1J42</pre>
<pre class=output4>1J¯42
</pre>
   
   
    <tr>
     <td class=tab1><B>Minus</B><br>
   Z is A minus B
     <td class=tab12><pre class=input4 line=595>      2 - 3</pre>
<pre class=output4>¯1
</pre>
   
     <td class=tab3> -
     <td class=tab4><B>Negative</B><br>
   
           Z is the negative of B
     <td class=tab5><pre class=input4 line=595>      - ¯2</pre>
<pre class=output4>2
</pre>
   
   
    <tr>
     <td class=tab1><B>Times</B><br>
   Z is A times B
     <td class=tab12><pre class=input4 line=595>      2 × 3</pre>
<pre class=output4>6
</pre>
   
     <td class=tab3> ×
     <td class=tab4><B>Direction</B><br>
   
           Z is 1, 0, or ¯1 resp.
           if B > 0, B = 0, or B < 0
     <td class=tab5><pre class=input4 line=595>      × ¯5</pre>
<pre class=output4>¯1
</pre>
   
   
    <tr>
     <td class=tab1><B>Divide</B><br>
   
           Z is A divided by B
     <td class=tab12><pre class=input4 line=595>      3÷2</pre>
<pre class=output4>1.5
</pre>
   
     <td class=tab3> ÷
     <td class=tab4><B>Reciprocal</B><br>
   Z is 1 ÷ B
     <td class=tab5><pre class=input4 line=595>      ÷4</pre>
<pre class=output4>0.25
</pre>
   
   
    <tr>
     <td class=tab1><B>Minimum</B> <br>
   
           Z is the smaller of A and B
     <td class=tab12><pre class=input4 line=595>      2 ⌊ 3</pre>
<pre class=output4>2
</pre>
   
     <td class=tab3> ⌊
     <td class=tab4><B>Floor</B> <br>
   
           Z is B rounded down
     <td class=tab5><pre class=input4 line=595>      ⌊ 4.7</pre>
<pre class=output4>4
</pre>
   
   
    <tr>
     <td class=tab1><B>Maximum</B> <br>
   
           Z is the larger of A and B
     <td class=tab12><pre class=input4 line=595>      2 ⌈ 3</pre>
<pre class=output4>3
</pre>
   
     <td class=tab3> ⌈
     <td class=tab4><B>Ceiling</B><br>
   
           Z is B rounded up
     <td class=tab5><pre class=input4 line=595>      ⌈ 4.7</pre>
<pre class=output4>5
</pre>
   
   
    <tr>
     <td class=tab1><B>Power</B><br>
   
           Z is A raised to<br>
   
           the B<SUP>th</SUP> power
     <td class=tab12><pre class=input4 line=595>      2⋆3</pre>
<pre class=output4>8
</pre>
   
     <td class=tab3> ⋆
     <td class=tab4><B>Exponential</B><br>
   
           Z is <B>e</B> to<br>
   
           the B<SUP>th</SUP> power
     <td class=tab5><pre class=input4 line=595>      ⋆1</pre>
<pre class=output4>2.718281828
</pre>
   
   
    <tr>
     <td class=tab1><B>Logarithm</B><br>
   
           Z is the logarithm<br>
   
             of B to base A
     <td class=tab12><pre class=input4 line=595>      2⍟8</pre>
<pre class=output4>3
</pre>
   
     <td class=tab3> ⍟
     <td class=tab4><B>Natural Logarithm</B><br>
   
           Z is the natural<br>
   
           logarithm of B
     <td class=tab5><pre class=input4 line=595>      ⍟8</pre>
<pre class=output4>2.079441542
</pre>
   
   
    <tr>
     <td class=tab1><B>Residue</B> <br>
    Z is B modulo A
     <td class=tab12><pre class=input4 line=595>      10∣13</pre>
<pre class=output4>3
</pre>
   
     <td class=tab3> ∣
     <td class=tab4><B>Magnitude</B> <br>
   
           Z is the magnitude of B
     <td class=tab5><pre class=input4 line=595>      ∣3J4</pre>
<pre class=output4>5
</pre>
   
   
    <tr>
     <td class=tab1><B>Binomial</B> <br>
   
           Z is Γ(1+B) ÷ (Γ(1+A) × Γ(1+B-A))<br>
   <br>
   
   
           For integers A≥0 and B≥0:<br>
   
           Z is (B!) ÷ ((A!) × (B-A)!)
     <td class=tab12><pre class=input4 line=595>      3!5   ⍝ aka. 5 over 3</pre>
<pre class=output4>10
</pre>
   
     <td class=tab3> !
     <td class=tab4><B>Factorial</B><br>
   
           Z is Γ(1+B), aka.<br>
   
           B! for integers B≥0
     <td class=tab5><pre class=input4 line=595>      !4   ⍝ factorial of B</pre>
<pre class=output4>24
</pre>
   
   
    <tr>
     <td class=tab1><B>Circular Functions</B> <br>
   
           Z is a function, selected<br>
   
           by integer A, and called<br>
   
           with argument B:
           <br>
   
   <br>
    <B>A=¯12</B>: exp(iB)
   <br>
    <B>A=¯11</B>: iB
   <br>
    <B>A=¯10</B>: +B
   <br>
    <B>A=¯9</B>: B
   <br>
    <B>A=¯8</B>: sqrt(B<SUP>2</SUP> - 1)
   <br>
    <B>A=¯7</B>: atanh(B)
   <br>
    <B>A=¯6</B>: acosh(B)
   <br>
    <B>A=¯5</B>: asinh(B)
   <br>
    <B>A=¯4</B>: (B+1) × sqrt((B-1)÷(B+1)))
   <br>
    <B>A=¯3</B>: atan(B)
   <br>
    <B>A=¯2</B>: acos(B)
   <br>
    <B>A=¯1</B>: asin(B)
   <br>
    <B>A=0</B>: sqrt(1 - B<SUP>2</SUP>) 
   <br>
    <B>A=1</B>: sin(B)
   <br>
    <B>A=2</B>: cos(B)
   <br>
    <B>A=3</B>: tan(B)
   <br>
    <B>A=4</B>: sqrt(1 + B<SUP>2</SUP>) 
   <br>
    <B>A=5</B>: sinh(B)
   <br>
    <B>A=6</B>: cosh(B)
   <br>
    <B>A=7</B>: tanh(B)
   <br>
    <B>A=8</B>: sqrt(¯1 - B<SUP>2</SUP>) 
   <br>
    <B>A=9</B>: real(B)
   <br>
    <B>A=10</B>: ∣ B
   <br>
    <B>A=11</B>: imag(B)
   <br>
    <B>A=12</B>: arc(B)
     <td class=tab12><pre class=input4 line=595>      A,⍪(A←¯13+⍳25) ○ 1.1</pre>
<pre class=output4>¯12 0.4535961214J0.8912073601
¯11            0J1.1
¯10          1.1
 ¯9          1.1
 ¯8            0J1.486606875
 ¯7  1.522261219J¯1.570796327
 ¯6 0.4435682544
 ¯5 0.9503469298
 ¯4 0.4582575695
 ¯3 0.8329812667
 ¯2            0J¯0.4435682544
 ¯1  1.570796327J¯0.4435682544
  0            0J0.4582575695
  1 0.8912073601
  2 0.4535961214
  3  1.964759657
  4  1.486606875
  5   1.33564747
  6  1.668518554
  7 0.8004990218
  8            0J¯1.486606875
  9          1.1
 10          1.1
 11            0
 12            0
</pre>
   
     <td class=tab3> ○
     <td class=tab4><B>Pi Times</B> <br>
   
           Z is Pi times B
     <td class=tab5><pre class=input4 line=595>      ○1</pre>
<pre class=output4>3.141592654
</pre>
   
          <pre class=input4 line=595>      ○2</pre>
<pre class=output4>6.283185307
</pre>
   
   
    <tr>
     <td class=tab1><B>Without</B> <br>
   
           Z is the elements of A<br>
   
           that are not in B
     <td class=tab12><pre class=input4 line=595>      1 2 3 4 5 6 ∼ 3 4</pre>
<pre class=output4>1 2 5 6
</pre>
   
     <td class=tab3> ∼
     <td class=tab4><B>Not</B> <br>
    Z is the boolean<br>
   
           complement of B
     <td class=tab5><pre class=input4 line=595>      ∼ 1 0 1 1 0 0</pre>
<pre class=output4>0 1 0 0 1 1
</pre>
   
   
    <tr>
     <td class=tab1><B>And/LCM</B> <br>
   
           For boolean A and B is Z the<br>
   
           logical AND of A and B.
           <br>
   <br>
   
           For integer A or B is Z the<br>
   
           least common multiple of A and B
     <td class=tab12><pre class=input4 line=595>      0 0 1 1 ∧ 0 1 0 1</pre>
<pre class=output4>0 0 0 1
</pre>
   
     <td class=tab3> ∧
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      ∧ 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      ∧0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Or/GCD</B> <br>
   
           For boolean A and B is Z the<br>
   
           logical OR of A and B
           <br>
   <br>
   
           For integer A and B is Z the<br>
   
           gratest common divisor of A and B
     <td class=tab12><pre class=input4 line=595>      0 0 1 1 ∨ 0 1 0 1</pre>
<pre class=output4>0 1 1 1
</pre>
   
     <td class=tab3> ∨
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      ∨ 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      ∨0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Nand</B> <br>
    Z is ∼ (A ∧ B)
     <td class=tab12><pre class=input4 line=595>      0 0 1 1 ⍲ 0 1 0 1</pre>
<pre class=output4>1 1 1 0
</pre>
   
     <td class=tab3> ⍲
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      ⍲ 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      ⍲0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Nor</B> <br>
    Z is ∼ (A ∨ B)
     <td class=tab12><pre class=input4 line=595>      0 0 1 1 ⍱ 0 1 0 1</pre>
<pre class=output4>1 0 0 0
</pre>
   
     <td class=tab3> ⍱
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      ⍱ 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      ⍱0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Equal</B> <br>
   
      Z is 1 for equal A and B,<br>
   
      and 0 otherwise.
     <td class=tab12><pre class=input4 line=595>      1 2 3 = 2</pre>
<pre class=output4>0 1 0
</pre>
   
     <td class=tab3> =
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      = 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      =0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Less Than</B> <br>
   
     Z is 1 if A is less than B,<br>
   
     and 0 otherwise.
     <td class=tab12><pre class=input4 line=595>      1 2 3 < 2</pre>
<pre class=output4>1 0 0
</pre>
   
     <td class=tab3> <
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      < 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      <0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Less or Equal</B> <br>
   
           Z is 1 if A s less than or<br>
   
           equal to B, and 0 otherwise
     <td class=tab12><pre class=input4 line=595>      1 2 3 ≤ 2</pre>
<pre class=output4>1 1 0
</pre>
   
     <td class=tab3> ≤
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      ≤ 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      ≤0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Not Equal</B> <br>
   
           Z is 1 if A  differs from B,<br>
   
           and 0 otherwise
     <td class=tab12><pre class=input4 line=595>      1 2 3 ≠ 2</pre>
<pre class=output4>1 0 1
</pre>
   
     <td class=tab3> ≠
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      ≠ 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      ≠0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Greater or Equal</B> <br>
   
           Z is 1 if A s greater than or<br>
   
           equal to B, and 0 otherwise
     <td class=tab12><pre class=input4 line=595>      1 2 3 ≥ 2</pre>
<pre class=output4>0 1 1
</pre>
   
     <td class=tab3> ≥
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      ≥ 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      ≥0 1 0 1
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Greater Than</B><br>
   
           Z is 1 if A is greater than B,<br>
   
           and 0 otherwise
     <td class=tab12><pre class=input4 line=595>      1 2 3 > 2</pre>
<pre class=output4>0 0 1
</pre>
   
     <td class=tab3> >
     <td class=tab4><B>N/A</B>
     <td class=tab5><pre class=input4 line=595>      > 0 1 0 1</pre>
<pre class=errput4>VALENCE ERROR
      >0 1 0 1
      ^
</pre>
   
   </table>
   
   
   <h4><a id="CH_3.4.10"></a>
   3.4.10 List of Other Built-in Functions</h4>
   
   In order to have all functions listed in one place, we also provide the
   remaining build-in APL functions here. These functions are either
   represented by a single APL character, or by a name that starts with ⎕,
   followed by one or more letters from A-Z ("quad functions"). There is no
   big difference between quad functions and other built-in functions, except
   for the name. Often quad functions are used for services of the
   underlying operating system, such as time information, user accounting, etc.
   Note that the non-quad functions are all defined by the ISO APL standard
   (and identical on all APL interpreters), while very few quad-functions
   are defined by the standard and the other ones differ considerably between
   different APL interpreters.
   <br>
   
   <br>
   
   <B>Note:</B> The table below uses the concept of APL variables which have not
   been introduced yet (but will be soon). If you are an APL novice then please
   ignore the table for the moment and return to it after variables have been
   introduced.
   <br>
   
   <br>
   
   <table class=table1 cellspacing="0" cellpadding="0"> <tr>
     <th class="tab12" colspan="2">Dyadic: Z←A FUN B
     <th class="tab3"> FUN
     <th class="tab45" colspan="2">Monadic: Z←FUN B
   
    <tr>
     <th class="tab1"> Name/Description
     <th class="tab2"> Example(s)
     <th class="tab3"> &nbsp;
     <th class="tab4"> Name/Description
     <th class="tab5" colspan="5"> Example(s)
   
    <tr>
     <td class=tab1><B>Reshape</B><br>
   Z is the ravel of B (possibly shortened or replicated
   as needed) with shape A
     <td class=tab12><pre class=input4 line=595>      2 3⍴1 2 3 4 5 6</pre>
<pre class=output4>1 2 3
4 5 6
</pre>
   
     <td class=tab3> ⍴
     <td class=tab4><B>Shape</B><br>
   Z is the shape of B
     <td class=tab5><pre class=input4 line=595>      ⍴ (2 3 ⍴ 1 2 3 4 5 6)</pre>
<pre class=output4>2 3
</pre>
   
   
    <tr>
     <td class=tab1><B>Join</B><br>
   Z is the concatenation of A and B
     <td class=tab12><pre class=input4 line=595>      A ← 2 3⍴'abcdef' ◊ B ← 2 3⍴1 2 3 4 5 6<pre class=output4>

</pre>
A<pre class=output4>abc
def
</pre>
B<pre class=output4>1 2 3
4 5 6
</pre>
A,B</pre>
<pre class=output4>abc 1 2 3
def 4 5 6
</pre>
   
   
     <td class=tab3> ,<br>
   ⍪
     <td class=tab4><B>Ravel</B><br>
   ,B is the ravel of B (a vector with the same elements as B.
          <br>
   <br>
   <B>Table</B><br>
   ⍪B is a 2-dimensional matrix with the elements of B.)
     <td class=tab5><pre class=input4 line=595>      ⎕ ← B ← 2 3 ⍴ 1 2 3 4 5 6</pre>
<pre class=output4>1 2 3
4 5 6
</pre>
   
          <pre class=input4 line=595>      ,B</pre>
<pre class=output4>1 2 3 4 5 6
</pre>
   
          <pre class=input4 line=595>      ⎕ ← B ← 1 2 3 4 5</pre>
<pre class=output4>1 2 3 4 5
</pre>
   
          <pre class=input4 line=595>      ⍪B</pre>
<pre class=output4>1
2
3
4
5
</pre>
   
   
    <tr>
     <td class=tab1><B>Index of</B><br>
   Z is the positions of B's elements in A
     <td class=tab12><pre class=input4 line=595>      'abcdefgh' ⍳ 'hello'</pre>
<pre class=output4>8 5 9 9 9
</pre>
   
   
     <td class=tab3> ⍳
     <td class=tab4><B>Index Generator</B><br>
   Z is 1 2 ... B
     <td class=tab5><pre class=input4 line=595>      ⍳6</pre>
<pre class=output4>1 2 3 4 5 6
</pre>
   
   
    <tr>
     <td class=tab1><B>Identical</B><br>
   Z is 1 if A and B have the same shape and the same
         ravel elements (including identical nested ravel elements), and 0
         otherwise.
     <td class=tab12><pre class=input4 line=595>      1 2 3 ≡ 1 2 3   ⍝ same shapes and ravels</pre>
<pre class=output4>1
</pre>
   
          <pre class=input4 line=595>      1 2 3 = 1 2 5   ⍝ for comparison: equal</pre>
<pre class=output4>1 1 0
</pre>
   
          <pre class=input4 line=595>      1 2 3 ≡ 1 2 5   ⍝ same shapes, different ravels</pre>
<pre class=output4>0
</pre>
   
          <pre class=input4 line=595>      1  ≡ ,1   ⍝ same ravel, different shapes</pre>
<pre class=output4>0
</pre>
   
   
     <td class=tab3> ≢
     <td class=tab4><B>Depth</B><br>
   Z is the depth (the level of nesting) of B
     <td class=tab5><pre class=input4 line=595>      ≡ 1</pre>
<pre class=output4>0
</pre>
   
          <pre class=input4 line=595>      ≡ 1 2 3</pre>
<pre class=output4>1
</pre>
   
          <pre class=input4 line=595>      ≡ 1 (2 3) 4</pre>
<pre class=output4>2
</pre>
   
   
    <tr>
     <td class=tab1><B>Not Identical</B><br>
   Z is 0 if A and B have the same shape and the same
         ravel elements (including identical nested ravel elements), and 1
         otherwise.
     <td class=tab12><pre class=input4 line=595>      1 2 3 ≢ 1 2 3   ⍝ same shapes and ravels</pre>
<pre class=output4>0
</pre>
   
          <pre class=input4 line=595>      1 2 3 ≠ 1 2 5   ⍝ for comparison: not equal</pre>
<pre class=output4>0 0 1
</pre>
   
          <pre class=input4 line=595>      1 2 3 ≢ 1 2 5   ⍝ same shapes, different ravels</pre>
<pre class=output4>1
</pre>
   
          <pre class=input4 line=595>      1  ≢ ,1   ⍝ same ravel, different shapes</pre>
<pre class=output4>1
</pre>
   
     <td class=tab3> ≢
     <td class=tab4><B>Tally</B><br>
   
           Z is the length of the first axis of B
     <td class=tab5><pre class=input4 line=595>      ≢ 1</pre>
<pre class=output4>1
</pre>
   
          <pre class=input4 line=595>      ≢ 2 3⍴1 2 3</pre>
<pre class=output4>2
</pre>
   
          <pre class=input4 line=595>      ≢ 4 3⍴1 2 3</pre>
<pre class=output4>4
</pre>
   
          <pre class=input4 line=595>      ≢ 1 (2 3) 4</pre>
<pre class=output4>3
</pre>
   
   
    <tr>
     <td class=tab1><B>Member of</B><br>
   Z is a Boolean value with the same shape as A.
              The elements of Z indicate if the corresponding element in A is
              equal to some element in B.
     <td class=tab12><pre class=input4 line=595>      (2 3⍴1 2 3 4 5 6) ϵ 4 5 6 7 8</pre>
<pre class=output4>0 0 0
1 1 1
</pre>
   
   
     <td class=tab3> ∈
     <td class=tab4><B>Enlist</B><br>
   Z is the elements of B listed in depth-first order (all
                      nested sub-values of a ravel element come before the
                      next ravel element at the same level).
     <td class=tab5><pre class=input4 line=595>      ∈ (1 2 3) (4 5) 6</pre>
<pre class=output4>1 2 3 4 5 6
</pre>
   
   
    <tr>
     <td class=tab1><B>Deal</B><br>
   Z is a subset of ⎕IO ... ⎕IO+B containing A elements
              chosen at random
     <td class=tab12><pre class=input4 line=595>      3 ? 10</pre>
<pre class=output4>7 9 4
</pre>
   
          <pre class=input4 line=595>      3 ? 10</pre>
<pre class=output4>4 2 10
</pre>
   
   
     <td class=tab3> ?
     <td class=tab4><B>Roll</B><br>
   Z has the same shape as B. The elements of Z are random
                      numbers between ⎕IO and ⎕IO+b where b is the corresponding
                      element in B.
     <td class=tab5><pre class=input4 line=595>      ? 10 100 1000</pre>
<pre class=output4>5 95 697
</pre>
   
   
    <tr>
     <td class=tab1><B>Grade Up/Down with collating sequence</B><br>
   
              A is a character array which defines an sorting order for
              characters. B is a character vector (string) to be sorted.
              Z is an integer vector such that B[Z] is sorted according to the
              sorting order defined by A.
     <td class=tab12><pre class=input4 line=595>      ⎕IO←1                         ⍝ ⍋ and ⍒ depend on ⎕IO</pre>
<pre class=output4>

</pre>
   
          <pre class=input4 line=595>      ⊢B←5 4⍴'DEADBADECEDEBEADDEE'  ⍝ B: the items to be sorted</pre>
<pre class=output4>DEAD
BADE
CEDE
BEAD
DEED
</pre>
   
          <pre class=input4 line=595>      'ABCDE' ⍋ B                   ⍝ sort B with A < B < C < D < E</pre>
<pre class=output4>2 4 3 1 5
</pre>
   
          <pre class=input4 line=595>      B['ABCDE' ⍋ B;]               ⍝ the sorted items</pre>
<pre class=output4>BADE
BEAD
CEDE
DEAD
DEED
</pre>
   
          <pre class=input4 line=595>      B['CBADE' ⍋ B;]               ⍝ same with C < B < A < D < E</pre>
<pre class=output4>CEDE
BADE
BEAD
DEAD
DEED
</pre>
   
     <td class=tab3> ⍋ <br>
    ⍒
     <td class=tab4><B>Grade Up/Down</B><br>
   Z is a vector of indices such that B[Z] is ordered
              ascendingly (⍋) or descendingly (⍒). In other words, B[⍋B] is B
              sorted in ascending order and B[⍒B] is B sorted in descending order.
     <td class=tab5><pre class=input4 line=595>      ⍋ B←1 7 4 2 6</pre>
<pre class=output4>1 4 3 5 2
</pre>
   
          <pre class=input4 line=595>      B[⍋B]</pre>
<pre class=output4>1 2 4 6 7
</pre>
   
          <pre class=input4 line=595>      B[⍒B]</pre>
<pre class=output4>7 6 4 2 1
</pre>
   
   
    <tr>
     <td class=tab1><B>Representation aka. Encode</B><br>
   
           Z is numbers in B represented in the number system with radices A.
           ⍴A determines the number of digits in that representation.
     <td class=tab12><pre class=input4 line=595>      2 2 2 2 2 2 ⊤ 42   ⍝ 42 in base 2 (aka. binary) with 6 digits</pre>
<pre class=output4>1 0 1 0 1 0
</pre>
   
     <td class=tab3> ⊤
     <td class=tab4>N/A
     <td class=tab5><pre class=input4 line=595>      ⊤ 42</pre>
<pre class=errput4>VALENCE ERROR
      ⊤42
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Base Value aka. Decode</B><br>
   
           Z is the number corresponding to the digits B in the number system
           with radices A.
     <td class=tab12><pre class=input4 line=595>      2 ⊥ 1 0 1 0 1 0   ⍝ binary 1 0 1 0 1 0 in decimal</pre>
<pre class=output4>42
</pre>
   
     <td class=tab3> ⊥
     <td class=tab4>N/A
     <td class=tab5><pre class=input4 line=595>      ⊥ 42</pre>
<pre class=errput4>VALENCE ERROR
      ⊥42
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Union</B><br>
   Z is A , B (with duplicates of A in B removed)
     <td class=tab12><pre class=input4 line=595>      1 2 2 3 'A' ∪ 3 'B' 'C' 'A'</pre>
<pre class=output4>1 2 2 3 ABC
</pre>
   
     <td class=tab3> ∪
     <td class=tab4><B>Unique</B><br>
   Z is B with duplicate elements removed
     <td class=tab5><pre class=input4 line=595>      ∪ 1 2 3 4 3 5</pre>
<pre class=output4>1 2 3 4 5
</pre>
   
   
    <tr>
     <td class=tab1><B>Format</B><br>
   Z is B formatted according to A
     <td class=tab12><pre class=input4 line=595>      ⊢B←3 2ρ1 .468987 2 57.276 3 27963</pre>
<pre class=output4>1     0.468987
2    57.276
3 27963
</pre>
   
          <pre class=input4 line=595>      ⍝ format by specification: (field size + precision)</pre>
   
          <pre class=input4 line=595>      ⍝ precisions < 0 imply exponential format</pre>
   
          <pre class=input4 line=595>      4 2 12 ¯5 ⍕ B   ⍝ field sizes 4 and 12, precisions 2 and ¯5</pre>
<pre class=output4>1.00   4.6899E¯1
2.00   5.7276E1 
3.00   2.7963E4 
</pre>
   
          <pre class=input4 line=595>      ⍝ format by example: (example string A)</pre>
   
          <pre class=input4 line=595>      ⊢B←234.67 456.23 987.65 34.23</pre>
<pre class=output4>234.67 456.23 987.65 34.23
</pre>
   
          <pre class=input4 line=595>      "SUM: $5,555.50" ⍕ +/ B</pre>
<pre class=output4>SUM: $1,712.78
</pre>
   
     <td class=tab3> ⍕
     <td class=tab4><B>Format</B><br>
   
          Z is B for strings; otherwise B converted to a character vector or matrix
     <td class=tab5>
   
    <tr>
     <td class=tab1> N/A
     <td class=tab12> <pre class=input4 line=595>      2 ⍎ 42</pre>
<pre class=errput4>VALENCE ERROR
      2⍎42
      ^^
</pre>
   
     <td class=tab3> ⍎
     <td class=tab4><B>Execute</B><br>
   Z is the result of executing string B as APL expression
     <td class=tab5>
   
    <tr>
     <td class=tab1><B>Take</B><br>
   Z is a rectangular sub-area of B according to A
     <td class=tab12> <pre class=input4 line=595>      ⊢V←⍳7</pre>
<pre class=output4>1 2 3 4 5 6 7
</pre>
         <pre class=input4 line=595>      3↑V</pre>
<pre class=output4>1 2 3
</pre>
    <pre class=input4 line=595>      ¯3↑V</pre>
<pre class=output4>5 6 7
</pre>
   
           <pre class=input4 line=595>      ⊢B←7 7⍴⍳49</pre>
<pre class=output4> 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31 32 33 34 35
36 37 38 39 40 41 42
43 44 45 46 47 48 49
</pre>
    <pre class=input4 line=595>      3 3↑B</pre>
<pre class=output4> 1  2  3
 8  9 10
15 16 17
</pre>
    <pre class=input4 line=595>      ¯3 ¯3↑B</pre>
<pre class=output4>33 34 35
40 41 42
47 48 49
</pre>
   
     <td class=tab3> ↑
     <td class=tab4><B>First</B><br>
   Z is a Scalar containing first element of B (or the prototype of B if B is empty)
     <td class=tab5>
   
    <tr>
     <td class=tab1><B>Drop</B><br>
   Z is B rectangular sub-area of B according to A
     <td class=tab12> <pre class=input4 line=595>      ⊢V←⍳7</pre>
<pre class=output4>1 2 3 4 5 6 7
</pre>
         <pre class=input4 line=595>      3↓V</pre>
<pre class=output4>4 5 6 7
</pre>
    <pre class=input4 line=595>      ¯3↓V</pre>
<pre class=output4>1 2 3 4
</pre>
   
           <pre class=input4 line=595>      ⊢B←7 7⍴⍳49</pre>
<pre class=output4> 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31 32 33 34 35
36 37 38 39 40 41 42
43 44 45 46 47 48 49
</pre>
    <pre class=input4 line=595>      3 3↓B</pre>
<pre class=output4>25 26 27 28
32 33 34 35
39 40 41 42
46 47 48 49
</pre>
    <pre class=input4 line=595>      ¯3 ¯3↓B</pre>
<pre class=output4> 1  2  3  4
 8  9 10 11
15 16 17 18
22 23 24 25
</pre>
   
     <td class=tab3> ↓
     <td class=tab4> N/A
     <td class=tab5> <pre class=input4 line=595>      ↓ 1 2 3</pre>
<pre class=errput4>VALENCE ERROR
      ↓1 2 3
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Find</B><br>
   Z[i] is 1 if A starts at B[i] in B and 0 if not.
     <td class=tab12><pre class=input4 line=595>      3 4 ⍷ 1 2 3 4 5</pre>
<pre class=output4>0 0 1 0 0
</pre>
   
     <td class=tab3> ⋸
     <td class=tab4> N/A
     <td class=tab5> <pre class=input4 line=595>      ⋸ 'abc'</pre>
<pre class=errput4>VALENCE ERROR
      ⍷'abc'
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Index</B><br>
   Z is B[A]
     <td class=tab12><pre class=input4 line=595>      2 ⌷ 'Hello'</pre>
<pre class=output4>e
</pre>
      ⍝ second character
     <td class=tab3> ⌷
     <td class=tab4> N/A
     <td class=tab5> <pre class=input4 line=595>      ⌷ 1 2 3</pre>
<pre class=errput4>VALENCE ERROR
      ⌷1 2 3
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Right</B><br>
   Z is B.
     <td class=tab12><pre class=input4 line=595>      'Left' ⊢  'Right'</pre>
<pre class=output4>Right
</pre>
   
     <td class=tab3> ⊢
     <td class=tab4><B>Identity</B> <br>
    Z is B. ⊢B is a shortcut for ⎕←B
     <td class=tab5>
   
    <tr>
     <td class=tab1><B>Left</B><br>
   Z is A
     <td class=tab12><pre class=input4 line=595>      'Left' ⊣  'Right'</pre>
<pre class=output4>Left
</pre>
   
     <td class=tab3> ⊣
     <td class=tab4><B>Hide</B> <br>
    Z is B as a committed APL value (and is therefore not
                     automatically displayed). ⊣B is a shortcut for (⍳0)⍴B.
     <td class=tab5> <pre class=input4 line=595>      1 + 3</pre>
<pre class=output4>4
</pre>
   
           <pre class=input4 line=595>      ⊣ 1 + 3</pre>
<pre class=output4>

</pre>
   
   
    <tr>
     <td class=tab1><B>Partition</B> <br>
   
           Z is B, divided into partitions according to A. Two elements B[b]
           and B[b+1] of B belong to the same partition if A[b] ≥ A[b+1] > 0.
           Each partition becomes a nested item of Z where B[b] with A[b] = 0
           are removed.
     <td class=tab12><pre class=input4 line=595>      1 1  2 2  3 3 3 3 ⊂ 'ABCDEFGH'   ⍝ 3 partitions</pre>
<pre class=output4> AB CD EFGH 
</pre>
   
          <pre class=input4 line=595>      1 1  0 0  3 3 3 3 ⊂ 'ABCDEFGH'   ⍝ 2 partitions</pre>
<pre class=output4> AB EFGH 
</pre>
   
     <td class=tab3> ⊂
     <td class=tab4><B>Enclose</B><br>
   Z is B for simple scalars B, otherwise a scalar
                        that contains B as a nested value
     <td class=tab5><pre class=input4 line=595>      B←3 4 ⍴5</pre>
<pre class=output4>

</pre>
   
          <pre class=input4 line=595>      8 ⎕CR B</pre>
<pre class=output4>┌→──────┐
↓5 5 5 5│
│5 5 5 5│
│5 5 5 5│
└───────┘
</pre>
   
          <pre class=input4 line=595>      8 ⎕CR ⊂B</pre>
<pre class=output4>┌─────────┐
│┌→──────┐│
│↓5 5 5 5││
││5 5 5 5││
││5 5 5 5││
│└───────┘│
└ϵ────────┘
</pre>
   
   
    <tr>
     <td class=tab1><B>Pick</B> <br>
   
           Z is a nested sub-value of B, whose position in B is determined by A.
           Every item of A corresponds to a nesting level of B.
     <td class=tab12><pre class=input4 line=595>      8 ⎕CR  S←2 3ρ'AB' 'CD' 'EF' 'GH' 'IJ' 'KL'</pre>
<pre class=output4>┌→─────────────┐
↓┌→─┐ ┌→─┐ ┌→─┐│
││AB│ │CD│ │EF││
│└──┘ └──┘ └──┘│
│┌→─┐ ┌→─┐ ┌→─┐│
││GH│ │IJ│ │KL││
│└──┘ └──┘ └──┘│
└ϵ─────────────┘
</pre>
   
          <pre class=input4 line=595>      (1 3) 2 ⊃ S   ⍝ (1 3) selects 'EF' from S, 2 selects 'F' from 'EF'</pre>
<pre class=output4>F
</pre>
   
          <pre class=input4 line=595>      (⊃S[1;3])[2]   ⍝ the same.</pre>
<pre class=output4>F
</pre>
   
   
     <td class=tab3> ⊃
     <td class=tab4><B>Disclose</B><br>
   
           Z is the elements of B,
           with nested sub-values
           replaced by arrays padded
           to the same common size
     <td class=tab5> <pre class=input4 line=595>      8 ⎕CR B←2 2⍴'One' 'Two' 'Three' 'Four'</pre>
<pre class=output4>┌→─────────────┐
↓┌→──┐   ┌→──┐ │
││One│   │Two│ │
│└───┘   └───┘ │
│┌→────┐ ┌→───┐│
││Three│ │Four││
│└─────┘ └────┘│
└ϵ─────────────┘
</pre>
   
           <pre class=input4 line=595>      8 ⎕CR ⊃ B</pre>
<pre class=output4>┌→────┐
↓One  │
│Two  │
│     │
│Three│
│Four │
└─────┘
</pre>
   
   
    <tr>
     <td class=tab1><B>Rotate</B><br>
   Z is B rotated according to A
     <td class=tab12><pre class=input4 line=595>      ⊢B←3 5⍴⍳5</pre>
<pre class=output4>1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
</pre>
   
          <pre class=input4 line=595>      1 2 3⌽B       ⍝ rotate along the last axis (columns)</pre>
<pre class=output4>2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
</pre>
   
          <pre class=input4 line=595>      ¯1 ¯2 ¯3⌽B    ⍝ rotate backwards along the last axis (columns)</pre>
<pre class=output4>5 1 2 3 4
4 5 1 2 3
3 4 5 1 2
</pre>
   
          <pre class=input4 line=595>      ⊢B←3/⍪⍳5</pre>
<pre class=output4>1 1 1
2 2 2
3 3 3
4 4 4
5 5 5
</pre>
   
          <pre class=input4 line=595>      1 2 3⊖B       ⍝ rotate along the first axis (rows)</pre>
<pre class=output4>2 3 4
3 4 5
4 5 1
5 1 2
1 2 3
</pre>
   
     <td class=tab3> ⊖ <br>
    ⌽
     <td class=tab4><B>Reverse</B><br>
   
           Z is B with the items along the first resp. last axis reversed
     <td class=tab5><pre class=input4 line=595>      ⌽1 2 3 4 5</pre>
<pre class=output4>5 4 3 2 1
</pre>
   
   
    <tr>
     <td class=tab1><B>Transpose (General)</B><br>
   Z is B transposed according to A.
          <br>
    A is a vector of
             numbers in<br>
   
             1 2 3...⌈/A (or in<br>
   
             0 1 2..., if ⎕IO←0).
             <br>
   <br>
   
             Permutations A (of
             ⍳⍴⍴B) permute the
             axes of B.
             <br>
   <br>
   
             Repeated items in A
             select diagonals in
             B and reduce the rank
             of the result.
   
     <td class=tab12> <pre class=input4 line=595>      ⊢N234←10 ⊥¨ ⍳2 3 4</pre>
<pre class=output4>111 112 113 114
121 122 123 124
131 132 133 134

211 212 213 214
221 222 223 224
231 232 233 234
</pre>
   
           <pre class=input4 line=595>      1 3 2⍉N234</pre>
<pre class=output4>111 121 131
112 122 132
113 123 133
114 124 134

211 221 231
212 222 232
213 223 233
214 224 234
</pre>
   
           <pre class=input4 line=595>      1 1 2⍉N234   ⍝ axis 1 repeated</pre>
<pre class=output4>111 112 113 114
221 222 223 224
</pre>
   
     <td class=tab3> ⍉
     <td class=tab4><B>Transpose (Reverse Axes)</B><br>
   Z is B transposed so that the order
              of axes is reversed. Z←⍉B ←→ (⌽⍳⍴B)⍉B
     <td class=tab5> <pre class=input4 line=595>      ⊢N234←10 ⊥¨ ⍳2 3 4</pre>
<pre class=output4>111 112 113 114
121 122 123 124
131 132 133 134

211 212 213 214
221 222 223 224
231 232 233 234
</pre>
   
           <pre class=input4 line=595>      ⍉ N234</pre>
<pre class=output4>111 211
121 221
131 231

112 212
122 222
132 232

113 213
123 223
133 233

114 214
124 224
134 234
</pre>
   
   
    <tr>
     <td class=tab1><B>Intersection</B><br>
   Z is the elements of A that are also in B
     <td class=tab12><pre class=input4 line=595>      1 2 3 4 5 6 ∩ 3 4 5 6 7 8</pre>
<pre class=output4>3 4 5 6
</pre>
   
     <td class=tab3> ∩
     <td class=tab4> N/A
     <td class=tab5> <pre class=input4 line=595>      ∩ 3 4 5 6 7 8</pre>
<pre class=errput4>VALENCE ERROR
      ∩3 4 5 6 7 8
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Compress</B><br>
   Z is the elements of B with B[i] repeated A[i] times
     <td class=tab12><pre class=input4 line=595>      1 2 3 4 5 / 'ABCDE'<pre class=output4>ABBCCCDDDDEEEEE
</pre>
1 2 3 4 5 / '1A' '2B' '3C' '4D' '5E'</pre>
<pre class=output4> 1A 2B 2B 3C 3C 3C 4D 4D 4D 4D 5E 5E 5E 5E 5E 
</pre>
   
     <td class=tab3> / <br>
    ⌿
     <td class=tab4>N/A (note that f/B is an operator that takes one value argument)
     <td class=tab5> <pre class=input4 line=595>      / 'ABCDE'</pre>
<pre class=errput4>SYNTAX ERROR
      /'ABCDE'
      ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Expand</B><br>
   A[i] is 0 or 1; if 1 then Z[i] is B[i] and otherwise ↑B.
     <td class=tab12><pre class=input4 line=595>      1 0 1 0 0 1\1 2 3   ⍝ 1 at 1, 2 at 3, and 3 at 6. ↑B is 0<pre class=output4>1 0 2 0 0 3
</pre>
1 0 1 0 0 1 \ 'ABC' ⍝ A at 1, B at 3, and C at 6  ↑B is ' '</pre>
<pre class=output4>A B  C
</pre>
   
     <td class=tab3> \ <br>
    ⍀
     <td class=tab4>N/A (note that f\B is an operator that takes one value argument)
     <td class=tab5> <pre class=input4 line=595>      \ 'ABCDE'</pre>
<pre class=errput4>SYNTAX ERROR
      \'ABCDE'
      ^
</pre>
   
   
   </table>
   
   
   <h4><a id="CH_3.4.11"></a>
   3.4.11 List of Built-in Monadic APL Operator</h4>
   
   A monadic APL operator OP1 takes 2 or 3 arguments in the following order:
   
   <ul>
   <li>a left value <B>A</B> (mandatory or optional, depending on the operator),</li>
   <li>a mandatory left function argument <B>f</B> (followed by the operator itself)</li>
   <li>a mandatory right value <B>B</B>.</li>
   </ul>
   
   
   <table class=table1 cellspacing="0" cellpadding="0"> <tr>
     <th class="tab12" colspan="2">Used with 2 Value Arguments A and B: Z←A f OP1 B
     <th class="tab3"> OP1
     <th class="tab45" colspan="2">Used with 1 Value Argument B: Z←f OP1 B
   
    <tr>
     <th class="tab1"> Name/Description
     <th class="tab2"> Example(s)
     <th class="tab3"> &nbsp;
     <th class="tab4"> Name/Description
     <th class="tab5" colspan="5"> Example(s)
   
    <tr>
     <td class=tab1><B>Reduce N-wise</B> <br>
   
           Like <B>f/B</B> and <B>f⌿B</B> except that <B>f</B> is applied to groups
           C<SUB>1</SUB> C<SUB>2</SUB> ... C<SUB>n</SUB>.
           Each group C<SUB>n</SUB> has A consecutive items of B and starts at position
           i of the axis along which the N-wise reductions are computed.
     <td class=tab12><pre class=input4 line=595>      ⊢R←1 2 3 4 5 6<pre class=output4>1 2 3 4 5 6
</pre>
4 +/ R<pre class=output4>10 14 18
</pre>
+/R[1 2 3 4]   ⍝ group C₁ ←→ Z[1]<pre class=output4>10
</pre>
+/R[2 3 4 5]   ⍝ group C₂ ←→ Z[2]<pre class=output4>14
</pre>
+/R[3 4 5 6]   ⍝ group C₃ ←→ Z[3]</pre>
<pre class=output4>18
</pre>
   
           <pre class=input4 line=595>      ⊢R←2 6⍴⍳12      ⍝ ⍴⍴R > 1<pre class=output4>1 2 3  4  5  6
7 8 9 10 11 12
</pre>
4 +/ R</pre>
<pre class=output4>10 14 18
34 38 42
</pre>
   
   
     <td class=tab3> / <br>
    ⌿
     <td class=tab4> <B>Reduce</B> <br>
   
            <B>Z</B> is computed by applying <B>f</B> repeatedly along the last axis
            of B, i.e.  Z←[;;1] f B[;;2] f ... f B[;;N] (the number of semicolons
            is ¯1↑⍴⍴B and N←¯1↑⍴B). f⌿B is the same except that f is computed
            along the first axis of B.
     <td class=tab5><pre class=input4 line=595>      +/ 1 2 3 4 5   ⍝ +/ is the sum of elements</pre>
<pre class=output4>15
</pre>
   
   
    <tr>
     <td class=tab1> N/A
     <td class=tab12> <pre class=input4 line=595>      2 +\ 1 2 3 4</pre>
<pre class=errput4>VALENCE ERROR
      2+\1 2 3 4
      ^ ^
</pre>
   
     <td class=tab3> \ <br>
    ⍀
     <td class=tab4> <B>Scan</B> <br>
   
            Z←f\B resp. Z←f⍀B is like Z←f/B resp. Z←f⌿B except that the partial
            results of the different invocations of function f are not discarded
            but included in the result Z.
     <td class=tab5><pre class=input4 line=595>      +\ 1 2 3 4 5   ⍝ 1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5</pre>
<pre class=output4>1 3 6 10 15
</pre>
   
   
    <tr>
     <td class=tab1><B>Commute</B><br>
   Z is B f A (the arguments A and B are exchanged)
     <td class=tab12><pre class=input4 line=595>      2 ÷ 1</pre>
<pre class=output4>2
</pre>
   
          <pre class=input4 line=595>      2 ÷⍨ 1</pre>
<pre class=output4>0.5
</pre>
   
     <td class=tab3> ⍨
     <td class=tab4><BO Duplicate<br>
   Z is B f B (the single argument B is duplicated)
     <td class=tab5><pre class=input4 line=595>      ×⍨ 1 2 3 4   ⍝ squares</pre>
<pre class=output4>1 4 9 16
</pre>
   
   
    <tr>
     <td class=tab1><B>Each (dyadic)</B><br>
   Z[i] is A[i] f  B[i] (f is called dyadically
           for all corresponding items of A and B)
   
     <td class=tab12><pre class=input4 line=595>      8 ⎕CR  1 2 3 ,10 20 30</pre>
<pre class=output4>┌→─────────────┐
│1 2 3 10 20 30│
└──────────────┘
</pre>
   
          <pre class=input4 line=595>      8 ⎕CR  1 2 3 ,¨10 20 30</pre>
<pre class=output4>┌→───────────────────┐
│┌→───┐ ┌→───┐ ┌→───┐│
││1 10│ │2 20│ │3 30││
│└────┘ └────┘ └────┘│
└ϵ───────────────────┘
</pre>
   
     <td class=tab3> f¨
     <td class=tab4><B>Each (monadic)</B><br>
   Z[i] is f B[i] (f called monadically for every item B[i] of B)
     <td class=tab5><pre class=input4 line=595>      8 ⎕CR , 1 2 3</pre>
<pre class=output4>┌→────┐
│1 2 3│
└─────┘
</pre>
<pre class=input4 line=595>      8 ⎕CR ,¨ 1 2 3</pre>
<pre class=output4>┌→──────────┐
│┌→┐ ┌→┐ ┌→┐│
││1│ │2│ │3││
│└─┘ └─┘ └─┘│
└ϵ──────────┘
</pre>
   
   </table>
   
   
   <h4><a id="CH_3.4.12"></a>
   3.4.12 List of Built-In Dyadic APL Operators</h4>
   
   A dyadic APL operator OP2 takes 3 or 4 arguments in the following order:
   
   <ul>
   <li>a left value <B>A</B> (mandatory or optional, depending on the operator),</li>
   <li>a mandatory function argument <B>f</B>, (followed by the operator itself)</li>
   <li>a mandatory function argument <B>g</B>, and</li>
   <li>a mandatory right value <B>B</B>.</li>
   </ul>
   
   
   <table class=table1 cellspacing="0" cellpadding="0"> <tr>
     <th class="tab12" colspan="2">Used with 2 Value Arguments A and B: Z←A f OP2 g B
     <th class="tab3"> OP2
     <th class="tab45" colspan="2">Used with 1 Value Argument B: Z←f OP2 g B
   
    <tr>
     <th class="tab1"> Name/Description
     <th class="tab2"> Example(s)
     <th class="tab3"> &nbsp;
     <th class="tab4"> Name/Description
     <th class="tab5" colspan="5"> Example(s)
   
    <tr>
     <td class=tab1><B>Inner Product</B><br>
   Z[i;j] is f / A[i] g B[j]. Row A[;j] is multiplied
                              with column B[i;] and the resulting vector V is
                              then f-reduced to give the scalar Z[i;j] (enclosed
                              if necessary to yield a scalar).
                          <br>
     For simple numeric matrices A and B this is
                              the "matrix multiplication" known from linear
                              algebra.
     <td class=tab12><pre class=input4 line=595>      ⊢A←2 2⍴1 2 3 4</pre>
<pre class=output4>1 2
3 4
</pre>
<pre class=input4 line=595>      ⊢B←2 2⍴1 2 3 4</pre>
<pre class=output4>1 2
3 4
</pre>
<pre class=input4 line=595>      ⊢A +.× B</pre>
<pre class=output4> 7 10
15 22
</pre>
   
     <td class=tab3> f.g
     <td class=tab4> N/A
     <td class=tab5> <pre class=input4 line=595>      +.× 2 2⍴1 2 3 4</pre>
<pre class=errput4>VALENCE ERROR
      +.×2 2⍴1 2 3 4
      ^ ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Outer Product</B><br>
   Z[i;j] is A[i] g B[j]. ⍴Z ←→ (⍴A),⍴B)
     <td class=tab12><pre class=input4 line=595>      B ∘.× B←⍳10</pre>
<pre class=output4> 1  2  3  4  5  6  7  8  9  10
 2  4  6  8 10 12 14 16 18  20
 3  6  9 12 15 18 21 24 27  30
 4  8 12 16 20 24 28 32 36  40
 5 10 15 20 25 30 35 40 45  50
 6 12 18 24 30 36 42 48 54  60
 7 14 21 28 35 42 49 56 63  70
 8 16 24 32 40 48 56 64 72  80
 9 18 27 36 45 54 63 72 81  90
10 20 30 40 50 60 70 80 90 100
</pre>
   
     <td class=tab3> ∘.g
     <td class=tab4> N/A
     <td class=tab5> <pre class=input4 line=595>      ∘.× B←⍳10</pre>
<pre class=errput4>VALENCE ERROR
      ∘.×B←⍳10
      ^    ^
</pre>
   
   
    <tr>
     <td class=tab1><B>Rank</B><br>
   
            <B>Z←f ⍤ y B</B> is
            function <B>f</B> applied
            to the rank-<B>m</B> cells
            of <B>B</B> (where <B>m</B> is
            defined by <B>y</B>, see
            below.).
            <br>
   <br>
   
            The <B>rank-v cells</B> of
            a value <B>V</B>, <B>v≤⍴⍴V</B>,
            is <B>V</B> enclosed along its
            <B>v</B> lower axes, i.e.
            <B>⊂[(-v)↑⍴V] V</B>
            <br>
   <br>
   
            <I>Conceptually</I> is <B>y</B>
            a 3 item integer vector:
            <B>y ← m a b</B>.
            Shorter <B>y</B> are expanded:
            <br>
   <br>
   
            <B>y←m</B>    ←→  <B>y←m m m</B>
            <B>y←a b</B>  ←→  <B>y←b a b</B>
            <br>
   <br>
   
            This monadic case uses only
            the first item <B>m</B> of <B>y</B>,
            but not <B>a</B> or <B>b</B>.
   
     <td class=tab12><pre class=input4 line=595>      y←0 ◊ ⍳⍤y 1 2 3</pre>
<pre class=output4>1 0 0
1 2 0
1 2 3
</pre>
   
         <pre class=input4 line=595>      ⍝ ISO standard 13751 uses arrays like N233 below,
      ⍝ whose items are unique and reflect their position
      ⍝ in the array That is, e.g.  N233[i;j;k] ←→ ijk
      ⍝
      ⎕ ← N233 ← 10 ⊥¨ ⍳2 3 3</pre>
<pre class=output4>111 112 113
121 122 123
131 132 133

211 212 213
221 222 223
231 232 233
</pre>
   
          <pre class=input4 line=595>      (,⍤2) N233</pre>
<pre class=output4>111 112 113 121 122 123 131 132 133
211 212 213 221 222 223 231 232 233
</pre>
   
          <pre class=input4 line=595>      ⍳⍤0 1 2 3      ⍝ ambiguous, see below</pre>
<pre class=output4>1 2 3
</pre>
   
          <pre class=input4 line=595>      (⍳⍤0) 1 2 3   ⍝ y B ←→ (0) (1 2 3)</pre>
<pre class=output4>1 0 0
1 2 0
1 2 3
</pre>
   
          <pre class=input4 line=595>      (⍳⍤0 1) 2 3   ⍝ y B ←→ (0 1) (2 3)</pre>
<pre class=output4> 1 1  1 2  1 3 
 2 1  2 2  2 3 
</pre>
   
          <pre class=input4 line=595>      (⍳⍤0 1 2) 3   ⍝ y B ←→ (0 1 2) (3)</pre>
<pre class=output4>1 2 3
</pre>
   
     <td class=tab3> ⍤
     <td class=tab4><B>Rank</B><br>
   
            <B>Z←A f ⍤ y B</B> is
            function <B>f</B> applied to the
            rank-<B>a</B> cells of <B>A</B>
            and the rank-<B>b</B> cells of <B>B</B>
            (with <B>a</B> and <B>b</B> defined
            by <B>y</B>, see monadic case).
            <br>
   <br>
   
            This dyadic case uses
            only <B>a</B> and <B>b</B> of
            <B>y←m a b</B>; the first item <B>m</B>
            is used in the monadic case.<br>
   
            The intention of this somewhat
            confusing definition was apparently
            the use of the same <B>y</B>
            in the monadic and dyadic cases.
            However, a two item <B>y←a b</B>
            (with <B>a</B> ignored in the monadic
            case) would have been more plausible.
   
   
     <td class=tab5><pre class=input4 line=595>      0 1 2⌽⍤0 1 'ABC'</pre>
<pre class=output4>ABC
BCA
CAB
</pre>
   
   
    <tr>
     <td class=tab1><B>Power Operator</B><br>
   
            <B>Z←A f ⍣ N B</B> (N > 0):<br>
   
              repeat: Z←B←A f B<br>
   
              (repeats N times).<br>
   <br>
   
            <B>Z←A f ⍣ N B</B> (N < 0):<br>
   
              repeat: Z←B←A f<SUP>-1</SUP> B<br>
   
              (repeats -N times).<br>
   <br>
   
            <B>Z←A f ⍣ g B</B><br>
   
            with function <B>g</B>:
              repeat: Z←B←A f B<br>
   
              until (A f B) g B.
     <td class=tab12><pre class=input4 line=595>      2 (×⍣ 5) 1   ⍝ 2 × 2 × 2 × 2 × 2 × 1</pre>
<pre class=output4>32
</pre>
   
          <pre class=input4 line=595>      2 (×⍣ ¯5) 1   ⍝ ((((1 ÷ 2) ÷ 2) ÷ 2) ÷ 2) ÷ 2</pre>
<pre class=output4>0.03125
</pre>
   
          <pre class=input4 line=595>      2 (-⍣≤)  6.4   ⍝ (2 - 6.4) = ¯4.4 and 4.4 ≤ 6.4</pre>
<pre class=output4>¯4.4
</pre>
   
     <td class=tab3> ⍣
     <td class=tab4><B>Power Operator</B><br>
   
            <B>Z←f ⍣ N B</B> (N > 0):<br>
   
              repeat: Z←B←f B<br>
   
              (repeats N times).<br>
   <br>
   
            <B>Z←f ⍣ N B</B> (N < 0):<br>
   
              repeat: Z←B←f<SUP>-1</SUP> B<br>
   
              (repeats -N times).<br>
   <br>
   
            <B>Z←f ⍣ g B</B><br>
   
            with function <B>g</B>:
              repeat: Z←B←f B<br>
   
              until (f B) g B.
     <td class=tab5><pre class=input4 line=595>      (-⍣3) 5    ⍝ - - - 5</pre>
<pre class=output4>¯5
</pre>
   
          <pre class=input4 line=595>      (-⍣¯3) 5   ⍝ -<sup>-1</sup> is +</pre>
<pre class=output4>5
</pre>
   
   </table>
   
   
   <br>
   <br>
   
   <B>Notes</B>: The outer product is considered a dyadic operator here (and also
   in the APL standard), even though it has only one functional argument and
   not two. If it were a monadic operator then the function argument g would
   have to appear left of the operator symbol (.) rather than right of it.
   In a way one can consider the outer product as the inner product with '∘'
   being the identity function.
   <br>
   
   <br>
   
   The ISO standard defines f⍤y as dyadic operator (with a left (function)
    rgument f and right (numeric) argument y. y is a numeric vector with
   1, 2, or 3 elements, which may be ambiguous in certain cases.
   
   <h4><a id="CH_3.4.13"></a>
   3.4.13 Functions and Operators with Axis Argument</h4>
   
   As we have seen above, some built-in functions and operators have variants
   that operate along the first or along the last axis. For example:
   
<pre class=input_T line=602>      ⊢A←2 3 ⍴'A'</pre>
<pre class=output1>AAA
AAA
</pre>
<pre class=input_ line=603>      ⊢B←2 3⍴'b'</pre>
<pre class=output1>bbb
bbb
</pre>
<pre class=input_ line=603>      A,B   ⍝ catenate along last axis</pre>
<pre class=output1>AAAbbb
AAAbbb
</pre>
<pre class=input_ line=603>      A⍪B   ⍝ catenate along first axis</pre>
<pre class=output>AAA
AAA
bbb
bbb
</pre>
   
   
   For built-in functions and operators the symbol for the the variant that
   works along the first axis is the symbol for the variant that works along
   the last axis but with a '-' overstrike. These days APL uses a keyboard
   layout where every APL character can be entered with the help of the
   Ctrl-key or with the Alt-key, but in the early days of APL the character
   '⍪' was produced by typing ',' then backspace (which moved the input cursor
   back over the ',' just types) and finaly '-'. On a standard ASCII terminal
   this 3 character sequence would have replaced ',' with '-' but on an APL
   terminal it instead would have combined the ',' and the '-' resulting in
   the overstrike character '⍪'.
   
   Coming back to our topic axis arguments: Those built-in functions that
   can operate along the first or along the last axis can also operate along
   any other axis. The desired axis is provided after the function or operator
   symbol and in brackets:
   
   <br>
   
<pre class=input_T line=602>      ⊢A←2 3 4⍴'A'</pre>
<pre class=output1>AAAA
AAAA
AAAA

AAAA
AAAA
AAAA
</pre>
<pre class=input_ line=603>      ⊢B←2 3 4⍴'b'</pre>
<pre class=output1>bbbb
bbbb
bbbb

bbbb
bbbb
bbbb
</pre>
<pre class=input_ line=603>      A,B   ⍝ catenate along last axis</pre>
<pre class=output1>AAAAbbbb
AAAAbbbb
AAAAbbbb

AAAAbbbb
AAAAbbbb
AAAAbbbb
</pre>
<pre class=input_ line=603>      A⍪B   ⍝ catenate along first axis</pre>
<pre class=output1>AAAA
AAAA
AAAA

AAAA
AAAA
AAAA

bbbb
bbbb
bbbb

bbbb
bbbb
bbbb
</pre>
<pre class=input_ line=603>      A,[1]B   ⍝ catenate along first axis</pre>
<pre class=output1>AAAA
AAAA
AAAA

AAAA
AAAA
AAAA

bbbb
bbbb
bbbb

bbbb
bbbb
bbbb
</pre>
<pre class=input_ line=603>      A,[2]B   ⍝ catenate along middle axis</pre>
<pre class=output1>AAAA
AAAA
AAAA
bbbb
bbbb
bbbb

AAAA
AAAA
AAAA
bbbb
bbbb
bbbb
</pre>
<pre class=input_ line=603>      A,[3]B   ⍝ catenate along last axis</pre>
<pre class=output>AAAAbbbb
AAAAbbbb
AAAAbbbb

AAAAbbbb
AAAAbbbb
AAAAbbbb
</pre>
   
   <br>
   
   The axis can be given as a numeric literal as above, but also as a 
   variable whose value is a number indicating a valid axis of the arguments.
   
   <h4><a id="CH_3.4.14"></a>
   3.4.14 System Functions</h4>
   
   The built-in APL functions that we have introduced so far were represented
   by a single character. These functions are commonly referred to as
   "primitive APL functions" (or operators) or simply "APL primitives". There
   is another group of built-in APL functions called "System Functions" which
   are used in the same way as primitives. The distinction between APL
   primitives and system functions is somewhat arbitrary and probably caused
   by a lack of suitable characters or keyboard keys. The few differences
   between primitives and system functions are:
   <br>
   
   <ul>
   <li>a primitive is denoted by single character while a system function
       is denoted by the character ⎕ followed by one or more characters A-Z
       or a-z (see chapter "Names of System Functions and System Variables"
       above)</li>
   <li>The function computed by a APL primitives essentially the same on
       different APL interpreters while the system functions (and in particular
       their presence or absence) may differ considerably between different
       APL interpreters.</li>
   <li>APL primitives compute APL values from other APL values while system
       functions typically provide an interface to resources of the underlying
       operating system on which the interpreter runs.</li>
   </ul>
   
   <br>
   
   For a quick tour of GNU APL the details of the GNU APL system functions
   are far to extensive and we refer the reader to the <B>GNU APL info manual</B>
   where the GNU APL specific system functions are described in more detail,
   and to the ISO standard 13751 for more common system functions. Notet that
   some system functions arfe obsolete these days but maintained only for
   backward-compatibility with older (APL1-) interpreters.
   <br>
   
   
   <h5><a id="CH_3.4.14.1"></a>
   3.4.14.1 Z ← ⎕AF B : Atomic Function</h5>
   
   Monadic, obsolete. In a pure Unicode interpreter like GNU APL <B>⎕AF B</B>
    seems to be the same as <B>⎕UCS B</B>.
   
   <h5><a id="CH_3.4.14.2"></a>
   3.4.14.2 Z ← A ⎕AT B : Attributes</h5>
   
   Dyadic. For a (user-defined) name <B>FOO</B> which designates an existing
   defined function or variable, the expression <B>A ⎕AT 'FOO'</B> yields a
   numeric vector with attributes from a category that is defined by <B>A</B>:
   
   <ul>
   <li>A=1:  result type, function and operator valences</li>
   <li>A=2:  creation time, valences</li>
   <li>A=3:  execution peroperties</li>
   <li>A=4:  object sizes (CDR)</li>
   </ul>
   
   
   Note that the name <B>FOO</B> is quoted to make it a character vector. ⎕AT also
   accepts a character matrix if the attributes of multiple names shall be
   obtained.
   
   <h5><a id="CH_3.4.14.3"></a>
   3.4.14.3 Z ← A ⎕CR B : Character Representation</h5>
   
   Monadic. For a (user-defined) name <B>FOO</B> which designates an existing
   defined function or operator, the expression <B>⎕CR 'FOO'</B> yields the
   character representation for that name. The character representation of a
   function is a character matrix with one line for every line (including
   the header line) of the function or operator.
   <br>
   
   <br>
   
   Dyadic. As a GNU APL specific feature, dyadic <B>A ⎕CR 'FOO'</B> is one of
   over 40 different conversion functions. The integer scalar A ≥ 0 selects
   one of these functions. <B>A ⎕CR ⍬</B> and <B>A ⎕CR ''</B> display a list of
   the functions implemented so far.
   
   <h5><a id="CH_3.4.14.4"></a>
   3.4.14.4 Z ← ⎕DL B : Delay</h5>
   
   Monadic. <B>⎕DL N</B> pauses the operation of the interpreter for N seconds.
   
   <h5><a id="CH_3.4.14.5"></a>
   3.4.14.5 Z ← A ⎕DLX B : Donald Knuth's Dancing Links</h5>
   
   Dyadic. <B>⎕DLX</B> implements a powerful backtracking machinery known as
   "Dancing links" or "Algorithm X". The algorithm was published by Donald
   Knuth in 2000 and is the algorithm of choice for a class of problems that
   is best soved by means of backtracking. For example the 8 tower and 8
   queens problem on a chess-board or sudokus. Formally <B>⎕DLX</B> solves
   the so-called "exact cover problem": given a binary matrix B, find a
   subset Z of ⍳↑⍴B so that ( +/[1]B[Z;] ) ≡ ( (¯1↑⍴B)⍴1 ). Less formally:
   find a sub-maxtrix S←B[Z;] of B so that every column of S contains
   exactly one 1. The left arguments A of <B>A ⎕DLX B</B> controls the type
   of result desired such as compute only one solution, conmpute all solutions,
   etc.
   
   <h5><a id="CH_3.4.14.6"></a>
   3.4.14.6 Z ← A ⎕EA B : Execute Alternate</h5>
   
   Dyadic. <B>A ⎕EA B</B> computes <B>⍎B</B> and, if that fails, computes <B>⍎A</B>.
   A and B are character vectors containing APL expressions. The result of
    <B>A ⎕EA B</B> is the result of <B>⍎A</B> if it succeeds, else the result of
   <B>⍎B</B>. If <B>⍎B</B> succeeds then <B>⍎A</B> is not computed so that either
   <B>⍎B</B> or <B>⍎A</B> is being computed.
   
   <h5><a id="CH_3.4.14.7"></a>
   3.4.14.7 Z ← A ⎕EB B : Execute Both</h5>
   
   Dyadic. <B>A ⎕EB B</B> computes <B>⍎B</B> and then <B>⍎A</B>. Errors in <B>⍎B</B>
   are ignored, so that <B>⍎B</B> and <B>⍎A</B> are both computed. Typically
   <B>⍎A</B> is an error handler for the case where <B>⍎B</B> has failed, e.g.
   for providing a replacement for the missing result of <B>⍎A</B>.
   
   <B>⎕EB</B> is a GNU APL specific feature.
   
   <h5><a id="CH_3.4.14.8"></a>
   3.4.14.8 Z ← ⎕EC B : Execute Controlled</h5>
   
   Monadic. <B>⎕EC B</B> computes <B>⍎B</B> but does not interupt the APL
   interpreter when an error occurs. Instead the e-element result vector
   indicates <B>(Z1 Z2 Z3)←⎕EC B</B> indicates the type of result:
   
   <ul>
   <li>Z1=0: Error, e.g. 2+'A'</li>
   <li>Z1=1: Value, e.g. 2+2</li>
   <li>Z1=2: Committed Value, e.g. A←2+2</li>
   <li>Z1=3: No Value, e.g. FOO with FOO returning no result</li>
   <li>Z1=4: Branch, e.g. → 2</li>
   <li>Z1=5: Escape, e.g. →</li>
   </ul>
   
   
   <B>Z2</B> is the result that <B>⎕ET</B> (see below) would have had if <B>⍎B</B>
   were computed without <B>⎕EC</B>. When computed with <B>⎕EC</B> then <B>⎕ET</B>
   is not affected.
   
   <B>Z3</B> is the actual result of <B>⍎B</B>:
   
   <ul>
   <li>Z1=0: ⎕EM (see below)</li>
   <li>Z1=1: e.g. 4 for 2+2</li>
   <li>Z1=2: e.g. 4 for A←2+2</li>
   <li>Z1=3: 0 0⍴0</li>
   <li>Z1=4: e.g. 2 for → 2</li>
   <li>Z1=5: 0 0⍴0</li>
   </ul>
   
   
   <h5><a id="CH_3.4.14.9"></a>
   3.4.14.9 Z ← ⎕ENV B : ENvironment Variables</h5>
   
   Monadic. GNU APL feature: return the names and values of the environment
   variables in the operating system at the point in time when the GNU APL
   interpreter was started. The argument <B>B</B> of <B>⎕ENV B</B> is a prefix
   for the names of the environment variables that shall be returned.
   
   <h5><a id="CH_3.4.14.10"></a>
   3.4.14.10 Z ← A ⎕ES B : Event Simulate</h5>
   
   Nomadic. Programmatically simulate an error event. For testing error
   handlers. Monadic <B>⎕ES B</B> is <B>⎕EM ⎕ES B</B> or <B>B  ⎕ES ⎕ET</B> depending
   on B being either a character vector (event message) or a 2-item integer
   vector (event type).
   
   <h5><a id="CH_3.4.14.11"></a>
   3.4.14.11 Z ← ⎕EX B : EXpunge</h5>
   
   Monadic. Argument <B>B</B> of <B>⎕EX B</B> specifies one or more name(s) of
   variables, functions, or operators that shall be erased. For each name, the
   corresponding result item is 1 on success or 0 on error.
   
   <h5><a id="CH_3.4.14.12"></a>
   3.4.14.12 Z ← A ⎕FFT B : Fast Fourier Transform</h5>
   
   Nomadic. Compute the fast fourier transform of real or complex <B>B</B>.
   The optional argument <B>A</B> controls details such as a window function
   to be used for the FFT.
   
   <h5><a id="CH_3.4.14.13"></a>
   3.4.14.13 ⎕FIO[X] B : File I/O functions</h5>
   
   Dyadic. Similar to <B>A ⎕CR B</B> above, <B>A ⎕FIO B</B> is a collection of
   over 60 different (sub-) functions. Dyadic <B>A ⎕CR B</B> has a mandatory
   axis argument <B>X</B> which is an integer scalar X ≥ 0 that selects
   one of these sub-functions. The sub-function <B>⎕CR[X]</B> is then monadic,
   dyadic or nomadic.
   
   As a matter of convenience, the functions <B>A ⎕FIO ⍬</B> and <B>A ⎕FIO ""</B>
   (i.e. without an axis argument) display lists of the functions implemented
   by <B>A ⎕CR[X] B</B> so far in different formats.
   
   The functions in <B>⎕CR</B> are conversion functions which means that they
   transform one APL value into another APL value. As a consequence each
   conversion function is monadic and the left argument <B>B</B> is the value
   that is being converted.
   
   In contrast, the functions in <B>⎕FIO</B> constitue an interface to the
   underlying operating system and every function in <B>⎕FIO</B> corresponds
   to a C function in library libc. This has two consequences:
   
   <ol>
   <li>the corresponding C function in libc has more often than not two or
       more arguments. For this reason, the function number which selects
       the individual function is now the numeric axis argument <B>X</B>
       of <B>A ⎕FIO[X] B</B>.</li>
   <li>the now unused left argument <B>A</B> has now become avaiable as another
       argument for the selected function <B>⎕FIO[X]</B>. That is, all functions
       <B>A ⎕CR</B> are monadic while most functions <B>⎕FIO[X]</B> are dyadic.</li>
   </ol>
   
   
   In the early days of GNU APL there were only a few functions <B>⎕FIO[X]</B>
   and distinguishing different sub-functions by means of function numbers
   was already common practice (see, for example, ⎕AT above) and was adequate
   as long as the number of sub-functions was small. Over the years, however,
   more and more functions were added to <B>⎕FIO</B>, and the resulting
   APL code became more and more difficult to read. Therefore at
   some point in time a second mechanism - function names instead of function
   numbers - was added. One could now, for example, write <B>⎕FIO['fopen']</B>
   instead of the less intuitive <B>⎕FIO[3]</B>.
   <br>
   
   <br>
   
   A minor flaw of the new function names was that they needed to be quoted.
   This led to a third syntax variant where the function name became an
   (unquoted) APL name instead of a (quoted) APL string. This is most likely
   the final and most elegant syntax for <B>⎕FIO</B> where one can now write
   <B>⎕FIO.fopen</B> instead of <B>⎕FIO['fopen']</B> or <B>⎕FIO[3]</B>.
   
   <h5><a id="CH_3.4.14.14"></a>
   3.4.14.14 Z ← ⎕FX B : FiX</h5>
   
   Monadic. <B>B</B> is either a character matrix or a vector of function lines
   (function header and APL code). <B>⎕FX B</B> creates a new defined APL function
   (see the chapter "Defined Functions" below). With monadic ⎕FX one can therefore
   create new defined APL functions at runtime.
   <br>
   
   <br>
   
   Dyadic. As a GNU APL feature one can not only create defined functions that
   consis of lines of APL code, but also defined functions that were written
   in other computer languages, most commonly in C/C++. These so-called
   "native" functions are provided in terms of shared libraries that the user
   has to construct beforehand. In <B>A ⎕FX B</B> is <B>A</B> the file name of a
   shared library file and B the APL name of the function the is implemented
   in the shared library.
   <br>
   
   <br>
   
   GNU APL is shipped with a set of templates for creating native functions
   or operators that are intended as starting points for native functions
   created by the user.
   <br>
   
   <br>
   
   <h5><a id="CH_3.4.14.15"></a>
   3.4.14.15 Z ← ⎕GTK B : Gtk GUI</h5>
   
   <B>⎕GTK</B> is an interface to GTK (Graphical Tool Kit) version 3. It implements
   a small subset of the GTK 3 API and is intended for (and limited to)
   creating simple windows on the screen, for example to request input from
   the user in a more intuituve way than the old-fsshioned ⎕ and ⍞ input
   variables.
   
   <h5><a id="CH_3.4.14.16"></a>
   3.4.14.16 Z ← A ⎕JSON B : JSON parser</h5>
   
   Monadic. <B>B</B> is a text string in JSON (JavaScript Object Notation) format
   which is converted to the corresponding APL value <B>Z</B>.
   <br>
   
   <br>
   
   Dyadic. <B>B</B> is an APL value which is converted to the corresponding JSON
   string. <B>A</B> controls some aspect of this conversion, for example to read
   the JSON data string from a file rather than from an APL text vector.
   
   <h5><a id="CH_3.4.14.17"></a>
   3.4.14.17 Z ← A ⎕MAP B : MAP (replace) ravel elements</h5>
   
   <B>Z</B> is  <B>B</B> but with every occurance of ravel <B>A[j;1]</B> replaced
   with <B>A[j;2]</B>.
   
   The same can be achieved with <B>⎕RE</B>, but <B>⎕MAP</B> is optimized for this
   kind of 1:1 replacement while <B>⎕RE</B> is more powerful but slower.
   
   <h5><a id="CH_3.4.14.18"></a>
   3.4.14.18 Z ← ⎕INP B : INPut from script</h5>
   
   <B>⎕INP</B> is an early attempt to handle multi-line literals in GNU APL.
   It has been obsoleted by GNU APL multi-line literals but is still used
   internally. <B>⎕INP</B> should not be used in ordinary APL programs.
   
   <h5><a id="CH_3.4.14.19"></a>
   3.4.14.19 Z ← ⎕NA B : Name Association</h5>
   
   Obsolete. Throws a "NOT YET IMPLEMENTED" exeption when called. This fucntion
   ony exists so that workspaces from IBM APL2 that use it can be imported into
   GNU APL.
   
   <h5><a id="CH_3.4.14.20"></a>
   3.4.14.20 Z ← ⎕NC B : Name Class</h5>
   
   <B>B</B> is a matrix of APL names and <B>Z</B> is the current category for every
   name:
   
   <ul>
   <li>¯1: name B is not a valid APL name (i.e. B is malformed)</li>
   <li> 0: name B is a valid APL name but not used</li>
   <li> 1: name B denotes a label (in a defined function)</li>
   <li> 2: name B denotes a variable</li>
   <li> 3: name B denotes a defined function</li>
   <li> 4: name B denotes a defined operator</li>
   <li> 5: name B denotes a system variable (NOTE: only in GNU APL)</li>
   <li> 6: name B denotes a system function (NOTE: only in GNU APL)</li>
   </ul>
   
   
   <h5><a id="CH_3.4.14.21"></a>
   3.4.14.21 Z ← A ⎕NL B : Name List</h5>
   
   <B>Z</B> is a matrix of all (user-defined) names where: every name begins with
   APL string <B>A</B> and has one of the name classes in numeric vector <B>B</B>.
   
   <h5><a id="CH_3.4.14.22"></a>
   3.4.14.22 Z ← A ⎕PLOT B : Plot a Value</h5>
   
   Monadic. Simple plot (without attributes). The value <B>B</B> is plotted
   (i.e. displayed in a separate window) with default parameters for colors,
   line and point sizes, etc.
   <br>
   
   <br>
   
   Dyadic. Simple plot (with attributes). The value <B>B</B> is plotted with
   user-defined parameters in <B>A</B>.
   
   <h5><a id="CH_3.4.14.23"></a>
   3.4.14.23 Z ← A ⎕PNG B : Process PNG files and Pixel Images</h5>
   
   Monadic:
      Z ← ⎕PNG B with string B: Convert PNG file B into an array of color planes.
      monochrome images have one color plane while RGB images have 3 color planes
      (red, green, and blue). All images may have an additional opacity plane
      (aka. alpha channel).
   <br>
   
   <br>
   
      Z[;y;x] is the pixel at position (x, y) in the images, x counting from
     left to right and y from top to bottom.
   <br>
   
   <br>
   
      Z[1;;] is the gray plane for monochrome (grayscale) images and the red
      plane for RGB or RGBA images.
   <br>
   
   <br>
   
      Z[2;;] is the alpha channel for monochrome (grayscale) images with alpha
             channel and the green plane for RGB or RGBA images (unless 2 < ↑⍴Z).
   <br>
   
   <br>
   
      Z[3;;] is the blue plane for RGB or RGBA image (unless 3 < ↑⍴Z).
   <br>
   
   <br>
   
      Z[4;;] is the alpha channel RGBA images (unless 4 < ↑⍴Z).
   <br>
   
   <br>
   
      Z ← ⎕PNG B 3-dimensional array as returned above: Display the pixel array
      B in a window on the screen.
   <br>
   
   <br>
   
   Dyadic:
      Z ← A ⎕PNG B : Write pixel array B to file named A.
   
   <h5><a id="CH_3.4.14.24"></a>
   3.4.14.24 Z ← A ⎕RE B : Regular expression</h5>
   
   Dyadic. <B>Z</B> is <B>B</B> processed according to regular expression <B>A</B>.
   <B>⎕RE</B> is an interface to <B>libpcre</B> (where pcre stands for for
   Perl-compatible regular expression) and the format of <B>A</B> is described
   in the different man pages shipped with libpcre.
   
   <h5><a id="CH_3.4.14.25"></a>
   3.4.14.25 Z ← A ⎕RVAL B : Random APL value</h5>
   
   APL provides the primitive <B>? B</B> which returns an array of (pseudo-)
   random integers. <B>A ⎕RVAL B</B> generalizes this concept by computing
   (pseudo-) random APL values instead of pseudo-random integers. That
   means that not only the racwl items of Z but also the shape, depth, and
   types of the random values is chosen at random.
   
   Monadic. <B>⎕RVAL B</B> produces the next random value.
   
   Dyadic. <B>A ⎕RVAL B</B> controls the parameters (probablities) for subsequenct
   calls of monadic <B>⎕RVAL B</B>. The numeric scalar <B>A</B> specifies which
   parameter shall be specified:
   
   <ul>
   <li>A=0: change the random number generator state</li>
   <li>A=1: change the probabilities for ranks</li>
   <li>A=2: change the probabilities for shapes</li>
   <li>A=3: change the probabilities for types (character/integer/real/complex)</li>
   <li>A=3: change the probabilities for depths</li>
   </ul>
   
   
   <h5><a id="CH_3.4.14.26"></a>
   3.4.14.26 Z ← [A] ⎕SI B : State Indicator</h5>
   Return components of the State Indicator (see command )SI below) according
   to B:
   <ul>
   <li><B>⎕SI 1</B>: The name of the context. This is either the name of a defined
       function, or '◊' for an immediate execution context, or '⍎' for an execute
       context</li>
   <li><B>⎕SI 2</B>: The line number of a defined function, or 0 for for immediate
       execution and execute contexts.</li>
   <li><B>⎕SI 3</B>: funcion name and the line number in square brackets</li>
   <li><B>⎕SI 4</B>: like 3 but augmented like for command )SIS below.</li>
   <li><B>⎕SI 5</B>: The program counter (= token number) in the function.</li>
   <li><B>⎕SI 6</B>: The numeric parse mode</li>
   </ul>
   
   
   The optional left argument A is an integer scalar that selects one level of
   the )SI stack; if omitted then Z contains all levels of the )SI stack.
   
   <h5><a id="CH_3.4.14.27"></a>
   3.4.14.27 Z ← ⎕SQL[CMD] B : SQL functions</h5>
   
   ⎕SQL an interface to a SQL database. See <B>info apl</B> for details.
   
   <h5><a id="CH_3.4.14.28"></a>
   3.4.14.28 Z ← ⎕SVC B : Shared Variable Control</h5>
   
   Obsolete. Shared variables are an ancient communication concept from the
   mainframe area. They are, to some extent, supported by GNU APL for
   compatibility with IBM APL2. "Normal" APL variables are assigned and referenced
   by the same APL interpreter instance (i.e. process). In contrast, Shared
   variables are assigned and referenced by different processes, making each
   shared variable a communication link between the processes.
   <br>
   <br>
   
   In GNU APL the system function ⎕FIO provides communication channels that are
   simpler to use than shared variables. For that reason, the system functions and
   variables related to shared variables are not described in detail here. Users
   who need them (to run ancient workspaces) supposedly know how they work,
   and users who don't should avoid them.
   
   <h5><a id="CH_3.4.14.29"></a>
   3.4.14.29 Z ← ⎕SVO B : Shared Variable Offer</h5>
   
   Obsolete. See ⎕SVC  above.
   
   <h5><a id="CH_3.4.14.30"></a>
   3.4.14.30 Z ← ⎕SVQ B : Shared Variable Query</h5>
   
   Obsolete. See ⎕SVC  above.
   
   <h5><a id="CH_3.4.14.31"></a>
   3.4.14.31 Z ← ⎕SVR B : Shared Variable Retraction</h5>
   
   Obsolete. See ⎕SVC  above.
   
   <h5><a id="CH_3.4.14.32"></a>
   3.4.14.32 Z ← ⎕SVS B : Shared Variable State</h5>
   
   Obsolete. See ⎕SVC  above.
   
   <h5><a id="CH_3.4.14.33"></a>
   3.4.14.33 Z ← [A] ⎕STOP B : STOP vector</h5>
   
   B is a simple string with the name of a defined function.
   <br>
   
   Z is the stop vector for that defined function.
   <br>
   <br>
   
   if <B>A</B> is omitted then the stop vector for defined function <B>B</B> is
   returned. Otherwise the stop vector for the defined function is set to <B>A</B>.
   Setting the stop vector creates breakpoints at the lines in A. When such a
   breakpoint is reached then APL execution stops and a new immediate execution
   context is entered. The user can then examine and/or change variables,
   terminate or continue the APL execution with →, execute comands, etc.
   
   <h5><a id="CH_3.4.14.34"></a>
   3.4.14.34 Z ← A ⎕TF B : Transfer Form</h5>
   
   ⎕TF converts an object in the current workspace into an APL string (and vice
   versa).
   <br>
   <br>
   
   The integer scalar <B>A</B> selects the format for the result <B>Z</B>; A←1
   produces the <I>migration transfer form</I> while A←2 produces the
   <I>extended transfer form</I> of an object.
   
   String <B>B</B> is the name of an object (i.e. a variable, a defined function,
   or (with A←2) a defined operator) in the current workspace.
   
   <B>Z</B> is a string which is a text encoding of the object that can be stored in
   files, transferred over a network, etc. and that can be converted back to an
   identical object in some other workspace.
   
   The migration transfer form can only be used for old APL1 (aka. ISO standard
   8485) functions and variables because it does not not support APL2 (aka.
   ISO standard 13751) extensions, in particular not: mixed values, nested values,
   and defined operators. The format uses fixed size records of 80 bytes each,
   which makes it compatible with standard 80 column Hollerith punch cards
   (supposedly the prevalent storage medium for APL workspaces in the 1960s
   when APL was invented). For example:
   
<pre class=input_T line=602>      )CLEAR</pre>
<pre class=output1>CLEAR WS
</pre>
<pre class="input_" line=571>      ∇Z←A FOO B
      Z←1 2 3
      ∇
</pre>
<pre class=input_ line=603>      1 ⎕TF 'FOO'   ⍝ the migration transfer form of defined function FOO</pre>
<pre class=output1>FFOO 2 2 9 Z←A FOO BZ←1 2 3  
</pre>
   <pre class=output></pre>
   
   In contrast, the extended transfer form supports these APL2 extensions. It
   uses strings of APL code (primarily APL literals, ⎕FX for defined functions
   and operators, and ← for variables). For example:
   
<pre class=input_T line=602>      )CLEAR</pre>
<pre class=output1>CLEAR WS
</pre>
<pre class="input_" line=571>      ∇Z←A FOO B
      Z←1 (2 3) 'Hello'   ⍝ nested and mixed
      ∇
</pre>
<pre class=input_ line=603>      2 ⎕TF 'FOO'   ⍝ the extended transfer form of defined function FOO</pre>
<pre class=output1>⎕FX 'Z←A FOO B' 'Z←1 (2 3) ''Hello''   ⍝ nested and mixed'
</pre>
   <pre class=output></pre>
   If the string <B>B</B> is the result <B>Z</B> of some prior ⎕TF conversion, then
   A ⎕TF B creates the corresponding object in the current workspace and Z is
   the name of the object created (or '' if an error occurred).
   
   <br>
   
   
   
   <h5><a id="CH_3.4.14.35"></a>
   3.4.14.35 Z ← ⎕XML B : XML parser</h5>
   
   ⎕XML provides a set of functions for parsing XML documents and to extract the
   data contained in them. See <B>info apl</B> for details.
   
   <h5><a id="CH_3.4.14.36"></a>
   3.4.14.36 Z ← ⎕TRACE B : TRACE vector</h5>
   
   ⎕TRACE is similar to ⎕STOP above. The difference is that ⎕STOP stops the
   execution when it hits a breakpoint while ⎕TRACE merely generates a printout
   when it hits a breakpoint.
   
   <h5><a id="CH_3.4.14.37"></a>
   3.4.14.37 Z ← ⎕UCS B : Universal Char Set</h5>
   
   ⎕UCS converts APL characters to APL integers (with the codepoint of the
   character), and vice versa. <B>B</B> can be a mix of characters and the direction
   of the conversion is determined by the type of the item. Example:
   
<pre class=input_T line=602>      ⎕UCS 'Hello ', 119 111 114 108 100</pre>
<pre class=output>72 101 108 108 111 32 world
</pre>
   
   
   <h3><a id="CH_3.5"></a>
   3.5 Variables</h3>
   
   Like most computer languages, APL has variables. Unlike compiled computer
   languages, variables in APL need not be declared beforehand. Instead,
   variables are simply created by assigning a value to a name:
   
<pre class=input_T line=602>      VAR ← 1 2 3</pre>
<pre class=output>

</pre>
   
   
   If the name is in use for something other than a variable (for instance, a
   defined function), then a VALUE ERROR will be raised. After a value has been
   assigned to a name (and, as a side effect of that assignment, a variable with
   that name has been created) referring to the name returns the most recent value
   that was assigned to the variable:
   
<pre class=input_T line=602>      VAR</pre>
<pre class=output1>1 2 3
</pre>
<pre class=input_ line=603>      VAR ← 1 2 3 4   ⍝ assignment to name VAR</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      VAR             ⍝ reference of name VAR</pre>
<pre class=output>1 2 3 4
</pre>
   
   
   In the above examples a fundamental APL rule should be explained. Normally
   a values being computed, for example a constant or the result of a function,
   is displayed on the screen. If, however, the value is assigned to a variable,
   then it becomes a <B>committed value</B> which is not displayed. The value is
   not consumed by the assignment, so that it can be assigned to several variables
   in one go:
   
<pre class=input_T line=602>      V1 ← V2 ← 1 2 3</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V1</pre>
<pre class=output1>1 2 3
</pre>
<pre class=input_ line=603>      V2</pre>
<pre class=output>1 2 3
</pre>
   
   
   The lifetime of a variable (though not the lifetime of their value which can
   change over time) is normally infinite; such variables are called
   <B>global variables</B>. There exist also <B>local variables</B> whose lifetime
   begins when a defined function is called and ends when that function call
   returns a result. This will be explained together with user defined functions).
   
   The lifetime of a variable can be explicitly terminated by either the
   command <B>)ERASE</B> or the APL function <B>⎕EX</B> (expunge):
   
<pre class=input_T line=602>      V1</pre>
<pre class=output1>1 2 3
</pre>
<pre class=input_ line=603>      )ERASE V1</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V1</pre>
<pre class=errput1>VALUE ERROR
      V1
      ^
</pre>
<pre class=input_ line=603>      V2</pre>
<pre class=output1>1 2 3
</pre>
<pre class=input_ line=603>      ⎕EX 'V2'</pre>
<pre class=output1>1
</pre>
<pre class=input_ line=603>      V2</pre>
<pre class=errput>VALUE ERROR
      V2
      ^
</pre>
   
   
   The result 1 of ⎕EX indicates successful erasure of the variable. Note
   that the argument of ⎕EX is not the variable V2 but a character vector
   'V2' containing the name of the variable.
   
   <h4><a id="CH_3.5.1"></a>
   3.5.1 The Variables ⎕ and ⍞</h4>
   
   There are two important system variables, ⎕ (quad) and ⍞ (quote quad),
   that are used because of their side effects. They are probably the most
   frequently used system variables in APL programs.
   
   <h5><a id="CH_3.5.1.1"></a>
   3.5.1.1 Input and Output with ⍞</h5>
   
   When a value is assigned to ⍞ then the value is displayed on the screen:
   
<pre class=input_T line=602>      ⍞ ← 1 + 2   ⍝ compute 1 + 2 and display the result</pre>
<pre class=output>3</pre>
   
   
   In the example above the <B>⍞ ←</B> is redundant, because the result 3
   is not a committed value and would therefore have been displayed anyway.
   However, <B>⍞ ←</B> is most useful to display committed values and temporary
   values inside APL expressions, often for debugging purposes.
   <br>
   <br>
   
   When ⍞ is referenced, then a line of input is read from the keyboard (actually
   from stdin which is normally the keyboard) and the characters read,
   excluding the end of line character. The result of referencing ⍞ is always
   a character vector (the user input is quoted by ⍞, which may explain
   its name quote quad).
   
   <pre class=input_T>      INPUT ← ⍞   ⍝ quote-quad input</pre>
   <pre class=input_>what we type</pre>
   <pre class=output1></pre>
   <pre class=input_>      INPUT</pre>
   <pre class=output>what we type</pre>
   
   An important special case arises when the assignment of a value to ⍞ (but
   not ⎕) is immediately (i.e. without another input or output operation)
   followed by a reference of ⍞. In that case the terminating end-of-line
   character is suppressed and the input requested on the same line:
   
   <pre class=input_T>      ⍞←"ENTER AMOUNT: " ◊ AMOUNT ← ⍞</pre>
   <pre class=input_>ENTER AMOUNT: 42</pre>
   
   <pre class=output1></pre>
   <pre class=input_>      AMOUNT</pre>
   <pre class=output>              42</pre>
   
   This special case is often used in interactive APL programs to print a prompt
   that tells the user what shall be entered. If this is not desired, then you
   can use ⎕ instead of ⍞ in the first assignment:
   
   <pre class=input_T>      ⎕←"ENTER AMOUNT: " ◊ AMOUNT ← ⍞</pre>
   <pre class=input_>ENTER AMOUNT: </pre>      
   <pre class=input_>42</pre>      
   <pre class=output1></pre>
   <pre class=input_>      AMOUNT</pre>
   <pre class=output>42</pre>
   
   
   <h5><a id="CH_3.5.1.2"></a>
   3.5.1.2 Input and Output with ⎕</h5>
   
   When a value is assigned to ⎕ then the value is displayed like for ⍞.
   However, the terminating end of line character is always printed, so that
   ⎕ cannot display a prompt on the same line as the user input in the way
   described for ⍞.
   <br>
   
   <br>
   
   Reference of ⎕ differs from referencing ⍞ in two ways:
   <ol>
   <li>⎕ displays its own prompt <B>⎕:</B> on a separate line, and</li>
   <li>⎕ <I>evaluates</I> the input line as an APL expression, rather than quoting
       it automatically like ⍞ does. The evaluation may produce an error if the
       input entered is not a valid APL expression.</li>
   </ol>
   
   
   The following examples may explain the referencing of ⎕.
   <br>
   <br>
   
   <B>Example 1</B>: The user references ⎕ and assigns the result to a variable
   named INPUT:
   
   <pre class=input_T>      INPUT ← ⎕</pre>
   <pre class=output>⎕:</pre>
   
   After the ⎕: prompt, the user enters the (valid) APL expression <B>1 + 2</B>
   which evaluates to <B>3</B>:
   
   <pre class=input_T>      1 + 2
      INPUT</pre>
   <pre class=output>3</pre>
   <br>
   <br>
   
   <B>Example 2</B>: Like before, the user references ⎕ and assigns the result to a
   variable named INPUT:
   
   <pre class=input_T>      INPUT ← ⎕</pre>
   <pre class=output>⎕:</pre>
   
   After the ⎕: prompt, the user enters the (valid, since quoted) APL string
   <B>'Hello'</B> which evaluates to character vector <B>Hello</B>:
   
   <pre class=input_T>      'Hello'
      INPUT</pre>
   <pre class=output>Hello</pre>
   <br>
   <br>
   
   <B>Example 3</B>: Like before, the user references ⎕ and assigns the result to
   a variable named INPUT:
   
   <pre class=input_T>      INPUT ← ⎕</pre>
   <pre class=output>⎕:</pre>
   
   After the ⎕: prompt, the user enters the (invalid, since not quoted) <B>Hello</B>.
   <B>Hello</B> is now an APL Name as opposed to an APL stringi as in example 2.
   If a variable or niladic function with name <B>Hello</B> were defined, then its
   value would be assigned to a variable named INPUT. In our example, however,
   this is not the case and therefore a <B>VALUE ERROR</B> is raised:
   
   <pre class=input_T>      Hello</pre>
   <pre class="errput">VALUE ERROR
      Hello
      ^</pre>
   
   <h5><a id="CH_3.5.1.3"></a>
   3.5.1.3 ⎕ Input in Application Programs</h5>
   
   Input by means of ⎕ can be very powerful while writing and debugging APL
   programs. It should be avoided, however, in finished application programs.
   The reason is that ⎕ throws an error when the user enters something that
   is not a valid APL expression. In contrast, input by means of ⍞ does not
   throw errors and is therefore safer to use in application programs.
   
   <h3><a id="CH_3.6"></a>
   3.6 Indexing</h3>
   
   Most programming languages provide indexing which either references or
   updates a part of the value. Most often, however, indexing is restricted
   to a single item. In APL, indexing is much more powerful and can even be
   used to create bigger values than the indexed value.
   
   An <B>index expression</B>, or <B>index</B>, is a sequence of one or more
   non-negative simple integer values. The sequence is enclosed in brackets
   and the elements of the sequence are separated by semicolons (unless the
   length of the sequence is 1):
   
   <pre class=input_T>     [1;2 3]</pre>
   <pre class=output></pre>
   
   The example above shows an index with 2 elements 1 and 2 3. An index can not
   be used on its own, but is always bound to the value left of it. The value
   left of an index is then said to be indexed by the index expression. The
   semantics of indexing a value is that a subset of the ravel of the value
   is being addressed. This subset is then either referenced (copied) or
   changed (assigned) depending on whether the indexed value appears on the
   left of an assignment arrow ← or not. We call a value that is being assigned
   an <B>lvalue</B> (for left value).
   
   The index is most strongly bound to the value on its left, which causes
   indexing of the value to be  performed as soon as the value is available.
   If the value is an lvalue (a value subject to an assignment) then the
   lvalue is updated with some other value; otherwise the value is referenced.
   
   Often the item left of the index is a variable and then it looks as if parts
   the variable are updated or referenced:
   
<pre class=input_T line=602>      V←1 2 3 4   ⍝ create a variable</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V[2 3]       ⍝ indexed reference</pre>
<pre class=output1>2 3
</pre>
<pre class=input_ line=603>      V[2 3]←'x'   ⍝ indexed assignment</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V             ⍝ show result of indexed assignment</pre>
<pre class=output>1 xx 4
</pre>
   
   
   What happens behind the scene, however, is that the variable V in the above
   examples is resolved into a value (indexed reference) or into an lvalue
   (indexed assignment). The value or lvalue is then being indexed.
   
   For indexing to be successful, the index must satisfy certain conditions:
   
   <ul>
     <li>The number of items in the index (i.e. the number of semicolons + 1)
         must be equal to the rank of the index</li>
     <li>The i<SUP>th</SUP> item in the index must be an integer between 1 and the
          i<SUP>th</SUP> item of the shape of the value that is being indexed.</li>
   </ul>
   
   
   As a consequence of the first condition, scalars cannot be indexed
   (an index without semicolons would require a rank of 1 for the indexed value).
   
   The second condition ensures that the corresponding index items do not exceed
   the corresponding shape items. As a C programmer or mathematician you will
   find it more natural if the range of an index starts at 0 rather than 1.
   In APL this can be achieved by setting the system variable ⎕IO (index origin)
   to 0:
   
<pre class=input_T line=602>      ⎕IO←0</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      (1 2 3 4)[2]</pre>
<pre class=output1>3
</pre>
<pre class=input_ line=603>      ⎕IO←1</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      (1 2 3 4)[2]</pre>
<pre class=output>2
</pre>
   
   
   You should not use ⎕IO←0 too extensively because most APL programmers are
   used to the default value of 1 for ⎕IO and the readability of your code may
   suffer.
   
   An indexed assignment has the side effect of changing parts of the variable,
   but the result of it is the value that is assigned, i.e. the right side
   of the assignment. The result is not displayed. In that respect, indexed
   assignment behaves like non-indexed assignment.
   
<pre class=input_T line=602>      V←1 2 3 4</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V[3 3 3⍴2]←'X'</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V</pre>
<pre class=output>1 X 3 4
</pre>
   
   
   The example above does not make too much sense because the same index
   2 is assigned 27 times. We used it to show the difference to indexed
   reference below.
   
   An indexed reference of a variable or value has a result whose shape is
   the concatenated shape of the index. This can be used to create values that
   are bigger than the indexed value:
   
<pre class=input_T line=602>      (1 2 3 4)[3 3 3⍴2]</pre>
<pre class=output>2 2 2
2 2 2
2 2 2

2 2 2
2 2 2
2 2 2

2 2 2
2 2 2
2 2 2
</pre>
   
   
   Indexing is one of the favorite operations of APL programmers and fully
   understanding it is key to understanding APL. Therefore we summarize the
   rules governing indexed assignment and indexed reference:
   
   <ul>
   <li>Common Requirements on Z ← A[X<SUB>1</SUB>;...;X<SUB>N</SUB>] and
         A[X<SUB>1</SUB>;...;X<SUB>N</SUB>] ← B</li>
     <ul>
     <li>A has rank N > 0 (and there are N-1 ≥ 0 semicolons inside the brackets).</li>
     <li>Each X<SUB>i</SUB> is a non-nested integer value of arbitrary shape.</li>
     <li>For every integer I in the ravel of X<SUB>i</SUB>: ⎕IO ≤ I ≤ ⎕IO + (⍴A)[i]).</li>
     </ul>
   
   
   <li>Indexed Assignment A[X<SUB>1</SUB>;...;X<SUB>N</SUB>] ← B</li>
     <ul>
     <li>The result of an indexed assignment is B; as a side effect some items
           in the ravel of A are updated with items in the ravel of B.</li>
     <li>The result is a committed value (and is therefore not displayed).</li>
     <li>If B is a scalar then it is scalar extended according to
         X<SUB>1</SUB>, ..., X<SUB>N</SUB>.</li>
     <li>repeated values in some X<SUB>i</SUB> are valid, but the result is
         implementation dependent (unless the corresponding items in B are
         identical).</li>
     <li>The shape of B can have trivial dimensions (dimensions of length 1). Such
         dimensions are ignored. The length of any non-trivial dimension (⍴B)[i]
         must match the number of elements ⍴,X<SUB>i</SUB> in the corresponding index
         item X<SUB>i</SUB>.</li>
     </ul>
   
   
   <li>Indexed Reference Z ← A[X<SUB>1</SUB>;...;X<SUB>N</SUB>]</li>
     <ul>
       <li>The rank of the result, i.e. ⍴⍴Z, is the sum of the ranks of items
           in the index list: ⍴⍴Z ↔ (⍴⍴Z<SUB>1</SUB>) + ... + (⍴⍴Z<SUB>N</SUB>)  </li>
       <li>The shape of the result is the catenation of items in the index
           list:  ⍴Z ↔ (⍴Z<SUB>1</SUB>), ..., (⍴X<SUB>N</SUB>) </li>
     </ul>
   
   </ul>
   
   
   A special case of an index item is the "elided index". If no value is given
   between two brackets or semicolons, then this means that the entire dimension
   (and not, as you might expect, nothing) is selected by the index item:
   
<pre class=input_T line=602>      A←3 4 ⍴ 1 2 3 4 5 6 7 8 9 10 11 12</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      A</pre>
<pre class=output1>1  2  3  4
5  6  7  8
9 10 11 12
</pre>
<pre class=input_ line=603>      A[2;]   ⍝ elided index for last dimension, aka. a "row"</pre>
<pre class=output1>5 6 7 8
</pre>
<pre class=input_ line=603>      A[;2]   ⍝ elided index for first dimension, aka. a "column"</pre>
<pre class=output>2 6 10
</pre>
   
   
   A final example shows the effect of multiple items in different dimensions:
   
<pre class=input_T line=602>      A←6 20⍴'∘'</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      A</pre>
<pre class=output1>∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
</pre>
<pre class=input_ line=603>      A[;2 3 9 14]←'║'   ⍝ set columns 2, 3, 9, and 14 to ║</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      A</pre>
<pre class=output1>∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
</pre>
<pre class=input_ line=603>      A[1 3 6;]←'═'   ⍝ set rows 1, 3, and 6</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      A</pre>
<pre class=output1>════════════════════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
════════════════════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
════════════════════
</pre>
<pre class=input_ line=603>      A[1 3 6;2 3 9 14]←'╬'   ⍝ set rows 1, 3, and 6 in columns 2, 3, 9, and 14</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      A</pre>
<pre class=output>═╬╬═════╬════╬══════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
═╬╬═════╬════╬══════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
═╬╬═════╬════╬══════
</pre>
   
   
   A disadvantage of the bracket index is that while the shapes of the index items
   can be freely chosen, the number of semicolons (and therefore the rank of A)
   is fixed. That makes it impossible to write functions that cope with arbitrary
   ranks of A.
   
   For that reason, a dyadic function X⌷A (called index) is provided where
   X plays the role of X<SUB>1</SUB>;...;X<SUB>N</SUB> in bracket index. X is a 
   (typically nested) vector of length N and both reference (Z←X⌷A) and
   assignment (X⌷A)←B are possible. Unlike bracket index, scalars can be
   indexed with the index function (X then has length 0), but elided indices
   are not supported by the index function.
   
   <h3><a id="CH_3.7"></a>
   3.7 Execution of APL Statements</h3>
   
   APL statements are either entered in immediate execution mode, or else
   as the body lines of user defined functions.
   
   An APL statements starts out as a sequence of characters other than the
   statement separator ◊ (which, as the name suggests, separates different
   statements on the same line) and the end of line character (linefeed).
   The examples provided above were examples of APL statements.
   
   An example of a line with 3 statements (and no output) is this:
   
<pre class=input_T line=602>      A←1 ◊ B←2 ◊ C←3</pre>
<pre class=output>

</pre>
   
   
   The first thing that the APL interpreter does when a statement is entered
   is to convert the characters of the statement into an internal format
   called tokens. The conversion of a sequence of characters into a sequence
   of tokens, commonly called <B>lexical analysis</B> or <B>tokenization</B>,
   can lead to errors when characters that do not have a meaning in APL,
   are discovered:
   
<pre class=input_T line=602>      ∫ f(x) dx</pre>
<pre class=errput1>Unknown APL character: ∫ (U+222B)
Non-APL character+
</pre>
   
   <pre class=output></pre>
   
   The rules for tokenizing the input characters are relatively simple:
   
   <ul>
   <li>APL literals are converted to a token that contains the APL value
       represented by the literal (as discussed in previous chapters)</li>       
   <li>APL names are converted to a token that contains the name
       (as discussed in previous chapters)</li>       
   <li>All other characters are converted to a token representing that character</li>
   </ul>
   
   
   Tokenization is done because operation at the character level is relatively
   inefficient, while the internal token format can be parsed more efficiently.
   In compiled languages tokenization and parsing are both performed by the
   compiler and the efficiency of the internal representation is not relevant
   for the efficiency of the compiled program. APL is interpreted, however,
   part of the parsing is performed at runtime and the purpose of tokenization
   is to perform as much analysis of a statement as possible when the statement
   is entered rather than later (and possibly repeatedly) when the statement
   is executed.
   
   As an example, the statement
   
<pre class=input_T line=602>      VARIABLE←1 2 'Hello' (2 'world')</pre>
<pre class=output>

</pre>
   
   
   is converted into 3 tokens:
   <br>
   
   <br>
   
   <label class=token>VARIABLE</label><label class=token>←</label><label class=token>1 2 'Hello' (2 'world')</label>
   <br>
   
   <br>
   
   This is possible because the somewhat complicated looking value
   <B>1 2 'Hello' (2 'world')</B> is entirely comprized of APL literals,
   which can be collapsed into a single (here: nested) value at tokenization
   time. On the other hand, if there are non-literals (such as functions or
   names) between the APL literals, then the literals left or right of the
   non-literals can not be combined and therefore show up in different tokens:
   
<pre class=input_T line=602>      VARIABLE←1 2 ⍴ 'Hello' (2 'world')</pre>
<pre class=output>

</pre>
   
   <br>
   
   <label class=token>VARIABLE</label><label class=token>←</label><label class=token>1 2</label><label class=token>⍴</label><label class=token>'Hello' (2 'world')</label>
   <br>
   
   <br>
   
   In immediate execution mode, the token sequence created by the tokenization
   of the input line is immediately executed, and there seems to be no difference
   between tokenization time and execution time. With user defined functions,
   however, it pays off to separate lexical analysis from parsing at execution
   time.
   
   The token sequence for the statement is then stored until it is executed.
   Conceptually, the first step when a statement is executed it to group (also
   called "bind") certain token to other token. APL has no operator precedence
   like other languages (the large number of built-in functions and operators
   in APL would have made that a tedious task). However the binding of token
   plays a similar role. Unfortunately the ISO standard fails to mention the
   rules for token binding, but we can refer to the the descriptions of
   commercial APL vendors. According to those descriptions the binding of token
   has the following precedences (from strongest binding to weakest binding):
   
   <ol>
   <li>bracket index to the token on its left</li>
   <li>assignment arrow to the token on its left</li>
   <li>dyadic operator to its right operand (the function right of it)</li>
   <li>items in vector notation</li>
   <li>operator to its left operand (the function left of it)</li>
   <li>function to its left argument (the value left of it)</li>
   <li>function to its right argument (the value right of it)</li>
   <li>assignment arrow to the token on its right</li>
   </ol>
   
   
   When we refer to, for example, a "token on its left", then this means when
   the token becomes available. In the following example:
   
<pre class=input_T line=602>      (2 × 1 2 3 4)[2]</pre>
<pre class=output>4
</pre>
   
   
   the bracket index [2] has the strongest binding. Before that binding can
   take place, however, the expression in parentheses, (2 × 1 2 3 4), must
   have been evaluated (yielding 2 4 6 8). The vector 2 4 6 8 is then indexed by
   bracket index [2] to give the final result 4.
   <br>
   
   <br>
   
   You may also wonder why operators bind to their operand but not to their
   arguments. The reason is that:
   
   <ul>
   <li>when a dyadic operator binds to its right operand, then the bound dyadic
       operator has become a monadic operator.</li>
   <li>when a monadic operator (or a bound dyadic operator) binds to its left
       operand, then the bound monadic operator has become a function.</li>
   <li>the bound monadic operator, then binds to its left and right arguments like
       every other dyadic or monadic function.</li>
   </ul>
   
   
   Note also that the actual number of binding strengths is smaller than the list
   above suggest. This is because some bindings are not in conflict with each
   other. For example, vector notation binds two or more values to each other,
   while the next lower binding strength binds an operator to a function.
   These two bindings could have been given the same binding strength.
   <br>
   
   <br>
   
   Some bindings merely define the order in which things are evaluated while
   others produce an intermediate result. For example, the binding of a dyadic
   function to its left argument forces a left argument in parentheses to be
   evaluated first and then the result to be passed to the dyadic function.
   On the other hand, the binding of a bracket index to the value or lvalue
   on its left forces immediate computation of the bracket index as described
   above.
   <br>
   
   <br>
   
   After binding the token, the evaluation of APL statements is performed 
   according to the "golden rule" of APL:
   <br>
   
   <br>
   
   <B>The rightmost function whose argument(s) are available is evaluated
       first.
       <br>
   
       The function and its argument(s) are then replaced by the result
       returned by the function, which causes the arguments of other functions
       to become available.
   </B>
   <br>
   
   <br>
   
   In short this means that APL statements are evaluated from right to left.
   Another consequence is that parentheses around the right argument of a
   function have no effect, while parentheses around the left argument make
   a difference:
   
<pre class=input_T line=602>      (1 + 2) × (3 + 4)   ⍝ 3 × 7</pre>
<pre class=output1>21
</pre>
<pre class=input_ line=603>      (1 + 2) × 3 + 4     ⍝ 3 × 7</pre>
<pre class=output1>21
</pre>
<pre class=input_ line=603>      1 + 2 × (3 + 4)     ⍝ 1 + (2 × 7)</pre>
<pre class=output1>15
</pre>
<pre class=input_ line=603>      1 + 2 × 3 + 4       ⍝ 1 + (2 × 7)</pre>
<pre class=output>15
</pre>
   
   
   
   <h3><a id="CH_3.8"></a>
   3.8 Defined Functions</h3>
   
   Programming in APL is primarily concerned with the creation and test of
   user defined functions. The immediate execution mode used so far is helpful
   to try things out, but not for larger applications.
   <br>
   
   <br>
   
   For the sake of explanation we define a user defined function to be a
   non-empty sequence of <B>function lines</B> numbered 0, 1, .... The first
   line is called function header and determines the following properties of
   the function:
   
   <ul>
   <li>if the function returns a value or not</li>
   <li>the valence (number of value arguments): niladic, monadic, or dyadic</li>
   <li>the name of the function or operator</li>
   <li>the number of function arguments: none (normal function),
       1 (monadic operator), or 2 (dyadic operator)</li>
   <li>the optional axis of the function or monadic operator</li>
   <li>the names of local variables of the function</li>
   </ul>
    
   
   <h4><a id="CH_3.8.1"></a>
   3.8.1 Function Header</h4>
   
   The header line of a user defined function consists of several APL names
   interleaved with some of the characters ←, (, ), [, ], and ;.
   The names can are freely chosen by the user; we will use the names
   Z, A, LO, F, X, B, RO, C, and D in our examples with the following meaning:
   
   <ul>
   <li>Z: the name of the result</li>
   <li>A: the left value argument</li>
   <li>LO: the left function argument of an operator</li>
   <li>RO: the right function argument of a dyadic operator</li>
   <li>F: the name of the function</li>
   <li>X: the axis argument</li>
   <li>B: the right value argument</li>
   <li>C: the first local variable</li>
   <li>D: the second local variable...</li>
   </ul>
    
   
   The syntax of the function header is then:
   <br>
   
   <br>
   function-header ::= result-spec function-and-args local-variables
   <br>
   result-spec ::= empty | Z ←
   <br>
   function-and-args ::= function-spec | function-spec B | A function-spec B
   <br>
   function-spec ::= function | ( LO function ) | ( LO function RO )
   <br>
   function ::= F | F [ X ]
   <br>
   local-variables ::= empty | ; C local-variables
   <br>
   
   <br>
   
   Additional requirements are that all names in the header must be different and
   that no name (with the exception of names for local variable names) must be
   user defined names. The names of a local variable may be the name of system
   variables, but must not be the name of a system function or primitive.
   <br>
   
   The possible combinations in the syntax above produces 2×3×3×2 = 36
   different header variants. Of these 36 variants the following 7 combinations
   are not allowed:
   
   <ul>
   <li>niladic function with axis</li>
   <li>monadic operator operator with no value argument</li>
   <li>monadic operator operator with axis and no value argument</li>
   <li>dyadic operator operator with no value argument</li>
   <li>dyadic operator operator with axis and no value argument</li>
   <li>dyadic operator operator with axis and one value argument</li>
   <li>dyadic operator operator with axis and two value arguments</li>
   </ul>
   
   
   The following sections describe the different fields of the function header.
   Before that we briefly describe one way to create and display user defined
   functions.
   
   <h5><a id="CH_3.8.1.1"></a>
   3.8.1.1 Creating and displaying defined functions: ⎕FX and ⎕CR</h5>
   
   The monadic system function ⎕FX creates a new function. The single argument of
   ⎕FX is either a character matrix (and the first row of that matrix is the
   function header) or a nested vector of character vectors (and the first
   character vector is then the header of the function. The remaining rows of
   the matrix or the remaining character vectors are the body lines of the
   function being created. On success ⎕FX returns the name of the function
   that it has created.
   
   Monadic ⎕CR displays the header and body lines of a function. The single
   argument of ⎕CR is the name of the function to be displayed. ⎕CR returns
   a matrix with the function header and the function body.
   
<pre class=input_T line=602>      )CLEAR</pre>
<pre class=output1>CLEAR WS
</pre>
<pre class="input_" line=571>      ∇FOO
      1 + 2
      ∇
</pre>
<pre class=input_ line=603>      ⎕CR 'FOO'</pre>
<pre class=output>FOO  
1 + 2
</pre>
   
   
   <h5><a id="CH_3.8.1.2"></a>
   3.8.1.2 Result Specification</h5>
   
   The example above has created a function FOO that had no result specification.
   Such functions can be executed, but they do not return a result and attempts
   to use their return fails:
   
<pre class=input_T line=602>      )CLEAR</pre>
<pre class=output1>CLEAR WS
</pre>
<pre class="input_" line=571>      ∇FOO
      1 + 2
      ∇
</pre>
<pre class=input_ line=603>      FOO                 ⍝ call FOO (that is OK)</pre>
<pre class=output1>3
</pre>
<pre class=input_ line=603>      VAR←FOO             ⍝ try to use FOO's result (that is an error)</pre>
<pre class=output1>3
</pre>
<pre class=errput>VALUE ERROR+
      VAR←FOO
      ^
</pre>
   
   
   The reason why some value (3) was displayed is not because FOO has returned
   the result 3, but because the statement '1 + 2' was not assigned to a variable
   and therefore printed.
   
   For a function to return a result, two conditions must be met:
   
   <ol>
   <li>the header must contain a result specification such as <B>Z←</B>, and</li>
   <li>the variable named in the result specification must be assigned during
       the execution of the function</li>
   </ol>
   
   
   The result specification is a user-defined name followed by the assignment
   arrow ← :
   
<pre class=input_T line=602>      )CLEAR</pre>
<pre class=output1>CLEAR WS
</pre>
<pre class=input_ line=603>      ⍝ define FOO returning result Z</pre>
<pre class="input_" line=571>      ∇Z←FOO
      Z←1 + 2
      ∇
</pre>
<pre class=input_ line=603>      FOO                         ⍝ call FOO</pre>
<pre class=output1>3
</pre>
<pre class=input_ line=603>      VAR←FOO                     ⍝ try to use FOO's result</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      VAR   ⍝ show result</pre>
<pre class=output>3
</pre>
   
   
   The output of simply calling FOO is the same as before. However, the value
   3 is now the result of FOO and not the result of the statement Z←1 + 2 inside
   FOO. This is because the assignment Z←1 + 2 is now a committed value which
   is not printed.
   
   If the function header has a result specification, but the result variable is
   not assigned, then
   
<pre class=input_T line=602>      )CLEAR</pre>
<pre class=output1>CLEAR WS
</pre>
<pre class=input_ line=603>      ⍝ define FOO returning Z without assigning Z (which is more often than not an error)</pre>
<pre class="input_" line=571>      ∇Z←FOO
      1 + 2
      ∇
</pre>
<pre class=input_ line=603>      FOO  ⍝ call FOO</pre>
<pre class=output1>3
</pre>
<pre class=input_ line=603>      VAR←FOO  ⍝ call FOO (OK) and try to use FOO's result (ERROR)</pre>
<pre class=output1>3
</pre>
<pre class=errput>VALUE ERROR+
      VAR←FOO
      ^
</pre>
   
   
   Forgetting, like above, to assign the result value inside a defined function
   whose header indicates that the function returns a result is an error that 
   is sometimes hard to discover, in particulat when the function contain
   branches (so that some execution paths assign the result and some don't).
   In that case the programmer may be mislead by the fact that the function
   header indicates a result and incorrectly assume that the result variable
   is actually assigned before the function returns.
   
   <h5><a id="CH_3.8.1.3"></a>
   3.8.1.3 Local Variables</h5>
   
   The function header can optionally contain a list of local variables. Every
   local variable is appended to the function header with a semicolon in front 
   of it. For example:
   
   <pre class=input_T>A FOO B;C;D</pre>
   <pre class=output></pre>
   is the header of a dyadic function (with arguments A and B) and local
   variables C and D.
   
   At this point we should reveal that every user defined name, and also the
   APL system variables have an associated stack, The stack is created when
   the name is first mentioned (or from the outset if the name refers to an
   APL system variable).
   
   When a user defined function is called, then the stack of the following
   names is pushed:
   
   <ul>
   <li>the function result</li>
   <li>the function arguments</li>
   <li>the local variables, and</li>
   <li>labels (see below)</li>
   </ul>
   
   
   After pushing a name, the name refers to nothing, which is usually changed
   shortly after pushing it. The previous values of the name are now
   inaccessible. Only the item on the top of a name's stack can be accessed.
   
   The name on the top of the stack remains accessible until either another
   (or the same) function with the same name in its local variables is called,
   or else until the functions returns. If the function returns then the stacks
   of all its local variable names are poped and the previous top of the stack
   becomes accessible again.
   
   <h5><a id="CH_3.8.1.4"></a>
   3.8.1.4 The Del Editor</h5>
   
   ⎕FX is not the only way to create user defined functions. ⎕FX is good if
   the function created is small and is often the only way to create new
   functions programmatically. An alternative present in many APL interpreters
   is the interactive 'Del' editor. The Del editor is started by entering
   the APL character Nabla (<B>∇</B>) and the full header of the new function.
   The Del editor has simple commands for displaying, inserting, editing, and
   deleting function lines.
   
   The Del editor has a prompt which is the next line to be added or changed;
   This line is displayed in square bracket. If the user wants to change a
   different line than the line proposed by the Del editor then the desired
   is entered (again in square brackets). The following is an overview of
   Del editor commands:
   <br>
   
   <br>
   
   <table cellspacing="0" cellpadding="0">  <tr>  <th>Command <th>Effect
     <tr>  <td class=tab>[N]     <td class=tab>Continue editing with line N
     <tr>  <td class=tab>[⎕]     <td class=tab>display all function lines
     <tr>  <td class=tab>[⎕N]    <td class=tab>display the function lines 1 to (including) N
     <tr>  <td class=tab>[N⎕]    <td class=tab>display the function line N and the following
     <tr>  <td class=tab>[N⎕M]   <td class=tab>display function lines N to M (including)
     <tr>  <td class=tab>[∆N]    <td class=tab>delete function lines N
     <tr>  <td class=tab>[N∆M]   <td class=tab>delete function lines N to M
     <tr>  <td class=tab>[→]     <td class=tab>discard changes
     <tr>  <td class=tab>∇       <td class=tab>close the Del editor
   </table>
   
   <br>
   
   <br>
   
   Entering a non-existing fractional number, like in [3.5] creates a new line
   between the closest existing lines (between lines 3 and 4 if there are no
   other fractional line numbers between 3 and 4). When the Del editor is
   closed then all lines will be renumbered, starting with header line 0.
   <br>
   
   These days you will use your own editor like <B>Vim</B> or <B>emacs</B> to edit
   APL functions and then cut-and-paste them into the window in which APL runs,
   or start APL with a text file containing function definitions. However, at
   the time when the Del editor was invented, computer mice were not yet invented
   and terminals were too limited in functionality to support cut-and-paste.
   Most commands of the Del editor are irrelevant today, but the Del editor is
   still the method of choice when defining function in (non-interactive) APL
   scripts create new APL functions.
   <br>
   
   For example, say you have a normal (UTF8 encoded) text file containing
   the following:
   <pre class=input_T>
∇ Z←FOO
  1 + 2
∇</pre>
   <pre class=output></pre>
   <br>
   
   That defines the same function as;
   <pre class=input_T> ⎕FX 'Z←FOO' '1 + 2'
   </pre>
   <pre class=output></pre>
   <br>
   
   but is more readable, in particular when functions become longer. We will
   use this format for displaying functions. The above format is also suitable
   for displaying APL code snippets in emails or on web pages. The reader can
   simply cut-and-paste then into his interpreter (provided of course, that
   the interpreter uses UTF8 encoded Unicode and not special APL fonts).
   
   <h5><a id="CH_3.8.1.5"></a>
   3.8.1.5 Function Body</h5>
   
   The remaining lines of a function are called the <B>function body</B>.
   The function body consists of 0 or more <B>function lines</B>. Every
   function line consists of 0 or more APL statements like those already
   discussed above.
   
   A function line can have an optional <B>label</B>. A label is another kind
   of local variables that is automatically created, cannot be changed, and
   has an integer value that is equal to the number of the line on which it
   was written. For example:
   
   <pre class=input_T>∇A FOO1 B;C;D
L1: 'line 1'
L2: 'line 2'
 X←L2
∇</pre>
   <pre class=output></pre>
   
   The hypothetical function FOO1 above has two arguments A and B, explicit
   local variables C and D, and labels L1 and L2. The syntax for a label is a
   name followed by a colon. The variable X would get the values 2 because
   label L2 is on line 2. labels are read-only; attempting to change their
   value yields a SYNTAX ERROR. Labels will be discussed together with branching
   in functions below.
   
   <h4><a id="CH_3.8.2"></a>
   3.8.2 How Functions and Operators are Evaluated</h4>
   
   The execution (or evaluation) of a function starts when the function name
   is detected in a statement and all its arguments (as defined by the header
   of the function) are present. Lets assume we define FOO like this:
   
<pre class=input_T line=602>      )CLEAR</pre>
<pre class=output1>CLEAR WS
</pre>
<pre class=input_ line=603>      ⍝ define dyadic FOO with result Z and arguments A and B</pre>
<pre class="input_" line=571>      ∇Z←A FOO B;C;D
      L1: 'line 1'
      L2: 'line 2'
      X←L2
      Z←42
      ∇
</pre>
<pre class=input_ line=603>      ⎕CR 'FOO'   ⍝ check FOO</pre>
<pre class=output1>Z←A FOO B;C;D
L1: 'line 1' 
L2: 'line 2' 
X←L2         
Z←42         
</pre>
   
   <pre class=output></pre>
   
   Then we enter the following in immediate execution mode:
   
<pre class=input_T line=602>      (3 + 4) FOO 5</pre>
<pre class=output>line 1
line 2
42
</pre>
   
   
   The APL interpreter will see FOO, but it will notice that the left argument
   of FOO, i.e. (3 + 4,) is not yet available because the result of (3 + 4) has
   not yet being computed. The interpreter will therefore compute (3 + 4) first
   and replace it by 7. We have now:
   
   <pre class=input_T> 7 FOO 5</pre>
   <pre class=output></pre>
   
   The interpreter can now evaluate 7 FOO 5 (or some other function in the
   general case) as follows:
   
   <ol>
     <li>first the stacks of all names are pushed. In our example, the names
         being pushed are Z, A, B, C, D, L1, and L2 (but not FOO!)</li>
     <li>next the actual arguments of the function (7 and 5) are assigned to
         the formal parameters (A and B) of the function. That is, A←7 and B←5.</li>
     <li>the labels are assigned, i.e. L1←1 and L2←2.</li>
     <li>(at this point, the function result Z and the local variables C and D
         are undefined, while the function arguments A and B and the labels
         have values)</li>
     <li>the statements in the function body are executed, starting with the
         first statement in the first line.</li>
     <li>the function result Z, which may or may not be defined is stored in
         a temporary location.</li>
     <li>all stacks of all names that were pushed above are poped. They now have
         the value they had when FOO was called.</li>
     <li>the function and its arguments are replaced by the function result in
         the temporary location.</li>
   </ol>
   
   
   In our example, the following output is produced:
   
<pre class=input_T line=602>      (3 + 4) FOO 5</pre>
<pre class=output>line 1
line 2
42
</pre>
   
   
   The first two output lines ("line 1" and "line 2") are output from lines
   1 and 2 of FOO, while the last line is the return value from FOO which
   is displayed <B>after</B> FOO has returned.
   
   <h4><a id="CH_3.8.3"></a>
   3.8.3 Branching</h4>
   
   The examples of user defined functions given so far were "linear" by which
   we mean that the statements in the body of the function were executed one
   after the other until the end of the function was reached.
   <br>
   
   In addition to that, APL provides a means to change the order of the
   normal program flow from the beginning of a function to its end: a
   computed branch.
   <br>
   
   <br>
   
   APL has been criticized for having only one way of changing the order of
   the program flow instead of many (like if/else, for, while, and case in C/C++).
   However the computed branch in APL is so powerful that it can easily emulate
   the multiple flow control statements in other languages. And the fact that APL
   works on larger data structures than scalars makes the low-level loops found
   in other languages obsolete.
   <br>
   
   <br>
   
   A <B>computed branch</B> is a statement that consists of a branch arrow (→) and
   a numeric APL value. A slightly different statement, called <B>Escape</B>
   consists of the same branch arrow, but without the value. For example:
   
   <ul>
     <li>→L   ⍝ computed branch (to label L)</li>
     <li>→    ⍝ escape</li>
   </ul>
   
   <h5><a id="CH_3.8.3.1"></a>
   3.8.3.1 Labels</h5>
   
   The numeric argument of a computed branch is a line number. So →1 is a
   branch to line 1 of some user defined function. However, absolute line
   numbers should never be used for branching. The reason is that APL renumbers
   the lines of a user defined function when new lines are added between
   existing lines. The line numbers in branches are not renumbered when
   renumbering lines and as a consequence the absolute line numbers in branches
   become invalid. This problem can easily be solved by using labels.
   <br>
   
   A label is an APL name followed by : (colon) at the beginning of a line.
   The label is an automatically created local variable whose value is
   the line number on which it was written and the variable is read-only
   (i.e. one cannot assign a new value to it). Unlike absolute line numbers,
   labels move with their line when other lines are inserted before them and
   as a subsequent renumbering lines does not harm labels.
   <br>
   
   Example:
   
   <pre class=input_T></pre>
   <pre class=output>∇FOO
    'line 1' ◊ →3    ⍝ Bad: absolute branch to line 3
    'line 2' ◊ →L3   ⍝ Good: branch to line 3 with label L3
L3: 'line 3' ◊ 
∇</pre>
   
   If another line is inserted before the first line, then FOO becomes:
   
   <pre class=input_T></pre>
   <pre class=output>∇FOO
    'new line before line 1' 
    'line 1' ◊ →3    ⍝ Bad: absolute branch to line 3
    'line 2' ◊ →L3   ⍝ Good: branch to line 3 with label L3
L3: 'line 3' ◊ 
∇</pre>
   
   The previous line 3 with label L3 is now line 4. The branch to the absolute
   line number 3, i.e. →3, now branches to the line before the line with label
   L3 (which is most likely wrong now), while the branch to label L3 remains
   correct.
   
   <h5><a id="CH_3.8.3.2"></a>
   3.8.3.2 Computed Branch (inside a function)</h5>
   
   Inside a function a computed branch →EXPR where EXPR is some APL expression
   is executed as follows.
   
   <ul>
     <li>first the expression EXPR is evaluated. If the evaluation of EXPR fails
         then this is an error and execution of the function stops as described
         later on.
     </li>
         
     <li>Let X be the result of evaluating EXPR. Then:
       <ul>
         <li>if X is empty, then execution continues with the next statement after
             the branch. This is can be used to emulate if statement in C++</li>
         <li>if X is not empty, then it is expected to be a vector whose first
             element is an integer L.</li>
           <ul>
              <li>if L is a valid line number, (a number between 1 and
                   the number of lines in the function (including)) then
                  then a branch to that line is performed. That is, execution
                  continues at the first statement on the new line.</li>
              <li>Otherwise, i.e. L is ≤ 0 or larger than the number of lines
                  in the function, then execution of the function is ended.</li>
           </ul>
   
       </ul>
   
     </li>
   </ul>
   
   
   In the following we explain some examples of frequently used branch patterns
   and their "equivalents" in C/C++
   
   <pre class=input_T></pre>
   <pre class=output>                 ⍝ meaning                C/C++

 →0              ⍝ leave the function     return;
 →(COND)⍴0       ⍝ dito if COND           if (COND) return;
 →(COND)↓0       ⍝ dito if not COND       if (!COND) return;

 →LAB            ⍝ goto line LAB          goto LAB;
 →(COND)⍴LAB     ⍝ dito if COND           if (COND)   goto LAB;
 →(COND)↓LAB     ⍝ dito if not COND       if (!COND)  goto LAB;

 →⎕LC            ⍝ repeat current line
 →(COND)⍴⎕LC     ⍝ dito if COND           do { current line } while (COND)

 →⎕LC+1          ⍝ goto next line
 →(COND)⍴⎕LC+1   ⍝ dito if COND           if (COND)     { rest-of-line }

 →⎕LC-1          ⍝ goto previous line
 →(COND)⍴⎕LC-1   ⍝ dito if COND

 →(X=V1,V2 ...)/L1, L2, ...)   ⍝          switch(X) { case V1: goto L1; ... }
   </pre>
   
   In the examples above COND is usually a Boolean expression such as A ≤ B.
   <br>
   
   <br>
   
   Since all APL comparison operators have negated forms (=/≠, ≤/&gt; &lt; etc.)
   the (COND)↓ patterns above are far less frequent then the (COND)⍴ patterns.
   Not also that the (COND)↓ only works for single line numbers (like 0 or LAB
   above) but NOT for possibly longer vectors like ⎕LC.
   <br>
   
   <br>
   
   The (COND)⍴ pattern also works for non-Boolean integer expressions (like
   if (COND) with non-integer COND in C/C++). The should not be used,
   however, if the integer COND is large because then the computation of
   ⍴ takes a long time and all but the first element of COND is discarded.
   To avoid that, use 0≠COND instead of COND if COND may be a large integer.
   
   <h5><a id="CH_3.8.3.3"></a>
   3.8.3.3 Computed Branch (outside a function)</h5>
   
   If a computed branch statement is executed outside a function (for example
   after an error in a function interrupts the execution of the function and
   returns to immediate execution mode) then the branch is executed as if it
   were executed inside the interrupted function. An error is thrown if no
   interrupted function exists.
   <br>
   
   <br>
   
   This can be used to jump back (i.e. continue) the execution of a function
   that was interrupted (typically after removing the cause of the error).
   
   <h5><a id="CH_3.8.3.4"></a>
   3.8.3.4 Escape (Unwind)</h5>
   
   
   <h2><a id="CH_4"></a>
   4 Commands</h2>
   
   Every APL interpreter provides a number of commands that can be entered in
   immediate execution mode. The ISO standard defines a small number of standard
   commands, and every interpreter adds its own commands for various purposes.
   
   Commands do not follow the syntax of the APL language, but are more similar to
   the input of a shell (a command, followed by mandatory or optional arguments).
   A command starts with the character ) (or ] for some interpreters) followed by
   a name.
   
   <h3><a id="CH_4.1"></a>
   4.1 Standard Commands</h3>
   
   <h4><a id="CH_4.1.1"></a>
   4.1.1 )CLEAR</h4>
   Syntax: <B>)CLEAR</B>
   <br>
   <br>
   
   Re-initializes the current workspace. All user-defined functions and
   variables are deleted and all system variables are reset to their default
   value. The workspace name is set to <B>CLEAR WS</B>.
   
   
   <h4><a id="CH_4.1.2"></a>
   4.1.2 )COPY</h4>
   Syntax: <B>)COPY [lib] wsname [object ...]</B>
   <br>
   <br>
   
   <B>lib</B> is an optional library reference number from 0 to 9. If <B>lib</B>
   is omitted then it is taken to be 0. The library reference number selects
   one of 10 directories (which can be configured elsewhere, see command
   <B>)LIBS</B> below) that contain workspace files.
   <br>
   <br>
   
   <B>wsname</B> then selects a workspace file in the directory selected by <B>lib</B>.
   <br>
   <br>
   
   Normally the name of the workspace file is either <B>wsname.apl</B> or else
   <B>wsname.xml</B>. However, if <B>lib</B> is omitted, then the workspace file
   need not be contained in the directory corresponding to library reference 0,
   but <B>wsname</B> may instead be an absolute path to the workspace file that
   shall be copied. This can be useful if the workspace file resides in a
   non-standard (according to <B>)LIBS</B>) directory, or if both <B>wsname.apl</B>
   and <B>wsname.xml</B> exist in the same directory.
   <br>
   <br>
   
   <ul>
   <li>If <B>object</B>(s) is omitted, then <B>all</B> user-defined variables,
       defined functions, and defined operators in the selected workspace
       are copied into the current workspace.</li>
   <li>Otherwise only those user-defined variables, defined functions, and defined
       operators whose names starts with one of the names in <B>object ...</B> are
       copied into the current workspace.</li>
   </ul>
   
   
   
   <h4><a id="CH_4.1.3"></a>
   4.1.3 )COPY_ONCE</h4>
   <br>
   <br>
   
   Like )COPY, but the workspace file is copied at most once. Subsequent
   )COPY_ONCE of the same workspace file will be ignored.
   
   <h4><a id="CH_4.1.4"></a>
   4.1.4 )DROP</h4>
   Syntax: <B>)DROP [lib] wsname</B>
   <br>
   <br>
   
   <B>lib</B> is an optional library reference number as for command <B>)COPY</B>
   above.
   <br>
   <br>
   
   <B>wsname</B> selects a workspace in the directory selected by <B>lib</B>. If
   <B>lib</B> is omitted then an absolute path to the workspace file is accepted
   as <B>wsname</B>.
   <br>
   <br>
   
   
   Delete the workspace (<B>CAUTION:</B> without any warning).
   
   
   <h4><a id="CH_4.1.5"></a>
   4.1.5 )ERASE</h4>
   Syntax: <B>)ERASE symbol ...</B>
   <br>
   <br>
   
   The variable, defined function, or defined operator with name <B>symbol</B>
   is deleted in the current workspace.
   
   
   <h4><a id="CH_4.1.6"></a>
   4.1.6 )FNS</h4>
   Syntax: <B>)FNS [from-to]</B>
   <br>
   <br>
   
   Display the names of defined functions in the current workspace.
   <br>
   <br>
   
   For workspaces with many defined functions, characters <B>from</B> and <B>to</B>
   can be used as a filter that specifies an alphabetic range of names.
   
   
   <h4><a id="CH_4.1.7"></a>
   4.1.7 )LIB</h4>
   Syntax: <B>)LIB [lib|path] [from-to]</B>
   <br>
   <br>
   
   <B>lib</B> is an optional library reference number as for command <B>)COPY</B>
   above.
   <br>
   <br>
   
   Alternatively, <B>path</B> may be the absolute path to a non-standard directory
   that contains workspace files.
   <br>
   <br>
   
   The workspaces in the selected directory are displayed.
   For directories with many workspace files, characters <B>from</B> and
   <B>to</B> can be used as a filter that specifies an alphabetic range of names.
   
   
   <h4><a id="CH_4.1.8"></a>
   4.1.8 )LOAD</h4>
   Syntax: <B>)LOAD [lib] wsname</B>
   <br>
   <br>
   
   <B>lib</B> is an optional library reference number as for command <B>)COPY</B>
   above.
   <br>
   <br>
   
   <B>wsname</B> selects a workspace in the directory selected by <B>lib</B>. If
   <B>lib</B> is omitted then an absolute path to the workspace file is accepted
   as <B>wsname</B>.
   <br>
   <br>
   
   The current workspace is discarded and the workspace stored in the
   selected workspace file is made the current workspace.
   
   
   <h4><a id="CH_4.1.9"></a>
   4.1.9 )NMS</h4>
   Syntax: <B>)NMS [from-to]</B>
   <br>
   <br>
   
   Display the names of variables, defined functions, and defined operators
   in the current workspace.
   <br>
   <br>
   
   For workspaces with many names, characters <B>from</B> and <B>to</B> can be
   used as a filter that specifies an alphabetic range of names.
   
   
   <h4><a id="CH_4.1.10"></a>
   4.1.10 )OPS</h4>
   Syntax: <B>)OPS [from-to]</B>
   <br>
   <br>
   
   Display the names of defined operators in the current workspace.
   <br>
   <br>
   
   For workspaces with many defined operators, characters <B>from</B> and <B>to</B>
   can be used as a filter that specifies an alphabetic range of names.
   
   
   <h4><a id="CH_4.1.11"></a>
   4.1.11 )SAVE</h4>
   Syntax: <B>)SAVE</B>
   <br>
   <br>
   
   Save the current workspace in the file <B>wsname.xml</B> where <B>wsname</B>
   is defined by the current workspace name (as per <B>)WSID</B>).
   
   <br>
   <br>
   
   Syntax: <B>)SAVE [lib] wsname</B>
   <br>
   <br>
   
   <B>lib</B> is an optional library reference number as for command <B>)COPY</B>
   above.
   <br>
   <br>
   
   <B>wsname</B> selects a workspace in the directory selected by <B>lib</B>. If
   <B>lib</B> is omitted then an absolute path to the workspace file is accepted
   as <B>wsname</B>.
   <br>
   <br>
   
   Save the current workspace in the file <B>wsname.xml</B> in the directory
   selected by <B>lib</B>.
   
   
   <h4><a id="CH_4.1.12"></a>
   4.1.12 )SI</h4>
   Syntax: <B>)SI</B>
   <br>
   <br>
   
   Every workspace contains a so-called <B>State Indicator</B> similar to the
   stack-trace of a C program when run in a debugger. Every time a defined
   function is called a new entry for the defined function is added, and
   the entry is deleted again when the defined function returns. Due to this
   last-in-first-out nature the <B>State Indicator</B> is also called the
   <B>)SI stack</B>.
   <br>
   <br>
   
   When the interpreter returns to immediate execution as a result of an
   error, then the command <B>)SI</B> can be used to display the (recursive)
   set of defined functions that have been called but not yet finished, and
   the line number of the current statement in each function.
   <br>
   <br>
   
   The <B>)SI</B> command itself displays only the function name and its line
   number. However there exist several variants of the <B>)SI</B> command that
   provide additional information for debugging purposes. For example:
   <br>
   <br>
   
<pre class=input_T line=602>      ⍝ clear the SI stack</pre>
<pre class=input_ line=603>      )SIC</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      ⍝ show the SI stack (which is always empty after )SIC)</pre>
<pre class=input_ line=603>      )SI</pre>
<pre class=output1>
</pre>
<pre class="input_" line=571>      ∇FOO;A;B;C
      1 + 2
      ÷0      ⍝ provoke a DOMAIN ERROR'
      ∇
</pre>
<pre class=input_ line=603>      FOO</pre>
<pre class=output1>3
</pre>
<pre class=errput1>DOMAIN ERROR
FOO[2]  ÷0
        ^
</pre>
<pre class=input_ line=603>      ⍝ show the SI stack again</pre>
<pre class=input_ line=603>      )SI</pre>
<pre class=output1>FOO[2]
⋆
</pre>
   
   <pre class=output></pre>
   
   In the output of command )SI: an immediate execution entry is displayed
   as <B>*</B> while a defined function is displayed as the function name followed
   by a line number of the function in brackets. In the example above:
   
   <ol>
   <li>The first line is the )SI entry for the execution of <B>FOO</B>. The
   execution was stopped in line 2 due to the DOMAIN ERROR, and</li>
   
   <li>The last * is the )SI entry for the immediate execution context in which
   command )SI was entered. Whenever APL detects an error, it stops execution and
   created a new )SI entry with mode immediate execution in which the user can
   then issue commands like )SI and/or change variables, and/or continue execution
   at the point where the error was detected.</li>
   </ol>
   
   
   
   <h4><a id="CH_4.1.13"></a>
   4.1.13 )SIC</h4>
   Syntax: <B>)SIC</B>
   <br>
   <br>
   
   Clear the <B>)SI stack</B> (remove all items and release its resources, in
   particular localized variables).
   
   
   <h4><a id="CH_4.1.14"></a>
   4.1.14 )SINL</h4>
   Syntax: <B>)SINL</B>
   <br>
   <br>
   
   )SI with Name List. Same as )SI, but the display of the )SI stack is augmented
   with the local variables of the function called. In the )SI example:
   <br>
   <br>
   
<pre class=input_T line=602>      )SINL</pre>
<pre class=output1>FOO[2]  A B C
⋆
</pre>
   
   <pre class=output></pre>
   
   The first line shows that function FOO was called and has localized the names
   A, B, and C. The second line is an immediate execution context (which cannot
   localize variables). )SINL is useful for determining the scope of a variable
   (e.g. which defined function has last localized it).
   
   <h4><a id="CH_4.1.15"></a>
   4.1.15 )SIS</h4>
   Syntax: <B>)SIS </B>
   <br>
   <br>
   
   )SI with Statement. Same as )SI, but the display of the )SI stack is augmented
   with the current statement in the function called (and possibly the error
   message if the statement had raised an error). In the )SI example:
<pre class=input_T line=602>      )SIS</pre>
<pre class=output1>FOO[2]  ÷0
        ^
⋆  FOO
   ^
</pre>
   
   <pre class=output></pre>
   The first line shows the APL statement <B>÷0</B> in line 2 of FOO which caused
   the DOMAIN ERROR. The second line shows the statemant <B>FOO</B> that called
   FOO. The order in the display of the )SI stack is therefore from most recent
   to least recent (or downwards from called function to calling function).
   
   
   <h4><a id="CH_4.1.16"></a>
   4.1.16 )VARS</h4>
   Syntax: <B>)VARS [from-to]</B>
   <br>
   <br>
   
   Display the names of user-defined variables in the current workspace.
   <br>
   <br>
   
   For workspaces with many user-defined variables, characters <B>from</B> and
   <B>to</B> can be used as a filter that specifies an alphabetic range of names.
   
   
   <h4><a id="CH_4.1.17"></a>
   4.1.17 )WSID</h4>
   Syntax: <B>)WSID</B>
   <br>
   <br>
   
   Display the name of the current workspace.
   <br>
   <br>
   
   Syntax: <B>)WSID wsname</B>
   <br>
   <br>
   
   Set the name of the current workspace to <B>wsname</B>. The name of the
   workspace is used, for example, when )DUMP or )SAVE is used and the
   filename is ommitted.
   
   
   <h3><a id="CH_4.2"></a>
   4.2 IBM APL2 Commands</h3>
   
   GNU APL also understands most of the IBM APL2 commands.
   
   
   <h4><a id="CH_4.2.1"></a>
   4.2.1 )CHECK</h4>
   Syntax: <B>)CHECK</B>
   <br>
   <br>
   
   Perform an internal check of the internal data structures, primarily to
   detect memory leaks.
   
   
   <h4><a id="CH_4.2.2"></a>
   4.2.2 )CONTINUE</h4>
   Syntax: <B>)CONTINUE</B>
   <br>
   <br>
   
   Save the current workspace under the name <B>CONTINUE.xml</B> and exit. If APL is
   started later on and a workspace named CONTINUE exists, then that workspaces
   is <B>)LOAD</B>ed automatically. In other words, the APL session is continued
   at the point where it was left with command <B>)CONTINUE</B>.
   
   
   <h4><a id="CH_4.2.3"></a>
   4.2.3 )HELP</h4>
   Syntax: <B>)HELP</B>
   <br>
   <br>
   
   Display a list of all GNU APL commands, system variables, and system functions.
   <br>
   <br>
   
   Syntax: <B>)HELP primitive</B>
   <br>
   <br>
   
   Display a brief help text for the APL primitive <B>primitive</B>.
   
   
   <h4><a id="CH_4.2.4"></a>
   4.2.4 )HOST</h4>
   Syntax: <B>)HOST command ...</B>
   <br>
   <br>
   
   Execute command <B>command ...</B> in the operating system under which GNU APL
   runs.
   
   
   <h4><a id="CH_4.2.5"></a>
   4.2.5 )IN</h4>
   Syntax: <B>)IN filename [object ...]</B>
   <br>
   <br>
   
   Like <B>)LOAD filename [object ...]</B>, but for a workspace saved with
   command <B>)OUT</B> (see below).
   
   <h4><a id="CH_4.2.6"></a>
   4.2.6 )MORE</h4>
   
   Syntax: <B>)MORE</B>
   <br>
   <br>
   
   APL errors like <B>DOMAIN ERROR</B>, <B>INDEX ERROR</B> etc. are displayed
   automatically if they occur. For some of these errors, the interpreter has
   additional information which is, however, not displayed automatically.
   Command <B>)MORE</B> may display this additional information. Example:
   
<pre class=input_T line=602>      1 2 3 ⎕MAP 1 2 3</pre>
<pre class=errput1>LENGTH ERROR+
      1 2 3 ⎕MAP 1 2 3
      ^     ^
</pre>
<pre class=input_ line=603>      )MORE</pre>
<pre class=output1>Odd length of A in A ⎕MAP B
</pre>
   
   <pre class=output></pre>
   A + character at the end of the APL error indicates that some additional
   information is present and can be displayed with <B>)MORE</B>.
   
   <h4><a id="CH_4.2.7"></a>
   4.2.7 )OUT</h4>
   Syntax: <B>)OUT filename [object ...]</B>
   <br>
   <br>
   
   Like <B>)SAVE</B> below, but using a different file format. The files have an
   extension of <B>.atf</B> (for APL Transfer File). Even though the <B>)SAVE</B>
   command itself is standardized (in the ISO standard), the file format that
   it produces is not. In contrast, the file format produced by <B>)OUT</B> and
   understood by <B>)IN</B> is supposed to be understood by different APL
   interpreters of different vendors, so that workspaces can, at least in
   principle, be exchanged using <B>)IN</B> and <B>)OUT</B>.
   <br>
   <br>
   
   Some vendors have extended the <B>.atf</B> file format, which undermines its
   primary purpose. GNU APL only supports the original format as described in
   the IBM <I>APL2 Language Reference Manual</I>.
   
   
   <h4><a id="CH_4.2.8"></a>
   4.2.8 )OFF</h4>
   Syntax: <B>)OFF</B>
   <br>
   <br>
   
   Exit the APL interpreter with exit code 0.
   <br>
   <br>
   
   Syntax: <B>)OFF [exit_code]</B>
   <br>
   <br>
   
   Exit the APL interpreter with the given exit code.
   
   
   <h4><a id="CH_4.2.9"></a>
   4.2.9 )PCOPY</h4>
   Syntax: <B>)PCOPY [lib] wsname [object ...]</B>
   <br>
   <br>
   
   Protective <B>)COPY</B>. Same as <B>)COPY</B> above, but not overwriting existing
   defined functions and variables.
   
   
   <h4><a id="CH_4.2.10"></a>
   4.2.10 )PIN</h4>
   Syntax: <B>)PIN filename [object ...]</B>
   <br>
   <br>
   
   Protective <B>)IN</B>. Same as <B>)IN</B> above, but not overwriting existing
   defined functions and variables.
   
   
   <h4><a id="CH_4.2.11"></a>
   4.2.11 )RESET</h4>
   Syntax: <B>)RESET</B>
   <br>
   <br>
   
   Same as <B>)CLEAR</B> above.
   
   
   <h4><a id="CH_4.2.12"></a>
   4.2.12 )SYMBOLS</h4>
   Syntax: <B>)SYMBOLS [count]</B>
   <br>
   <br>
   
   If <B>count</B> is ommitted then display the current number of user-defined
   names (i.e. for variables, labels, defined functions and defined operators).
   Otherwise, increase the size of the symbol table to at least <B>count</B>.
   
   
   <h3><a id="CH_4.3"></a>
   4.3 Additional GNU APL Commands</h3>
   
   In addition to the commands from the ISO standard and from IBM APL2, GNU APL
   provides some more commands. These commands are divided into 2 groups: normal
   commands that start with the character <B>)</B>, and debug commands that
   start with the character <B>]</B>.
   
   
   <h4><a id="CH_4.3.1"></a>
   4.3.1 )DUMP</h4>
   Syntax: <B>)DUMP [[lib] wsname]</B>
   <br>
   <br>
   
   Like <B>)SAVE</B> below, but using a different file format. The files have an
   extension of <B>.apl</B>. The file produced is an APL script which, when executed,
   reconstructs the current workspace (in terms of variables, defined functions,
   and defined operators).
   <br>
   <br>
   
   The .apl files produced by <B>)DUMP</B> are easier to read (and, if necessary,
   to modify) than the .xml files produced by <B>)SAVE</B>. On the one hand, .apl
   files are more portable than .xml files, both in respect of different versions
   of the GNU APL interpreter and in respect of interpreters from different APL
   interpreter. On the other hand, .apl files have limitations when used with
   <B>)COPY</B> in <B>libapl</B>.
   <br>
   <br>
   
   
   
   <h4><a id="CH_4.3.2"></a>
   4.3.2 )DUMP-HTML</h4>
   Syntax: <B>)DUMP-HTML [[lib] wsname]</B>
   <br>
   <br>
   
   <B>lib</B> is an optional library reference number as for command <B>)COPY</B>
   above.
   <br>
   <br>
   
   <B>wsname</B> selects a workspace in the directory selected by <B>lib</B>. If
   <B>lib</B> is omitted then an absolute path to the workspace file is accepted
   as <B>wsname</B>.
   <br>
   <br>
   
   )DUMP-HTML is similar to )DUMP, but it adds some HTML tagging so that the
   output file (with file extension .html) can be directly displayed by a web
   server. This can be useful for sharing your workspaces on the web in such
   a way that other users can cut-and-paste your code into their GNU APL session.
   
   <h4><a id="CH_4.3.3"></a>
   4.3.3 ]HIST</h4>
   Syntax: <B>)HIST</B>          ⍝ show entire history
   Syntax: <B>)HIST CLEAR</B>    ⍝ clear the history
   Syntax: <B>)HIST filter</B>   ⍝ show only history lines starting with <B>filter</B>
   <br>
   <br>
   
   ]HIST displays previously entered lines. It is sometimes difficult to remember
   the APL input that has lead to an APL error, and this command may help to
   reproduce such errors.
   
   If called with an argument, then argument CLEAR clears the history, while
   any other argument is taken as display filter. Only history lines beginning
   with the given filter are being displayed.
   
   <h4><a id="CH_4.3.4"></a>
   4.3.4 )LIBS</h4>
   Syntax: <B>)LIBS</B>
   <br>
   <br>
   
   Display the current mapping from library reference numbers to directories. For
   example:
<pre class=input_T line=602>      )LIBS</pre>
<pre class=output>Library root: /home/eedjsa/apl-1.8

Library reference number to (absolute) path mapping:

╔═══╤═════╤═════════════╤══════════════════════════════════════════════════════╗
║Ref│Conf │State (errno)│ Path to the directory containing the workspace files ║
╟───┼─────┼─────────────┼──────────────────────────────────────────────────────╢
║ 0 │PWD  │ present     │ /home/eedjsa/apl-1.8/workspaces                      ║
║ 1 │PWD  │ present     │ /home/eedjsa/apl-1.8/wslib1                          ║
║ 2 │PWD  │ present     │ /home/eedjsa/apl-1.8/wslib2                          ║
║ 3 │PSYS │ present     │ /usr/local/lib/apl/wslib3                            ║
║ 4 │PSYS │ present     │ /usr/local/lib/apl/wslib4                            ║
║ 5 │PSYS │ present     │ /usr/local/lib/apl/wslib5                            ║
║ 6 │PWD  │ present     │ /home/eedjsa/apl-1.8/wslib6                          ║
║ 7 │PWD  │ missing (2) │ /home/eedjsa/apl-1.8/wslib7                          ║
║ 8 │PWD  │ missing (2) │ /home/eedjsa/apl-1.8/wslib8                          ║
║ 9 │PWD  │ missing (2) │ /home/eedjsa/apl-1.8/wslib9                          ║
╚═══╧══╤══╧═════════════╧══════════════════════════════════════════════════════╝
       │
       ├── NONE:  found no method to compute the library path
       ├── CMD:   the path was set with )LIBS N path
       ├── ENV:   the path came from environment variable $APL_LIB_ROOT
       ├── PSYS:  the path came from the system preferences in file
       │                   /usr/local/etc/gnu-apl.d/preferences
       ├── PUSER: the path came from user preferences in file
       │                   $HOME/.config/gnu-apl or $HOME/.gnu-apl
       └── PWD:   the path is relative to current directory $PWD (last resort)
</pre>
   
   <br>
   <br>
   
   Syntax: <B>)LIBS [lib] path</B>
   <br>
   <br>
   
   <B>lib</B> is an optional library reference number as for command <B>)COPY</B>
   above.
   <br>
   <br>
   
   The directory for library reference number <B>lib</B> is set to <B>path</B>.
   
   
   <h4><a id="CH_4.3.5"></a>
   4.3.5 )QLOAD</h4>
   Syntax: <B>)QLOAD [lib] wsname</B>
   <br>
   <br>
   
   Quiet <B>)LOAD</B>. Like <B>)LOAD</B>) above, but without printing a <B>SAVED...</B>
   or <B>DUMPED ...</B> message.
   
   
   <h4><a id="CH_4.3.6"></a>
   4.3.6 )VALUES</h4>
   Syntax: <B>)VALUES</B>
   <br>
   <br>
   
   Display a (long) list of all APL values (not variables) currently known
   by the interpreter along with their status (for debug purposes).
   
   <h4><a id="CH_4.3.7"></a>
   4.3.7 ]BOXING</h4>
   Syntax: <B>]BOXING [OFF|2|3|4|7|8|9]</B>
   <br>
   <br>
   
   Changes the default style of the APL output. Example:
<pre class=input_T line=602>      V←1 (2 3) 'Hello'</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      ]BOXING OFF</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V</pre>
<pre class=output1> 1  2 3  Hello 
</pre>
<pre class=input_ line=603>      ]BOXING 4</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V</pre>
<pre class=output1>┏→━━━━━━━━━━━━━━┓
┃1 ┏→━━┓ ┏→━━━━┓┃
┃  ┃2 3┃ ┃Hello┃┃
┃  ┗━━━┛ ┗━━━━━┛┃
┗ϵ━━━━━━━━━━━━━━┛
</pre>
<pre class=input_ line=603>      ]BOXING 8</pre>
<pre class=output1>
</pre>
<pre class=input_ line=603>      V</pre>
<pre class=output1>┌→──────────────┐
│1 ┌→──┐ ┌→────┐│
│  │2 3│ │Hello││
│  └───┘ └─────┘│
└ϵ──────────────┘
</pre>
<pre class=input_ line=603>      ]BOXING OFF</pre>
<pre class=output1>
</pre>
   
   <pre class=output></pre>
   
   
   <h4><a id="CH_4.3.8"></a>
   4.3.8 ]COLOR</h4>
   Syntax: <B>]COLOR [ON|OFF]</B>
   <br>
   <br>
   
   Enables or disables the emission of Escape sequences for colors in the APL
   output. Output colouring is typically useful in truly interactive mode but
   requires terminals or terminal windows that support the Escape sequences.
   There are many situation, however, in which these Escape sequences disturb
   more than they help, e.g. copy-and-paste between terminal windows,
   post-processing of APL output.
   
   
   <h4><a id="CH_4.3.9"></a>
   4.3.9 ]DOXY</h4>
   Syntax: <B>]DOXY [path]</B>
   <br>
   <br>
   
   Produce a Doxgen-like documentation of the current workspace. If <B>path</B>
   is omitted then current directory is used as <B>path</B>. Example:
   
<pre class=input_T line=602>      ⍝ ]DOXY refuses to overwrite existing directories.</pre>
<pre class=input_ line=603>      )HOST rm -Rf /tmp/DOXY_TEST</pre>
<pre class=output1>
0 
</pre>
<pre class=input_ line=603>      )WSID DOXY_TEST</pre>
<pre class=output1>WAS CLEAR WS
</pre>
<pre class=input_ line=603>      ]DOXY /tmp</pre>
<pre class=output1>Command ]DOXY finished successfully.
    The generated documentation was stored in directory /tmp/DOXY_TEST
    You may now browse it from file:///tmp/DOXY_TEST/index.html
</pre>
   
   <pre class=output></pre>
   <h4><a id="CH_4.3.10"></a>
   4.3.10 ]EXPECT</h4>
   
   Syntax: <B>]EXPECT error_count</B>
   <br>
   <br>
   
   
   
   <h4><a id="CH_4.3.11"></a>
   4.3.11 ]KEYB</h4>
   Syntax: <B>]KEYB</B>
   <br>
   <br>
   
   Display an APL Keyboard that can, for example, be used for cut-and-paste of
   APL characters on keyboards that can not produce them. For example:
<pre class=input_T line=602>      ]KEYB</pre>
<pre class=output1>US Keyboard Layout:

╔════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦═════════╗
║ ~  ║ !⌶ ║ @⍫ ║ #⍒ ║ $⍋ ║ %⌽ ║ ^⍉ ║ &⊖ ║ *⍟ ║ (⍱ ║ )⍲ ║ _! ║ +⌹ ║         ║
║ `◊ ║ 1¨ ║ 2¯ ║ 3< ║ 4≤ ║ 5= ║ 6≥ ║ 7> ║ 8≠ ║ 9∨ ║ 0∧ ║ -× ║ =÷ ║ BACKSP  ║
╠════╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦══════╣
║       ║ Q  ║ W⍹ ║ E⍷ ║ R  ║ T⍨ ║ Y¥ ║ U  ║ I⍸ ║ O⍥ ║ P⍣ ║ {⍞ ║ }⍬ ║  |⊣  ║
║  TAB  ║ q? ║ w⍵ ║ eϵ ║ r⍴ ║ t∼ ║ y↑ ║ u↓ ║ i⍳ ║ o○ ║ p⋆ ║ [← ║ ]→ ║  \⊢  ║
╠═══════╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩══════╣
║ (CAPS   ║ A⍶ ║ S  ║ D  ║ F  ║ G  ║ H  ║ J⍤ ║ K  ║ L⌷ ║ :≡ ║ "≢ ║         ║
║  LOCK)  ║ a⍺ ║ s⌈ ║ d⌊ ║ f_ ║ g∇ ║ h∆ ║ j∘ ║ k' ║ l⎕ ║ ;⍎ ║ '⍕ ║ RETURN  ║
╠═════════╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═════════╣
║             ║ Z  ║ Xχ ║ C¢ ║ V  ║ B£ ║ N  ║ M  ║ <⍪ ║ >⍙ ║ ?⍠ ║          ║
║  SHIFT      ║ z⊂ ║ x⊃ ║ c∩ ║ v∪ ║ b⊥ ║ n⊤ ║ m| ║ ,⍝ ║ .⍀ ║ /⌿ ║  SHIFT   ║
╚═════════════╩════╩════╩════╩════╩════╩════╩════╩════╩════╩════╩══════════╝

</pre>
   
   <pre class=output></pre>
   The user may change the keyboard that is displayed with <B>]KEYB</B>, see e.g.
   <B>/usr/local/etc/gnu-apl.d/keyboard1.txt</B>.
   
   <h4><a id="CH_4.3.12"></a>
   4.3.12 ]LOG</h4>
   Syntax: <B>]LOG [facility [ON|OFF]]</B>
   <br>
   <br>
   
   
   
   <h4><a id="CH_4.3.13"></a>
   4.3.13 ]NEXTFILE</h4>
   Syntax: <B>]NEXTFILE</B>
   <br>
   <br>
   
   
   
   <h4><a id="CH_4.3.14"></a>
   4.3.14 ]OWNERS</h4>
   Syntax: <B>]OWNERS</B>
   <br>
   <br>
   
   
   
   <h4><a id="CH_4.3.15"></a>
   4.3.15 ]SVARS</h4>
   Syntax: <B>]SVARS</B>
   <br>
   <br>
   
   
   
   <h4><a id="CH_4.3.16"></a>
   4.3.16 ]SYMBOL</h4>
   Syntax: <B>]SYMBOL symbol</B>
   <br>
   <br>
   
   
   <h4><a id="CH_4.3.17"></a>
   4.3.17 ]USERCMD</h4>
   GNU APL allows the creation of new APL commands by the user. These commands are
   implemented as APL code, either as lambdas (for simple commands) or as defined
   functions (for more complex commands).
   <br>
   <br>
   
   Syntax: <B>]USERCMD</B>
   <br>
   <br>
   
   Display all currently defined user commands.
   <br>
   <br>
   
   Syntax: <B>]USERCMD )ucmd APL_fun [mode]</B>
   <br>
   <br>
   
   Syntax: <B>]USERCMD ]ucmd APL_fun [mode]</B>
   <br>
   <br>
   
   Define a new user-defined command by means of a defined function. The entire
   command is passed to the defined function as a string, therefore the function
   usually needs to drop the name of the command.
   <br>
   <br>
   
   <ul>
   <li>If the optional <B>mode</B> is 0 (which is the the default) then <B>APL_fun</B>
   shall be monadic and the command entered by the user is passed to <B>APL_fun</B>
   as an APL string (starting with the command name). <B>APL_fun</B> is responsible
   for parsing the string, typically at least dropping the name of the command.</li>
   <li>If the optional <B>mode</B> is 1 then <B>APL_fun</B> shall be dyadic. The right
   argument of <B>APL_fun</B> is the same as for mode 0, while the left argument
   is a nested vector of APL strings. This vector contains the tokenized right
   argument which somewhat simplifies the processing of the argument(s) with which
   the user-defined command was called. The first item of the vector is the
   command, the next item is the first argument (if provided), and so on.</li>
   </ul>
   
   It is possible to use the same defined function for different user-defined
   commands.
   <br>
   <br>
   
   Syntax: <B>]USERCMD )ucmd { ... }</B>
   Syntax: <B>]USERCMD ]ucmd { ... }</B>
   <br>
   <br>
   
   Define a new user defined command by means of a monadic lambda expression.
   The entire command is passed to the lambda expression as a string, therefore
   the lambda expression needs to drop e.g. the name of the command. Example:
   <br>
   <br>
   
   First define the command:
   
<pre class=input_T line=602>      ]USERCMD )sum { +/⍎4↓⍵ }</pre>
<pre class=output>    User-defined command )sum installed.
</pre>
   
   
   Then use the new command:
   
   <pre class=input_T>      )sum 1 2 3</pre>
   <pre class=output>6</pre>
   <br>
   
   Syntax: <B>]USERCMD REMOVE ]ucmd</B>
   <br>
   <br>
   
   Delete the previously defined user command <B>]ucmd</B>. Example:
<pre class=input_T line=602>      ]USERCMD REMOVE )sum</pre>
<pre class=output>    User-defined command )sum removed.
</pre>
   
   
   Syntax: <B>]USERCMD REMOVE-ALL</B>
   <br>
   <br>
   
   Delete all currently defined user commands.
<pre class=input_T line=602>      ]USERCMD REMOVE-ALL</pre>
<pre class=output>    All user-defined commands removed.
</pre>
   
   
   <h4><a id="CH_4.3.18"></a>
   4.3.18 ]XTERM</h4>
   Syntax: <B>]XTERM [ON|OFF]</B>
   <br>
   <br>
   
   GNU APL assumes, by default, that it runs interactively in an xterm compatible
   terminal or terminal emulator such as <B>xterm</B>. In some situations it needs
   to output Escape sequences, e.g. for positioning the cursor or for clearing
   lines. In some situations (see command <B>]COLOR</B>) these Escape sequences
   are not desired and their emission can be turned off with command <B>XTERM</B>
   <br>
   <br>
   
   
  </body>
</html>
