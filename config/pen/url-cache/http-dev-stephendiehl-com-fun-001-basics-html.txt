HTTP/1.1 200 OK
Server: nginx/1.1.19
Date: Wed, 06 Apr 2022 07:36:51 GMT
Content-Type: text/html
Last-Modified: Wed, 09 Mar 2016 00:24:17 GMT
Transfer-Encoding: chunked
Connection: keep-alive

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Write You a Haskell ( Stephen Diehl )</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">
    <style type="text/css">
      
    </style>
    <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="css/colors.css" rel="stylesheet">
    <link rel="alternate" type="application/atom+xml" title="Write You a Haskell" href="rss/atom.xml" />

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49839533-1', 'stephendiehl.com');
      ga('send', 'pageview');

    </script>

          <style type="text/css">
    div.sourceCode { overflow-x: auto; }
    table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
      margin: 0; padding: 0; vertical-align: baseline; border: none; }
    table.sourceCode { width: 100%; line-height: 100%; }
    td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
    td.sourceCode { padding-left: 5px; }
    code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code > span.dt { color: #902000; } /* DataType */
    code > span.dv { color: #40a070; } /* DecVal */
    code > span.bn { color: #40a070; } /* BaseN */
    code > span.fl { color: #40a070; } /* Float */
    code > span.ch { color: #4070a0; } /* Char */
    code > span.st { color: #4070a0; } /* String */
    code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code > span.ot { color: #007020; } /* Other */
    code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code > span.fu { color: #06287e; } /* Function */
    code > span.er { color: #ff0000; font-weight: bold; } /* Error */
    code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    code > span.cn { color: #880000; } /* Constant */
    code > span.sc { color: #4070a0; } /* SpecialChar */
    code > span.vs { color: #4070a0; } /* VerbatimString */
    code > span.ss { color: #bb6688; } /* SpecialString */
    code > span.im { } /* Import */
    code > span.va { color: #19177c; } /* Variable */
    code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code > span.op { color: #666666; } /* Operator */
    code > span.bu { } /* BuiltIn */
    code > span.ex { } /* Extension */
    code > span.pp { color: #bc7a00; } /* Preprocessor */
    code > span.at { color: #7d9029; } /* Attribute */
    code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      </style>
            <link rel="stylesheet" href="css/style.css" type="text/css" />
                  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
              </head>

  <body>

    <div>

        <div class="row">

          <div class="span3 side toc">
              <ul>
              <li><a href="index.html">Index</a></li>
              <li><a href="https://github.com/sdiehl/write-you-a-haskell">Github</a></li>
              <li><a href="http://dev.stephendiehl.com/fun/rss/atom.xml">RSS</a></li>
              <li><a href="WYAH.pdf">PDF</a></li>
              </ul>
              <ul>
              <li><a href="#haskell-basics">Haskell Basics</a><ul>
              <li><a href="#functions">Functions</a></li>
              <li><a href="#datatypes">Datatypes</a></li>
              <li><a href="#values">Values</a></li>
              <li><a href="#pattern-matching">Pattern matching</a></li>
              <li><a href="#recursion">Recursion</a></li>
              <li><a href="#laziness">Laziness</a></li>
              <li><a href="#higher-kinded-types">Higher-Kinded Types</a></li>
              <li><a href="#typeclasses">Typeclasses</a></li>
              <li><a href="#operators">Operators</a></li>
              <li><a href="#monads">Monads</a></li>
              <li><a href="#applicatives">Applicatives</a></li>
              <li><a href="#monoids">Monoids</a></li>
              <li><a href="#deriving">Deriving</a></li>
              <li><a href="#io">IO</a></li>
              <li><a href="#monad-transformers">Monad Transformers</a></li>
              <li><a href="#text">Text</a></li>
              <li><a href="#cabal-stack">Cabal &amp; Stack</a></li>
              <li><a href="#resources">Resources</a></li>
              </ul></li>
              </ul>
          </div>

          <div class="span9 body">
<!--<h1>Implementing a Functional Language in Haskell</h1>--!>
<div style="display:none">
<p><span class="math display">\[\newcommand{\andalso}{\quad\quad}
\newcommand{\infabbrev}[2]{\infax{#1 \quad\eqdef\quad #2}}
\newcommand{\infrule}[2]{\displaystyle \dfrac{#1}{#2}}
\newcommand{\ar}{\rightarrow}
\newcommand{\Int}{\mathtt{Int}}
\newcommand{\Bool}{\mathtt{Bool}}
\newcommand{\becomes}{\Downarrow}
\newcommand{\trule}[1]{(\textbf{#1})}
\newcommand{\FV}[1]{\mathtt{fv}(#1)}
\newcommand{\FTV}[1]{\mathtt{ftv}(#1)}
\newcommand{\BV}[1]{\mathtt{bv}(#1)}
\newcommand{\compiles}[1]{\text{C}\llbracket{#1}\rrbracket}
\newcommand{\exec}[1]{\text{E}\llbracket{#1}\rrbracket}
\renewcommand{\t}[1]{\mathtt{#1}}
\newcommand{\ite}[3]{\text{if }#1\text{ then }#2\text{ else }#3}
\]</span></p>
</div>
<div class="pagetitle">
<div class="figure">
<img src="img/titles/basics.png" alt="" />

</div>
</div>
<!--
<blockquote>
An elegant weapon for a more civilized age.
<cite>Obi-Wan Kenobi</cite>
</blockquote>
-->
<p class="halfbreak">
</p>
<h1 id="haskell-basics">Haskell Basics</h1>
<p>Let us now survey a few of the core concepts that will be used throughout the text. This will be a very fast and informal discussion. If you are familiar with all of these concepts then it is very likely you will be able to read the entirety of this tutorial and focus on the subject domain and not the supporting code. The domain material itself should largely be accessible to an ambitious high school student or undergraduate; and requires nothing more than a general knowledge of functional programming.</p>
<h2 id="functions">Functions</h2>
<p>Functions are the primary building block of all of Haskell logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
add x y <span class="fu">=</span>  x <span class="fu">+</span> y</code></pre></div>
<p>In Haskell all functions are pure. The only thing a function may do is return a value.</p>
<p>All functions in Haskell are curried. For example, when a function of three arguments receives less than three arguments, it yields a partially applied function, which, when given additional arguments, yields yet another function or the resulting value if all the arguments were supplied.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
g x y z <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">+</span> z

<span class="ot">h ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
h <span class="fu">=</span> g <span class="dv">2</span> <span class="dv">3</span></code></pre></div>
<p>Haskell supports higher-order functions, i.e., functions which take functions as arguments and yield other functions. For example the <code>compose</code> function takes two functions as arguments f and g and returns the composite function of applying f then g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">compose f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">iterate<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
iterate f x <span class="fu">=</span> x <span class="fu">:</span> (iterate f (f x))</code></pre></div>
<h2 id="datatypes">Datatypes</h2>
<p>Constructors for datatypes come in two flavors: <em>sum types</em> and <em>product types</em>.</p>
<p>A sum type consists of multiple options of <em>type constructors</em> under the same type. The two cases can be used at all locations the type is specified, and are discriminated using pattern matching.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Sum</span> <span class="fu">=</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">B</span> <span class="dt">Bool</span></code></pre></div>
<p>A product type combines multiple fields into the same type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Prod</span> <span class="fu">=</span> <span class="dt">Prod</span> <span class="dt">Int</span> <span class="dt">Bool</span></code></pre></div>
<p>Records are a special product type that, in addition to generating code for the constructors, generates a special set of functions known as <em>selectors</em> which extract the values of a specific field from the record.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Prod</span> <span class="fu">=</span> <span class="dt">Prod</span> {<span class="ot"> a ::</span> <span class="dt">Int</span> ,<span class="ot"> b ::</span> <span class="dt">Bool</span> }

<span class="co">-- a :: Prod -&gt; Int</span>
<span class="co">-- b :: Prod -&gt; Bool</span></code></pre></div>
<p>Sums and products can be combined.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T1</span>
  <span class="fu">=</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">B</span> <span class="dt">Bool</span> <span class="dt">Bool</span></code></pre></div>
<p>The fields of a datatype may be <em>parameterized</em>, in which case the type depends on the specific types the fields are instantiated with.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</code></pre></div>
<h2 id="values">Values</h2>
<p>A list is a homogeneous, inductively defined sum type of linked cells parameterized over the type of its values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
a <span class="fu">=</span> <span class="dt">Cons</span> <span class="dv">1</span> (<span class="dt">Cons</span> <span class="dv">2</span> (<span class="dt">Cons</span> <span class="dv">3</span> <span class="dt">Nil</span>))</code></pre></div>
<p>List have special value-level syntax:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">:</span>) <span class="fu">=</span> <span class="dt">Cons</span>
[]  <span class="fu">=</span> <span class="dt">Nil</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dv">1</span> <span class="fu">:</span> (<span class="dv">2</span> <span class="fu">:</span> (<span class="dv">3</span> <span class="fu">:</span> []))) <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>A tuple is a heterogeneous product type parameterized over the types of its two values.</p>
<p>Tuples also have special value-level syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="fu">=</span> <span class="dt">Pair</span> a b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">=</span> (<span class="dv">1</span>,<span class="dv">2</span>)
a <span class="fu">=</span> <span class="dt">Pair</span> <span class="dv">1</span> <span class="dv">2</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(,) <span class="fu">=</span> <span class="dt">Pair</span></code></pre></div>
<h2 id="pattern-matching">Pattern matching</h2>
<p>Pattern matching allows us to discriminate on the constructors of a datatype, mapping separate cases to separate code paths and binding variables for each of the fields of the datatype.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a

maybe<span class="ot"> ::</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b
maybe n f <span class="dt">Nothing</span>  <span class="fu">=</span> n
maybe n f (<span class="dt">Just</span> a) <span class="fu">=</span> f a</code></pre></div>
<p>Top-level pattern matches can always be written identically as case statements.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">maybe<span class="ot"> ::</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b
maybe n f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> n
  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> f a</code></pre></div>
<p>Wildcards can be placed for patterns where the resulting value is not used.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
const x _ <span class="fu">=</span> x</code></pre></div>
<p>Subexpression in the pattern can be explicitly bound to variables scoped on the right hand side of the pattern match.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
f (<span class="dt">Just</span> x <span class="fu">@</span> (<span class="dt">Just</span> _)) <span class="fu">=</span> x</code></pre></div>
<p>List and tuples have special pattern syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
length []     <span class="fu">=</span> <span class="dv">0</span>
length (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (length xs)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a
fst (a,b) <span class="fu">=</span> a</code></pre></div>
<p>Patterns may be guarded by predicates (functions which yield a boolean). Guards only allow the execution of a branch if the corresponding predicate yields True.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
filter pred []     <span class="fu">=</span> []
filter pred (x<span class="fu">:</span>xs)
  <span class="fu">|</span> pred x         <span class="fu">=</span> x <span class="fu">:</span> filter pred xs
  <span class="fu">|</span> otherwise      <span class="fu">=</span>     filter pred xs</code></pre></div>
<h2 id="recursion">Recursion</h2>
<p>In Haskell all iteration over data structures is performed by recursion. Entering a function in Haskell does not create a new stack frame, the logic of the function is simply entered with the arguments on the stack and yields result to the register. In the case where a function returns an invocation of itself invoked in the <em>tail position</em> the resulting logic is compiled identically to <code>while</code> loops in other languages, via a <code>jmp</code> instruction instead of a <code>call</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
sum ys <span class="fu">=</span> go ys <span class="dv">0</span>
  <span class="kw">where</span>
    go (x<span class="fu">:</span>xs) i <span class="fu">=</span> go xs (i<span class="fu">+</span>x)
    go [] i <span class="fu">=</span> i</code></pre></div>
<p>Functions can be defined to recurse mutually on each other.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">even <span class="dv">0</span> <span class="fu">=</span> <span class="dt">True</span>
even n <span class="fu">=</span> odd (n<span class="fu">-</span><span class="dv">1</span>)

odd <span class="dv">0</span> <span class="fu">=</span> <span class="dt">False</span>
odd n <span class="fu">=</span> even (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<h2 id="laziness">Laziness</h2>
<p>A Haskell program can be thought of as being equivalent to a large directed graph. Each edge represents the use of a value, and each node is the source of a value. A node can be:</p>
<ul>
<li>A <em>thunk</em>, i.e., the application of a function to values that have not been evaluated yet</li>
<li>A thunk that is currently being evaluated, which may induce the evaluation of other thunks in the process</li>
<li>An expression in <em>weak head normal form</em>, which is only evaluated to the outermost constructor or lambda abstraction</li>
</ul>
<p>The runtime has the task of determining which thunks are to be evaluated by the order in which they are connected to the main function node. This is the essence of all evaluation in Haskell and is called <em>graph reduction</em>.</p>
<p>Self-referential functions are allowed in Haskell. For example, the following functions generate infinite lists of values. However, they are only evaluated up to the depth that is necessary.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Infinite stream of 1&#39;s</span>
ones <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> ones

<span class="co">-- Infinite count from n</span>
numsFrom n <span class="fu">=</span> n <span class="fu">:</span> numsFrom (n<span class="fu">+</span><span class="dv">1</span>)

<span class="co">-- Infinite stream of integer squares</span>
squares <span class="fu">=</span> map (<span class="fu">^</span><span class="dv">2</span>) (numsfrom <span class="dv">0</span>)</code></pre></div>
<p>The function <code>take</code> consumes an infinite stream and only evaluates the values that are needed for the computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">take<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
take n _  <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span>  []
take n []          <span class="fu">=</span>  []
take n (x<span class="fu">:</span>xs)      <span class="fu">=</span>  x <span class="fu">:</span> take (n<span class="fu">-</span><span class="dv">1</span>) xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">take <span class="dv">5</span> squares
<span class="co">-- [0,1,4,9,16]</span></code></pre></div>
<p>This also admits diverging terms (called <em>bottoms</em>), which have no normal form. Under lazy evaluation, these values can be threaded around and will never diverge unless actually forced.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bot <span class="fu">=</span> bot</code></pre></div>
<p>So, for instance, the following expression does not diverge since the second argument is not used in the body of <code>const</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const <span class="dv">42</span> bot</code></pre></div>
<p>The two bottom terms we will use frequently are used to write the scaffolding for incomplete programs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">error<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a
undefined<span class="ot"> ::</span> a</code></pre></div>
<h2 id="higher-kinded-types">Higher-Kinded Types</h2>
<p>The &quot;type of types&quot; in Haskell is the language of kinds. Kinds are either an arrow (<code>k -&gt; k'</code>) or a star (<code>*</code>).</p>
<p>The kind of Int is <code>*</code>, while the kind of <code>Maybe</code> is <code>* -&gt; *</code>. Haskell supports higher-kinded types, which are types that take other types and construct a new type. A type constructor in Haskell always has a kind which terminates in a <code>*</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- T1 :: (* -&gt; *) -&gt; * -&gt; *</span>
<span class="kw">data</span> <span class="dt">T1</span> f a <span class="fu">=</span> <span class="dt">T1</span> (f a)</code></pre></div>
<p>The three special types <code>(,)</code>, <code>(-&gt;)</code>, <code>[]</code> have special type-level syntactic sugar:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(,) <span class="dt">Int</span> <span class="dt">Int</span>   <span class="fu">=</span>  (<span class="dt">Int</span>, <span class="dt">Int</span>)
(<span class="ot">-&gt;</span>) <span class="dt">Int</span> <span class="dt">Int</span>  <span class="fu">=</span>  <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
[] <span class="dt">Int</span>        <span class="fu">=</span>  [<span class="dt">Int</span>]</code></pre></div>
<h2 id="typeclasses">Typeclasses</h2>
<p>A typeclass is a collection of functions which conform to a given interface. An implementation of an interface is called an instance. Typeclasses are effectively syntactic sugar for records of functions and nested records (called <em>dictionaries</em>) of functions parameterized over the instance type. These dictionaries are implicitly threaded throughout the program whenever an overloaded identifier is used. When a typeclass is used over a concrete type, the implementation is simply spliced in at the call site. When a typeclass is used over a polymorphic type, an implicit dictionary parameter is added to the function so that the implementation of the necessary functionality is passed with the polymorphic value.</p>
<p>Typeclasses are &quot;open&quot; and additional instances can always be added, but the defining feature of a typeclass is that the instance search always converges to a single type to make the process of resolving overloaded identifiers globally unambiguous.</p>
<p>For instance, the Functor typeclass allows us to &quot;map&quot; a function generically over any type of kind (<code>* -&gt; *</code>) and apply it to its internal structure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  fmap f []     <span class="fu">=</span> []
  fmap f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> fmap f xs

<span class="kw">instance</span> <span class="dt">Functor</span> ((,) a) <span class="kw">where</span>
  fmap f (a,b) <span class="fu">=</span> (a, f b)</code></pre></div>
<h2 id="operators">Operators</h2>
<p>In Haskell, infix operators are simply functions, and quite often they are used in place of alphanumerical names when the functions involved combine in common ways and are subject to algebraic laws.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">+</span>
<span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">-</span>
<span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">/</span>
<span class="kw">infixl</span> <span class="dv">7</span> <span class="fu">*</span>

<span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">++</span>
<span class="kw">infixr</span> <span class="dv">9</span> <span class="fu">.</span></code></pre></div>
<p>Operators can be written in section form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(x<span class="fu">+</span>) <span class="fu">=</span>  \y <span class="ot">-&gt;</span> x<span class="fu">+</span>y
(<span class="fu">+</span>y) <span class="fu">=</span>  \x <span class="ot">-&gt;</span> x<span class="fu">+</span>y
(<span class="fu">+</span>)  <span class="fu">=</span>  \x y <span class="ot">-&gt;</span> x<span class="fu">+</span>y</code></pre></div>
<p>Any binary function can be written in infix form by surrounding the name in backticks.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">+</span><span class="dv">1</span>) <span class="ot">`fmap`</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="co">-- [2,3,4]</span></code></pre></div>
<h2 id="monads">Monads</h2>
<p>A monad is a typeclass with two functions: <code>bind</code> and <code>return</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  bind   ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>The bind function is usually written as an infix operator.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">&gt;&gt;=</span>

<span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>This defines the structure, but the monad itself also requires three laws that all monad instances must satisfy.</p>
<p><strong>Law 1</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a</code></pre></div>
<p><strong>Law 2</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class="fu">&gt;&gt;=</span> return <span class="fu">=</span> m</code></pre></div>
<p><strong>Law 3</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)</code></pre></div>
<p>Haskell has a level of syntactic sugar for monads known as do-notation. In this form, binds are written sequentially in block form which extract the variable from the binder.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> { a <span class="ot">&lt;-</span> f ; m } <span class="fu">=</span> f <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span> { m }
<span class="kw">do</span> { f ; m } <span class="fu">=</span> f <span class="fu">&gt;&gt;</span> <span class="kw">do</span> { m }
<span class="kw">do</span> { m } <span class="fu">=</span> m</code></pre></div>
<p>So, for example, the following are equivalent:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span>
  a <span class="ot">&lt;-</span> f
  b <span class="ot">&lt;-</span> g
  c <span class="ot">&lt;-</span> h
  return (a, b, c)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>
  g <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
    h <span class="fu">&gt;&gt;=</span> \c <span class="ot">-&gt;</span>
      return (a, b, c)</code></pre></div>
<h2 id="applicatives">Applicatives</h2>
<p>Applicatives allow sequencing parts of some contextual computation, but do not bind variables therein. Strictly speaking, applicatives are less expressive than monads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure  ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
(<span class="fu">&lt;$&gt;</span>) <span class="fu">=</span> fmap</code></pre></div>
<p>Applicatives satisfy the following laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure id <span class="fu">&lt;*&gt;</span> v <span class="fu">=</span> v                             <span class="co">-- Identity</span>
pure f <span class="fu">&lt;*&gt;</span> pure x <span class="fu">=</span> pure (f x)                <span class="co">-- Homomorphism</span>
u <span class="fu">&lt;*&gt;</span> pure y <span class="fu">=</span> pure (<span class="fu">$</span> y) <span class="fu">&lt;*&gt;</span> u               <span class="co">-- Interchange</span>
u <span class="fu">&lt;*&gt;</span> (v <span class="fu">&lt;*&gt;</span> w) <span class="fu">=</span> pure (<span class="fu">.</span>) <span class="fu">&lt;*&gt;</span> u <span class="fu">&lt;*&gt;</span> v <span class="fu">&lt;*&gt;</span> w  <span class="co">-- Composition</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
example1 <span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> m1 <span class="fu">&lt;*&gt;</span> m2
  <span class="kw">where</span>
    m1 <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">3</span>
    m2 <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>Instances of the <code>Applicative</code> typeclass also have available the functions <code>*&gt;</code> and <code>&lt;*</code>. These functions sequence applicative actions while discarding the value of one of the arguments. The operator <code>*&gt;</code> discards the left argument, while <code>&lt;*</code> discards the right. For example, in a monadic parser combinator library, the <code>*&gt;</code> would discard the value of the first argument but return the value of the second.</p>
<h2 id="monoids">Monoids</h2>
<p>Monoids provide an interface for structures which have an associative operation (<code>mappend</code>, there is also the synonym <code>&lt;&gt;</code>) and a neutral (also: unit or zero) element (<code>mempty</code>) for that operation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">  mempty ::</span> a
<span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  mconcat ::</span> [a] <span class="ot">-&gt;</span> a</code></pre></div>
<p>The canonical example is the list type with concatenation as the operation and the empty list as zero.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="ot">a ::</span> [<span class="dt">Integer</span>]
a <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">&lt;&gt;</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]

<span class="ot">b ::</span> [<span class="dt">Integer</span>]
b <span class="fu">=</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">&lt;&gt;</span> mempty) <span class="fu">&lt;&gt;</span> (mempty <span class="fu">&lt;&gt;</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>])</code></pre></div>
<h2 id="deriving">Deriving</h2>
<p>Instances for typeclasses like <code>Read</code>, <code>Show</code>, <code>Eq</code> and <code>Ord</code> can be derived automatically by the Haskell compiler.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PlatonicSolid</span>
  <span class="fu">=</span> <span class="dt">Tetrahedron</span>
  <span class="fu">|</span> <span class="dt">Cube</span>
  <span class="fu">|</span> <span class="dt">Octahedron</span>
  <span class="fu">|</span> <span class="dt">Dodecahedron</span>
  <span class="fu">|</span> <span class="dt">Icosahedron</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Read</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">example <span class="fu">=</span> show <span class="dt">Icosahedron</span>
example <span class="fu">=</span> read <span class="st">&quot;Tetrahedron&quot;</span>
example <span class="fu">=</span> <span class="dt">Cube</span> <span class="fu">==</span> <span class="dt">Octahedron</span>
example <span class="fu">=</span> sort [<span class="dt">Cube</span>, <span class="dt">Dodecahedron</span>]</code></pre></div>
<h2 id="io">IO</h2>
<p>A value of type <code>IO a</code> is a computation which, when performed, does some I/O before returning a value of type <code>a</code>. The notable feature of Haskell is that IO is still functionally pure; a value of type <code>IO a</code> is simply a value which stands for a computation which, when invoked, will perform IO. There is no way to peek into its contents without running it.</p>
<p>For instance, the following function does not print the numbers 1 to 5 to the screen. Instead, it builds a list of IO computations:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap print [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]<span class="ot"> ::</span> [<span class="dt">IO</span> ()]</code></pre></div>
<p>We can then manipulate them as an ordinary list of values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">reverse (fmap print [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>])<span class="ot"> ::</span> [<span class="dt">IO</span> ()]</code></pre></div>
<p>We can then build a composite computation of each of the IO actions in the list using <code>sequence_</code>, which will evaluate the actions from left to right. The resulting <code>IO</code> computation can be evaluated in <code>main</code> (or the GHCi repl, which effectively is embedded inside of <code>IO</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;</span> sequence_ (fmap print [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>])<span class="ot"> ::</span> <span class="dt">IO</span> ()
<span class="dv">1</span>
<span class="dv">2</span>
<span class="dv">3</span>
<span class="dv">4</span>
<span class="dv">5</span>

<span class="fu">&gt;&gt;</span> sequence_ (reverse (fmap print [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]))<span class="ot"> ::</span> <span class="dt">IO</span> ()
<span class="dv">5</span>
<span class="dv">4</span>
<span class="dv">3</span>
<span class="dv">2</span>
<span class="dv">1</span></code></pre></div>
<p>The IO monad is wired into the runtime with compiler support. It is a special case and most monads in Haskell have nothing to do with effects in this sense.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putStrLn<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
print<span class="ot">    ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>The type of <code>main</code> is always <code>IO ()</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Enter a number greater than 3: &quot;</span>
  x <span class="ot">&lt;-</span> readLn
  print (x <span class="fu">&gt;</span> <span class="dv">3</span>)</code></pre></div>
<p>The essence of monadic IO in Haskell is that <em>effects are reified as first class values in the language and reflected in the type system</em>. This is one of foundational ideas of Haskell, although it is not unique to Haskell.</p>
<h2 id="monad-transformers">Monad Transformers</h2>
<p>Monads can be combined together to form composite monads. Each of the composite monads consists of <em>layers</em> of different monad functionality. For example, we can combine an error-reporting monad with a state monad to encapsulate a certain set of computations that need both functionalities. The use of monad transformers, while not always necessary, is often one of the primary ways to structure modern Haskell programs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span>
<span class="ot">  lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre></div>
<p>The implementation of monad transformers is comprised of two different complementary libraries, <code>transformers</code> and <code>mtl</code>. The <code>transformers</code> library provides the monad transformer layers and <code>mtl</code> extends this functionality to allow implicit lifting between several layers.</p>
<p>To use transformers, we simply import the <em>Trans</em> variants of each of the layers we want to compose and then wrap them in a newtype.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Writer</span>

<span class="kw">newtype</span> <span class="dt">Stack</span> a <span class="fu">=</span> <span class="dt">Stack</span> {<span class="ot"> unStack ::</span> <span class="dt">StateT</span> <span class="dt">Int</span> (<span class="dt">WriterT</span> [<span class="dt">Int</span>] <span class="dt">IO</span>) a }
  <span class="kw">deriving</span> (<span class="dt">Monad</span>)

<span class="ot">foo ::</span> <span class="dt">Stack</span> ()
foo <span class="fu">=</span> <span class="dt">Stack</span> <span class="fu">$</span> <span class="kw">do</span>
  put <span class="dv">1</span>                  <span class="co">-- State layer</span>
  lift <span class="fu">$</span> tell [<span class="dv">2</span>]        <span class="co">-- Writer layer</span>
  lift <span class="fu">$</span> lift <span class="fu">$</span> print <span class="dv">3</span>  <span class="co">-- IO Layer</span>
  return ()

<span class="ot">evalStack ::</span> <span class="dt">Stack</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
evalStack m <span class="fu">=</span> execWriterT (evalStateT (unStack m) <span class="dv">0</span>)</code></pre></div>
<p>As illustrated by the following stack diagram:</p>
<div class="figure">
<img src="img/stack.png" alt="" />

</div>
<p>Using <code>mtl</code> and <code>GeneralizedNewtypeDeriving</code>, we can produce the same stack but with a simpler forward-facing interface to the transformer stack. Under the hood, <code>mtl</code> is using an extension called <code>FunctionalDependencies</code> to automatically infer which layer of a transformer stack a function belongs to and can then lift into it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="kw">import </span><span class="dt">Control.Monad.Writer</span>

<span class="kw">newtype</span> <span class="dt">Stack</span> a <span class="fu">=</span> <span class="dt">Stack</span> {<span class="ot"> unStack ::</span> <span class="dt">StateT</span> <span class="dt">Int</span> (<span class="dt">WriterT</span> [<span class="dt">Int</span>] <span class="dt">IO</span>) a }
  <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">Int</span>, <span class="dt">MonadWriter</span> [<span class="dt">Int</span>], <span class="dt">MonadIO</span>)

<span class="ot">foo ::</span> <span class="dt">Stack</span> ()
foo <span class="fu">=</span> <span class="kw">do</span>
  put <span class="dv">1</span>             <span class="co">-- State layer</span>
  tell [<span class="dv">2</span>]          <span class="co">-- Writer layer</span>
  liftIO <span class="fu">$</span> print <span class="dv">3</span>  <span class="co">-- IO Layer</span>
  return ()

<span class="ot">evalStack ::</span> <span class="dt">Stack</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
evalStack m <span class="fu">=</span> execWriterT (evalStateT (unStack m) <span class="dv">0</span>)</code></pre></div>
<p><strong>StateT</strong></p>
<p>The state monad allows functions within a stateful monadic context to access and modify shared state.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">put    ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()          <span class="co">-- set the state value</span>
<span class="ot">get    ::</span> <span class="dt">State</span> s s                <span class="co">-- get the state</span>
<span class="ot">gets   ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">State</span> s a    <span class="co">-- apply a function over the state, and return the result</span>
<span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s ()   <span class="co">-- set the state, using a modifier function</span></code></pre></div>
<p>Evaluation functions often follow the naming convention of using the prefixes <code>run</code>, <code>eval</code>, and <code>exec</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">execState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s         <span class="co">-- yield the state</span>
<span class="ot">evalState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a         <span class="co">-- yield the return value</span>
<span class="ot">runState  ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)    <span class="co">-- yield the state and return value</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State</span>

<span class="ot">test ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span>
test <span class="fu">=</span> <span class="kw">do</span>
  put <span class="dv">3</span>
  modify (<span class="fu">+</span><span class="dv">1</span>)
  get

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> execState test <span class="dv">0</span></code></pre></div>
<p><strong>ReaderT</strong></p>
<p>The Reader monad allows a fixed value to be passed around inside the monadic context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask   ::</span> <span class="dt">Reader</span> r r                            <span class="co">-- get the value</span>
<span class="ot">asks  ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a                <span class="co">-- apply a function to the value, and return the result</span>
<span class="ot">local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a  <span class="co">-- run a monadic action, with the value modified by a function</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Reader</span>

<span class="kw">data</span> <span class="dt">MyContext</span> <span class="fu">=</span> <span class="dt">MyContext</span>
  {<span class="ot"> foo ::</span> <span class="dt">String</span>
  ,<span class="ot"> bar ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">computation ::</span> <span class="dt">Reader</span> <span class="dt">MyContext</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)
computation <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> asks bar
  x <span class="ot">&lt;-</span> asks foo
  <span class="kw">if</span> n <span class="fu">&gt;</span> <span class="dv">0</span>
    <span class="kw">then</span> return (<span class="dt">Just</span> x)
    <span class="kw">else</span> return <span class="dt">Nothing</span>

<span class="ot">ex1 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
ex1 <span class="fu">=</span> runReader computation <span class="fu">$</span> <span class="dt">MyContext</span> <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>

<span class="ot">ex2 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
ex2 <span class="fu">=</span> runReader computation <span class="fu">$</span> <span class="dt">MyContext</span> <span class="st">&quot;haskell&quot;</span> <span class="dv">0</span></code></pre></div>
<p><strong>WriterT</strong></p>
<p>The writer monad lets us emit a lazy stream of values from within a monadic context. The primary function <code>tell</code> adds a value to the writer context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tell ::</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()</code></pre></div>
<p>The monad can be evaluated returning the collected writer context and optionally the returned value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">execWriter ::</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> w
<span class="ot">runWriter  ::</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> (a, w)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Writer</span>

<span class="kw">type</span> <span class="dt">MyWriter</span> <span class="fu">=</span> <span class="dt">Writer</span> [<span class="dt">Int</span>] <span class="dt">String</span>

<span class="ot">example ::</span> <span class="dt">MyWriter</span>
example <span class="fu">=</span> <span class="kw">do</span>
  tell [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]
  tell [<span class="dv">5</span><span class="fu">..</span><span class="dv">10</span>]
  return <span class="st">&quot;foo&quot;</span>

<span class="ot">output ::</span> (<span class="dt">String</span>, [<span class="dt">Int</span>])
output <span class="fu">=</span> runWriter example</code></pre></div>
<p><strong>ExceptT</strong></p>
<p>The Exception monad allows logic to fail at any point during computation with a user-defined exception. The exception type is the first parameter of the monad type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throwError ::</span> e <span class="ot">-&gt;</span> <span class="dt">Except</span> e a
<span class="ot">runExcept  ::</span> <span class="dt">Except</span> e a <span class="ot">-&gt;</span> <span class="dt">Either</span> e a</code></pre></div>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Except</span>

<span class="kw">type</span> <span class="dt">Err</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="ot">safeDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Except</span> <span class="dt">Err</span> <span class="dt">Int</span>
safeDiv a <span class="dv">0</span> <span class="fu">=</span> throwError <span class="st">&quot;Divide by zero&quot;</span>
safeDiv a b <span class="fu">=</span> return (a <span class="ot">`div`</span> b)

<span class="ot">example ::</span> <span class="dt">Either</span> <span class="dt">Err</span> <span class="dt">Int</span>
example <span class="fu">=</span> runExcept <span class="fu">$</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> safeDiv <span class="dv">2</span> <span class="dv">3</span>
  y <span class="ot">&lt;-</span> safeDiv <span class="dv">2</span> <span class="dv">0</span>
  return (x <span class="fu">+</span> y)</code></pre></div>
<p><strong>Kleisli Arrows</strong></p>
<p>The additional combinators for monads (<code>(&gt;=&gt;)</code>, <code>(&lt;=&lt;)</code>) compose two different monadic actions in sequence. <code>(&lt;=&lt;)</code> is the monadic equivalent of the regular function composition operator <code>(.)</code> and <code>(&gt;=&gt;)</code> is just <code>flip (&lt;=&lt;)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;=&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c</code></pre></div>
<p>The monad laws can be expressed equivalently in terms of Kleisli composition.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(f <span class="fu">&gt;=&gt;</span> g) <span class="fu">&gt;=&gt;</span> h   <span class="fu">=</span>   f <span class="fu">&gt;=&gt;</span> (g <span class="fu">&gt;=&gt;</span> h)
return <span class="fu">&gt;=&gt;</span> f      <span class="fu">=</span>   f
f <span class="fu">&gt;=&gt;</span> return      <span class="fu">=</span>   f</code></pre></div>
<h2 id="text">Text</h2>
<p>The usual <code>String</code> type is a singly-linked list of characters, which, although simple, is not efficient in storage or locality. The letters of the string are not stored contiguously in memory and are instead allocated across the heap.</p>
<p>The <code>Text</code> and <code>ByteString</code> libraries provide alternative efficient structures for working with contiguous blocks of text data. <code>ByteString</code> is useful when working with the ASCII character set, while <code>Text</code> provides a text type for use with Unicode.</p>
<p>The <code>OverloadedStrings</code> extension allows us to overload the string type in the frontend language to use any one of the available string representations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsString</span> a <span class="kw">where</span>
<span class="ot">  fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a

pack<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
<span class="ot">unpack ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p>So, for example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="ot">str ::</span> <span class="dt">T.Text</span>
str <span class="fu">=</span> <span class="st">&quot;bar&quot;</span></code></pre></div>
<h2 id="cabal-stack">Cabal &amp; Stack</h2>
<p>To set up an existing project with a sandbox, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> sandbox init</code></pre></div>
<p>This will create the <code>.cabal-sandbox</code> directory, which is the local path GHC will use to look for dependencies when building the project.</p>
<p>To install dependencies from Hackage, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install --only-dependencies</code></pre></div>
<p>Finally, configure the library for building:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> configure</code></pre></div>
<p>Now we can launch a GHCi shell scoped with the modules from the project in scope:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> repl</code></pre></div>
<h2 id="resources">Resources</h2>
<p>If any of these concepts are unfamiliar, there are some external resources that will try to explain them. The most thorough is the Stanford course lecture notes.</p>
<ul>
<li><a href="http://www.scs.stanford.edu/14sp-cs240h/">Stanford CS240h</a> by Bryan O'Sullivan, David Terei</li>
<li><a href="http://www.amazon.com/Real-World-Haskell-Bryan-OSullivan/dp/05965149800">Real World Haskell</a> by Bryan O'Sullivan, Don Stewart, and John Goerzen</li>
</ul>
<p>There are some books as well, but your mileage may vary with these. Much of the material is dated and only covers basic programming and not &quot;programming in the large&quot;.</p>
<ul>
<li><a href="http://www.amazon.com/Introduction-Functional-Programming-International-Computing/dp/0134841891">Introduction to Functioanl Programming</a> by Richard Bird and Philip Wadler</li>
<li><a href="http://learnyouahaskell.com/">Learn you a Haskell</a> by Miran Lipovača</li>
<li><a href="http://www.amazon.com/gp/product/0521692695">Programming in Haskell</a> by Graham Hutton</li>
<li><a href="http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell">Thinking Functionally</a> by Richard Bird</li>
</ul>
<p></p>
          </div>
        </div>

    </div>
    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="js/nav.js"></script>
  </body>
</html>
