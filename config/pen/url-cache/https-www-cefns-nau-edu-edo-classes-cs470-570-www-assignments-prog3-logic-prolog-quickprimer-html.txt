HTTP/1.1 200 OK
Date: Tue, 05 Nov 2024 19:01:46 GMT
Server: Apache/2.4.34 (Red Hat)
Strict-Transport-Security: max-age=31536000
Last-Modified: Mon, 03 Apr 2017 05:54:57 GMT
Accept-Ranges: bytes
Content-Length: 10920
Cache-Control: max-age=0, no-cache, no-store, must-revalidate
Pragma: no-cache
Expires: Wed, 11 Jan 1984 05:00:00 GMT
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive
Content-Type: text/html

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Prolog Quick Primer</title>
</head>

<body>
<p>&nbsp;</p>
<h1>Quick Prolog Primer</h1>
<p>Overview: Prolog is a very fun and useful language for exploring declarative programming. Aside from its long history of academic (research and teaching) use, it has actually been used quite extensively in real production, most notably as the basis for many high-performance parallel processing initiatives (e.g. Parlog). There are many different implementations of Prolog out there; among these, SWI-Prolog is arguably the most popular and (!!) is available for all common platforms, which makes it convenient for the purposes of a class like this. </p>
<p>The documentation available for SWI-Prolog is IMMENSE, with not only an extensive list of manuals, tutorials, and other links on the SWIPL home page (<a href="http://www.swi-prolog.org">http://www.swi-prolog.org</a>), but also many many forums online dedicated to discussion centered around swipl. As upper division students, you should be more than capable of piecing together the knowledge you need for a project by a focused exploration of these resources. Nonetheless, this page is an attempt to just get you started and give you a nudge in the right direction.  More generally, the <a href="http://www.swi-prolog.org/pldoc/man?section=quickstart">&quot;Getting started&quot; tutorial linked off the SWIPL home page</a> covers what I'm going to say here in much more detail.</p>
<h3>Installing SWIPL.</h3>
<p>The first thing you'll need to do is to get SWIPL installed on your machine. <a href="http://www.swi-prolog.org/download/stable">Go to the SWIPL download page</a> and grab whatever the latest stable version is for your platform. Depending on your platform, what exactly this process looks like might be slightly different. For Mac, they now have it packaged as a GUI application, meaning you just drag it into your &quot;Applications&quot; folder and run it, which then pops up a window with a Prolog command line. For some other platforms, you might run an installer (Mac used to be that way) and it'll install the &quot;swipl&quot; binary somewhere in your system path. Each downloadable package comes with a nice README file, so do whatever it says to get going!</p>
<p>Ok, so let's assume that you've done whatever needs doing and are now looking at a Prolog command prompt, which looks like &quot; ?- &quot;. That means it's up and waiting for you to ask it to prove something! So let's get programming...Now you can just type &quot;swipl&quot; at the command line to start up Prolog inside your terminal window. That's it. No IDE, no fancy GUI. Prolog is old school: the interpreter fires up right there in the terminal window and waits for you to do something! </p>
<h3>How to &quot;program&quot; in Prolog.</h3>
<p>Now that you've got Prolog installed and running, the edit-test development cycle is simple: fire up your favorite text editor. Yup, you read correctly: No IDE, no fancy GUI. Prolog is old school: it just gives you and interpreter; you edit code in your text editor and load it into the interpreter to run it. Ideally your text editor is one with a Prolog &quot;mode&quot;, so that it will color predicates and all that pretty stuff to help you out, but any basic text editor will do (see below for comments on what *real* programmers use). So now you write your code in the text editor, save it as a &quot;.pl&quot; file. Then you load that file (containing your facts and rules) into Prolog, and start posing queries. Repeat as necessary. Here are some detailed pointers:</p>
<ul>
  <li>You'll want to make sure that SWIPL's active directory is set to the same place that your code file exists. In Prolog, type the query &quot;pwd.&quot; to see your active directory.  Type the query &quot; cd('&lt;path to new dir&gt;') .&quot; to set it to something else, i.e., the directory where you have your code file. <strong>Note the period ('.') that appears at the end of each command. All Prolog statements/commands end in a period! </strong></li>
  <li>You can get help on Prolog through its help system. Type the query &quot;help.&quot; to get into that.</li>
  <li>Type the query &quot;halt.&quot; to exit prolog and return to your terminal shell.</li>
  <li>In most plathform versions, you can use the &quot;up/down&quot; arrows key  to scroll around in you recent command history. Can make things faster, i.e., avoid re-typing commands you recently issued and want to re-run.</li>
  <li>As you'll read in the manual, the normal way to &quot;load&quot; a program (facts plus rules) is to use the  <strong>consult('&lt;path to filename&gt;').</strong> predicate. This works super, but there's a shortcut: just type &quot; [filename]. &quot; Note that the filename here does <strong>not include</strong> the .pl extension. So if my source file in named &quot;homeworks.pl&quot;, I would type &quot; [homeworks]. &quot; to (re)load that source file into prolog.</li>
  <li>Once you're in Prolog, <strong>everything</strong> you type is a logical query. Even the commands above. <strong>Which means you should not forget that everything (including queries) in prolog must end with a &quot;.&quot;</strong>  If you leave that off, you'll be wondering why Prolog isn't doing what you want! </li>
  <li>In Prolog, words that start in lower-case are literals; words that start in uppercase are variables. Burn this into your brain! So if you type &quot;brother(John, Jim)&quot; you are not asking &quot;is Jim a brother to John?&quot;, you are asking &quot;is somebody a brother to somebody&quot;...because both  &quot;John&quot; and &quot;Jim&quot; are variables! Might as well have written &quot;brother(X,Y)&quot;! To ask about Jim and John, you'd want to write &quot;brother(john, jim).&quot;</li>
  <li>Often you'll type a query like &quot; sibling(john, X). &quot; meaning &quot;prove that John is the sibling of someone&quot;. So Prolog will try to prove it, i.e., tell you bindings of X for which this goal statement is true. Obviously there may be *many* possible bindings of X that make it true! Prolog will return the first one it finds, e.g. &quot;X=jim&quot;... and then will politely wait. If you hit &quot;return&quot; Prolog says &quot;oh nice, I guess that's all that was wanted...we're done&quot;, and returns you to the command line. But you can also hit  semi-colon (' ; '), which says to Prolog &quot;Thanks, but now try to find additional bindings that make it true&quot;. You can hit ' ; ' repeatedly, getting new bindings each time...until it can't find any further bindings, at which point it returns &quot;false&quot; and goes to command line.</li>
</ul>
<p>Ok, that should be enough to help you avoid the main &quot;gotchas&quot;. Your next move should be to do the nifty <a href="http://lpn.swi-prolog.org/lpnpage.php?pageid=online">Learn Prolog NOW Tutorial linked from the SWIPL home page.</a> Do a few more tutorials, bookmark the prolog online manual, and you should be well on your way to being a Prolog expert!</p>
<h3>How to see what Prolog is doing. </h3>
<p>We have made the claim that Prolog implements  a pretty close version of the backward-chaining FOL proof algorithm detailed in Chapter 9...which in turn  just implements the basic backward-chaining proof concept introduced for prepositional logic in Ch7.  But how do you know it's actually doing that?  More generally, how can you see what Prolog is doing....not just to understand it, but to debug your Prolog programs? In fact, there are a number of ways to make Prolog be &quot;verbose&quot; and show you what it's doing. First and foremost among these is &quot;trace.&quot;, which shows every predicate invoked as Prolog tries to prove something. Read all about Trace and other tools to look under the hood of Prolog on <a href="http://www.swi-prolog.org/pldoc/man?section=debugger">the SWIPL manual page regarding tracing and debugging.</a></p>
<h3>Comments on text editor for Prolog</h3>
<p>The big popularity of IDEs these days has made much of the discussion about text editors moot, seeing as an IDE will generally have a text editing solution built in.  But Prolog is still one of those areas of CS that's &quot;old school&quot;, i.e., there isn't enough mass usage to warrant creating a fancy special IDE (like Dr. Racket for Scheme) for Prolog.  And it's not all that vital: Prolog is super simple to run using the basic command-line interpreter plus any old text editor. It can be nice, however, to have your editor help you out a little with some code coloring (comments, predicates, etc. and other goodies).</p>
<p>What I use for most of my text editing is GNU Emacs (or Xemacs is fine too). You might have heard of emacs and even tried it out (command-line version comes built in for all unix/linux/mac systems)...and decided &quot;ewww, it's fully command-line based! Where's my fancy GUI?&quot;  Hey, no problem, I'm that way too these days! Fortunately, there are plenty of great open-source GUI wrappers that wrap standard emacs into a nice GUI interface --- that's where GNU Emacs and Xemacs help bridge the gap. What I use is Aquamacs, which works super on Mac...but there are tons of other GUI emacs editors for Windows, Linux, whatever. Because they are all *wrappers* for standard emacs, the way to get them to Prolog mode will be fairy identical. &quot;Prolog mode?&quot;, you say?  Yes, Emacs looks at the extension of the text file your are editing, decides what kind of file that is, and puts you in the right mode, i.e., with appropriate coloring and other support for that language. </p>
<p>Depending on what version/brand of emacs editor you install, you very well <em>might have prolog mode installed by default</em>. Just open a &quot;something.pl&quot; file in the editor and see if it says &quot;prolog&quot; for the mode at the bottom. If so, you're done, happy editing. Often there is no prolog mode defined in the standard distro though, and you'll need to add it. This is no problem: Emacs is written in lisp...and so anyone can extend it at will by adding more code...on the fly even! And many people over the years have perfected a sweet &quot;prolog mode&quot; file for emacs. Just go to <a href="https://bruda.ca/emacs/prolog_mode_for_emacs">https://bruda.ca/emacs/prolog_mode_for_emacs</a> , download the prolog.el file, and follow the instructions for installing it in the right place and making sure prolog knows where to find it. Simple! </p>
<p>Do yourself a favor and learn to use emacs. If nothing else, you'll be able to impress all the geeks drinking with you about how much of a &quot;true programmer&quot; you really are! </p>
</body>
</html>
