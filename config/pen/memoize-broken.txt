Debugger entered--Lisp error: (void-function \,)
  ,timeouts
  (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts)
  (list 'when 'timeout-to-use (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts))
  (list 'let (cons (list 'existing-timer (list 'gethash 'args timeouts)) '((timeout-to-use (or (and (variable-p 'timeout) timeout) memoize-default-timeout)))) '(when existing-timer (cancel-timer existing-timer)) (list 'when 'timeout-to-use (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts)))
  (list 'unwind-protect (cons 'let (cons (list (list 'ret (list 'or '(and (not (pen-var-value-maybe 'pen-sh-update)) (not (pen-var-value-maybe 'do-pen-update)) (not (>= (prefix-numeric-value current-global-prefix-arg) 4)) (not (>= (prefix-numeric-value current-prefix-arg) 4)) value) (cons 'let (cons (list (list 'newret (list 'puthash 'args (cons 'or (cons (cons 'apply (cons func '(args))) '('MEMOIZE_NIL))) table))) (cons (list 'if '(featurep 'hashtable-print-readable) (list 'ht-cache tablename table)) '(newret))))))) '((if (equal ret 'MEMOIZE_NIL) (setq ret nil)) ret))) (list 'let (cons (list 'existing-timer (list 'gethash 'args timeouts)) '((timeout-to-use (or (and (variable-p 'timeout) timeout) memoize-default-timeout)))) '(when existing-timer (cancel-timer existing-timer)) (list 'when 'timeout-to-use (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts))))
  (list 'let (list (list 'value (list 'gethash 'args table))) (list 'unwind-protect (cons 'let (cons (list (list 'ret (list 'or '(and (not (pen-var-value-maybe 'pen-sh-update)) (not (pen-var-value-maybe 'do-pen-update)) (not (>= (prefix-numeric-value current-global-prefix-arg) 4)) (not (>= (prefix-numeric-value current-prefix-arg) 4)) value) (cons 'let (cons (list (list 'newret (list 'puthash 'args (cons 'or (cons (cons 'apply (cons func '(args))) '('MEMOIZE_NIL))) table))) (cons (list 'if '(featurep 'hashtable-print-readable) (list 'ht-cache tablename table)) '(newret))))))) '((if (equal ret 'MEMOIZE_NIL) (setq ret nil)) ret))) (list 'let (cons (list 'existing-timer (list 'gethash 'args timeouts)) '((timeout-to-use (or (and (variable-p 'timeout) timeout) memoize-default-timeout)))) '(when existing-timer (cancel-timer existing-timer)) (list 'when 'timeout-to-use (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts)))))
  (list 'lambda '(&rest args) (list 'let (list (list 'value (list 'gethash 'args table))) (list 'unwind-protect (cons 'let (cons (list (list 'ret (list 'or '(and (not (pen-var-value-maybe 'pen-sh-update)) (not (pen-var-value-maybe 'do-pen-update)) (not (>= (prefix-numeric-value current-global-prefix-arg) 4)) (not (>= (prefix-numeric-value current-prefix-arg) 4)) value) (cons 'let (cons (list (list 'newret (list 'puthash 'args (cons 'or (cons (cons 'apply (cons func '(args))) '('MEMOIZE_NIL))) table))) (cons (list 'if '(featurep 'hashtable-print-readable) (list 'ht-cache tablename table)) '(newret))))))) '((if (equal ret 'MEMOIZE_NIL) (setq ret nil)) ret))) (list 'let (cons (list 'existing-timer (list 'gethash 'args timeouts)) '((timeout-to-use (or (and (variable-p 'timeout) timeout) memoize-default-timeout)))) '(when existing-timer (cancel-timer existing-timer)) (list 'when 'timeout-to-use (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts))))))
  (eval (list 'lambda '(&rest args) (list 'let (list (list 'value (list 'gethash 'args table))) (list 'unwind-protect (cons 'let (cons (list (list 'ret (list 'or '(and (not (pen-var-value-maybe 'pen-sh-update)) (not (pen-var-value-maybe 'do-pen-update)) (not (>= (prefix-numeric-value current-global-prefix-arg) 4)) (not (>= (prefix-numeric-value current-prefix-arg) 4)) value) (cons 'let (cons (list (list 'newret (list 'puthash 'args (cons 'or (cons (cons 'apply (cons func '(args))) '('MEMOIZE_NIL))) table))) (cons (list 'if '(featurep 'hashtable-print-readable) (list 'ht-cache tablename table)) '(newret))))))) '((if (equal ret 'MEMOIZE_NIL) (setq ret nil)) ret))) (list 'let (cons (list 'existing-timer (list 'gethash 'args timeouts)) '((timeout-to-use (or (and (variable-p 'timeout) timeout) memoize-default-timeout)))) '(when existing-timer (cancel-timer existing-timer)) (list 'when 'timeout-to-use (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts)))))))
  (let* ((funcpps (pps func)) (funcslugdata (if (< 150 (length funcpps)) (md5 funcpps) funcpps)) (funcslug (slugify (s-join "-" (pen-str2list funcslugdata)))) (tablename (concat "table-" funcslug)) (timeoutsname (concat "timeouts-" funcslug)) (table (make-or-load-hash-table tablename '(:test equal))) (timeouts (make-or-load-hash-table timeoutsname '(:test equal)))) (eval (list 'lambda '(&rest args) (list 'let (list (list 'value (list 'gethash 'args table))) (list 'unwind-protect (cons 'let (cons (list (list 'ret (list 'or '(and (not (pen-var-value-maybe 'pen-sh-update)) (not (pen-var-value-maybe 'do-pen-update)) (not (>= (prefix-numeric-value current-global-prefix-arg) 4)) (not (>= (prefix-numeric-value current-prefix-arg) 4)) value) (cons 'let (cons (list (list 'newret (list 'puthash 'args (cons 'or (cons (cons 'apply (cons func '(args))) '('MEMOIZE_NIL))) table))) (cons (list 'if '(featurep 'hashtable-print-readable) (list 'ht-cache tablename table)) '(newret))))))) '((if (equal ret 'MEMOIZE_NIL) (setq ret nil)) ret))) (list 'let (cons (list 'existing-timer (list 'gethash 'args timeouts)) '((timeout-to-use (or (and (variable-p 'timeout) timeout) memoize-default-timeout)))) '(when existing-timer (cancel-timer existing-timer)) (list 'when 'timeout-to-use (list 'puthash 'args (list 'run-at-time 'timeout-to-use nil (list 'eval (cons '\` (list (list 'lambda nil (list 'remhash ',args (cons '\, (list table)))))))) ,timeouts))))))))
  memoize--wrap((lambda (cmd resultnumber) "This is like pen-snc but it will memoize the function. resultnumber is necessary because we want n unique results per function" (setq cmd (concat pen-snc-ignored-envs " " cmd)) (if (f-directory-p penconfdir) (tee (f-join penconfdir "last-final-command.txt") cmd)) (pen-snc (concat pen-snc-ignored-envs " " cmd))) nil)
  (fset func (memoize--wrap (symbol-function func) timeout))
  (cond ((symbolp func) (if (get func :memoize-original-function) (progn (user-error "%s is already memoized" func))) (put func :memoize-original-documentation (documentation func)) (put func 'function-documentation (concat (documentation func) " (memoized)")) (put func :memoize-original-function (symbol-function func)) (fset func (memoize--wrap (symbol-function func) timeout)) func) ((functionp func) (memoize--wrap func timeout)))
  memoize(pen-prompt-snc)
  eval((memoize 'pen-prompt-snc) t)
  #f(compiled-function (exp &optional insert-value no-truncate char-print-limit) "Evaluate EXP and print value in the echo area.\nWhen called interactively, read an Emacs Lisp expression and\nevaluate it.  Value is also consed on to front of the variable\n`values'.  Optional argument INSERT-VALUE non-nil (interactively,\nwith a non `-' prefix argument) means insert the result into the\ncurrent buffer instead of printing it in the echo area.\n\nNormally, this function truncates long output according to the\nvalue of the variables `eval-expression-print-length' and\n`eval-expression-print-level'.  When NO-TRUNCATE is\nnon-nil (interactively, with a prefix argument of zero), however,\nthere is no such truncation.\n\nIf the resulting value is an integer, and CHAR-PRINT-LIMIT is\nnon-nil (interactively, unless given a non-zero prefix argument)\nit will be printed in several additional formats (octal,\nhexadecimal, and character).  The character format is used only\nif the value is below CHAR-PRINT-LIMIT (interactively, if the\nprefix argument is -1 or the value doesn't exceed\n`eval-expression-print-maximum-character').\n\nRuns the hook `eval-expression-minibuffer-setup-hook' on entering the\nminibuffer.\n\nIf `eval-expression-debug-on-error' is non-nil, which is the default,\nthis command arranges for all errors to enter the debugger." (interactive #f(compiled-function () #<bytecode -0x498efd89bea7931>)) #<bytecode 0x7d9ca56421cced0>)((memoize 'pen-prompt-snc) nil nil 127)
  apply(#f(compiled-function (exp &optional insert-value no-truncate char-print-limit) "Evaluate EXP and print value in the echo area.\nWhen called interactively, read an Emacs Lisp expression and\nevaluate it.  Value is also consed on to front of the variable\n`values'.  Optional argument INSERT-VALUE non-nil (interactively,\nwith a non `-' prefix argument) means insert the result into the\ncurrent buffer instead of printing it in the echo area.\n\nNormally, this function truncates long output according to the\nvalue of the variables `eval-expression-print-length' and\n`eval-expression-print-level'.  When NO-TRUNCATE is\nnon-nil (interactively, with a prefix argument of zero), however,\nthere is no such truncation.\n\nIf the resulting value is an integer, and CHAR-PRINT-LIMIT is\nnon-nil (interactively, unless given a non-zero prefix argument)\nit will be printed in several additional formats (octal,\nhexadecimal, and character).  The character format is used only\nif the value is below CHAR-PRINT-LIMIT (interactively, if the\nprefix argument is -1 or the value doesn't exceed\n`eval-expression-print-maximum-character').\n\nRuns the hook `eval-expression-minibuffer-setup-hook' on entering the\nminibuffer.\n\nIf `eval-expression-debug-on-error' is non-nil, which is the default,\nthis command arranges for all errors to enter the debugger." (interactive #f(compiled-function () #<bytecode -0x498efd89bea7931>)) #<bytecode 0x7d9ca56421cced0>) ((memoize 'pen-prompt-snc) nil nil 127))
  eval-expression((memoize 'pen-prompt-snc) nil nil 127)
  funcall-interactively(eval-expression (memoize 'pen-prompt-snc) nil nil 127)
  #<subr call-interactively>(eval-expression nil nil)
  apply(#<subr call-interactively> eval-expression (nil nil))
  (let ((ido-cr+-current-command command)) (apply orig-fun command args))
  call-interactively@ido-cr+-record-current-command(#<subr call-interactively> eval-expression nil nil)
  apply(call-interactively@ido-cr+-record-current-command #<subr call-interactively> (eval-expression nil nil))
  call-interactively(eval-expression nil nil)
  (prog1 (call-interactively cmd record-flag keys) (if (and (symbolp cmd) (get cmd 'byte-obsolete-info) (not (get cmd 'command-execute-obsolete-warned))) (progn (put cmd 'command-execute-obsolete-warned t) (message "%s" (macroexp--obsolete-warning cmd (get cmd 'byte-obsolete-info) "command")))))
  (cond ((arrayp final) (if record-flag (progn (add-to-history 'command-history (list 'execute-kbd-macro final prefixarg) nil t))) (execute-kbd-macro final prefixarg)) (t (prog1 (call-interactively cmd record-flag keys) (if (and (symbolp cmd) (get cmd 'byte-obsolete-info) (not (get cmd 'command-execute-obsolete-warned))) (progn (put cmd 'command-execute-obsolete-warned t) (message "%s" (macroexp--obsolete-warning cmd (get cmd ...) "command")))))))
  (let ((final cmd)) (while (progn (setq final (indirect-function final)) (if (autoloadp final) (setq final (autoload-do-load final cmd))))) (cond ((arrayp final) (if record-flag (progn (add-to-history 'command-history (list 'execute-kbd-macro final prefixarg) nil t))) (execute-kbd-macro final prefixarg)) (t (prog1 (call-interactively cmd record-flag keys) (if (and (symbolp cmd) (get cmd 'byte-obsolete-info) (not (get cmd ...))) (progn (put cmd 'command-execute-obsolete-warned t) (message "%s" (macroexp--obsolete-warning cmd ... "command"))))))))
  (if (and (symbolp cmd) (get cmd 'disabled) disabled-command-function) (run-hooks 'disabled-command-function) (let ((final cmd)) (while (progn (setq final (indirect-function final)) (if (autoloadp final) (setq final (autoload-do-load final cmd))))) (cond ((arrayp final) (if record-flag (progn (add-to-history 'command-history (list ... final prefixarg) nil t))) (execute-kbd-macro final prefixarg)) (t (prog1 (call-interactively cmd record-flag keys) (if (and (symbolp cmd) (get cmd ...) (not ...)) (progn (put cmd ... t) (message "%s" ...))))))))
  (let ((prefixarg (if special nil (prog1 prefix-arg (setq current-prefix-arg prefix-arg) (setq prefix-arg nil) (if current-prefix-arg (progn (prefix-command-update)))))) (globalprefixarg (if special nil (prog1 global-prefix-arg (setq current-global-prefix-arg global-prefix-arg) (setq global-prefix-arg nil) (if current-global-prefix-arg (progn (global-prefix-command-update))))))) (if (and (symbolp cmd) (get cmd 'disabled) disabled-command-function) (run-hooks 'disabled-command-function) (let ((final cmd)) (while (progn (setq final (indirect-function final)) (if (autoloadp final) (setq final (autoload-do-load final cmd))))) (cond ((arrayp final) (if record-flag (progn (add-to-history ... ... nil t))) (execute-kbd-macro final prefixarg)) (t (prog1 (call-interactively cmd record-flag keys) (if (and ... ... ...) (progn ... ...))))))))
  command-execute(eval-expression)
