(require 'cl-lib)
(require 'eieio)
(require 'eieio-base)
(require 'eieio-opt)

(require 'pen-hypertext)


;; Remember
;; Every slot that appears in each parent class is replicated in the new class.


;; Vision:
;; - This is meant to be an imagination, exploration game.
;;   - It's not meant to be difficult.
;;   - It should not require much tedium.
;;   - But it should have many areas to stretch the imagination.
;;   - It should just have a lot of switches.
;;     - And they don't need to be discovered.
;;       - Pretty much everything should be visible.
;; - It's like a super elaborate Magic School Bus exploration game.
;; - Just go from area to area and see what others have created.


;; Editing:
;; - Make it so I can build the game as I am exploring it.
;;   - This will be the most efficient way to construct the world.
;;   - New [org-link]s should create the new areas.
;; - I may as well use eieio, then, and persistent storage
;;   - Also, I get a pretty printer, Custom etc. and other features


;; Example scene:
;; - The outside of a house with 3 people around a barrel fire
;; - Some clickable options for things to do:
;;   - Enter the house
;;   - Sit down with them around the barrel


;; Example scene (barrel):
;; - Some clickable options for things to do:
;;   - Listen to them sing
;;   - Leave (and return to the outside of the house)


;; Example scene (inside the house):
;; - Clickable options:
;;   - Talk to the dormouse
;;     - This leads to another scene, etc.
;;       - Going into the mouse tunnels.
;;   - Yell out really loudly, "I love apples!"
;;     - This leads to another scene, etc.


;; I guess the genius of this game is that it could lead anywhere.

;; Then, maybe you can time yourself doing a race from A-B.

;; The above alone should be quite fun.
;; I would not even need an inventory, etc.
;; Therefore, I should start with that.


;; Design decisions:
;; - Keep it simple.
;; - Show everything there is to see on the viewport in a simple animation.
;;   - Typically, 1,2 or 3 frames
;; - List the things you can take or look at.
;;   - Prioritise an 'Escape from Monkey Island' interface
;;     - vs a text adventure interface (like magnetic scrolls)
;;     - Advance to using emacs transients, etc.
;;   - Click on options, item names, commands, etc.
;; - Inspect things closely.


;; Later:
;; - Inventory.
;;   - Make it so I can look at objects up close - this should be hypertext, too.


;; TODO Find out if I can save eieio objects
;; [[info:(eieio) eieio-persistent]]


;; Example of using ebdb
;; j:ebdb-record


;; The 'place' has an animated, clickable

;; e:$EMACSD/pen.el/src/pen-hypertext.el


;; TODO Eventually build a map.
;; But it might be better if I leave it for the user to try to remember the way.
(defun aa/map ()
  "This should display the map.

A map should mainly simply connect places together.
"
  (interactive)
  (message "%s" "Go to the map"))


;; It would be cool if the game state is stored in a git repository and synchronized over the internet.
;; So many people can play together. But nah.


;; An inventory object should have a decal
;; Exploring the world, you may find objects that increase your stats


;; This could be a jump-gate like in Ray's Maze.
;; Or it could be a 'sign' or it could be an immovable object.
;; Or it could be 'writing' on the wall or something.
(comment
 (defclass aa/static-object ()           ; No superclasses
   ((name :initarg :name
          ;; This gives the default name. It is empty.
          :initform ""
          :type string
          :custom string
          :documentation "A part of the landscape.")
    (weight :initarg :timer
            :initform 1
            :custom integer
            :type integer
            :documentation ".")
    (visible :initarg :timer
             :initform t
             :custom boolean
             :type boolean
             :documentation "."))
   "A class for describing an area."))


(comment
 (defset entrance
         (make-instance 'aa/area :name "House" :timer 1)))


;; Some objects may be generated by the program code,
;; like manna, for example.
;; Or, perhaps,
(comment
 (defclass aa/inventory-object ()        ; No superclasses
   ((name :initarg :name
          ;; This gives the default name. It is empty.
          :initform ""
          :type string
          :custom string
          :documentation "An object.")
    (weight :initarg :timer
            :initform 1
            :custom integer
            :type integer
            :documentation "."))
   "A class for describing an area."))


;; Can be drawn on the viewport.
;; Yeah, call it a 'place'.
;; [[info:(eieio) Slot Options]]
(defclass aa/area ()                    ; No superclasses
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "A place/area.")
   
   (name :initarg :name
         :initform ""
         :type string
         :custom string
         :documentation "A description of the area.")

   (animation-speed :initarg :timer
                    :initform 1
                    :custom integer
                    :type integer
                    :documentation "The animation speed.")

   ;; (static-objects :initarg :timer
   ;;                 :initform 1
   ;;                 :type (list-of aa/static-object)
   ;;                 :documentation "An immovable object.")

   ;; Items you can take
   ;; (inventory-objects :initarg :timer
   ;;                    :initform 1
   ;;                    :type (list-of aa/inventory-object)
   ;;                    :documentation "Objects which may be picked up.")

   ;; Yes, load these frames from the file
   (frames :initarg :frames
           :initform '()
           :type (list-of string)
           :documentation "Hypertext frames."))
  "A class for describing an area.")


;; The game world can be saved because it inherits from eieio-persistent
(defclass aa/world (eieio-persistent)
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "A game world.")

   (areas :initarg :areas
          :initform 1
          :type (list-of aa/area)
          :documentation "The areas in the world.")

   (entrance :initarg :entrance
             :initform 1
             :type (or null aa/area)
             :documentation "The entry/exit area to the world."))
  "A class for describing the game world.")


;; To create a new area
(cl-defgeneric aa/read (class &optional slots obj)
  "Prompt the user for values to create an instance of CLASS.
SLOTS are a plist of slot values; OBJ is an optional existing
object of type CLASS, from which to draw default values during
prompting.")


;; TODO Open the house.org file in j:hypertext-mode
;; Hypertext mode will be renamed as ascii-adventures-mode
;; because it will be the major mode for playing the game.
;; j:open-hypertext
;; j:load-place-from-file

;; OK, so how do I store game state?
;; I should probably use an emacs buffer for the game state
;; That way, I can open the buffer to tweak variable as the game is running'

;; I guess that I will use objects to store game state.
;; However, it may be better to use org files to store the state.

;; Here, area is a variable
;; Make methods as I need them
(comment
 (cl-defmethod aa/goto-place ((area place) &optional scriptname)
   ""
   (message "Going to %s"  (slot-value area 'name))

   (slot-value pers 'animation-speed)))


;; I won't typically need to have many areas remain open in memory,
;; because I will be only at a single place at a time.
;; But, actually, I *do* want persistent world state.
;; How will I do that?

(defset entrance
        (aa/area :name "House" :timer 1))


;; j:ebdb-save
;; j:ebdb-save-on-emacs-exit
;; There's a bunch of these initialize-instance methods.
;; That's because it's a defgeneric
;; j:initialize-instance
;; v +/"^(cl-defmethod initialize-instance ((field ebdb-field-labeled)" "$HOME/repos/ebdb/ebdb.el"

(cl-defmethod initialize-instance ((db aa/world) &optional slots)
  "Make sure DB has a uuid.
Also switch old :object-name slot name to :label."
  (let ((obj-name (plist-get slots :object-name))
        p)
    (unless (and (slot-boundp db 'uuid)
                 (slot-value db 'uuid))
      (setf (slot-value db 'uuid)
            (make-instance 'aa/field-uuid
                           :uuid (aa/make-uuid
                                  (slot-value db 'uuid-prefix)))))
    (while slots
      (when (not (eq :object-name (car slots)))
        (setq p (plist-put p (car slots) (nth 1 slots))))
      (setq slots (cddr slots)))
    (when obj-name
      (setq p (plist-put p :label obj-name)))
    (cl-call-next-method db p)))


(defun aa/reload-database (db)
  "Reload all records from database DB."
  (interactive (list (aa/prompt-for-db nil t)))
  (let ((db-str (aa/string db))
        (rec-uuids (mapcar #'aa/record-uuid (slot-value db 'records))))
    ;; I don't actually know if keeping pointers to DB's records would
    ;; interfere with the reloading of the database.  I suspect it
    ;; wouldn't, but safer to use the uuids.
    (message "Reloading %s..." db-str)
    (aa/redisplay-records rec-uuids 'unload)
    (aa/db-reload db)
    (aa/redisplay-records rec-uuids 'reformat)
    (message "Reloading %s... done" db-str)))


;; The world is inside of
;; I should actually load/initialize this the way ebdb does.
(defset world (aa/world :name "Imagiverse" :entrance))

;; Do I really want to maintain a separate state?
;; It *would* be useful for automating the game, of course:
;; - searching for things.
;; If it was filesystem-based-state then it would work nicely across hyperdrive, for example.
(comment
 (defset entrance
         (make-instance 'aa/area :name "House" :timer 1))
 ;; Rename the area
 (set-slot-value entrance 'name "Big house")

 (aa/area-p entrance)
 
 (slot-value entrance 'name)
 (oref entrance name)
 (oref-default entrance name)

 ;; Rename the house yet again
 (oset entrance name "Giant house")

 ;; Change the default name for new objects of type  aa/area
 (oset-default aa/area name "Unnamed place")

 (object-add-to-list entrance 'objects item &optional append))


;; OK, so I need to think about how I load this
(defun load-place-from-file (path)
  (setq path (umn path))

  ;; I guess this is parsing it twice
  (let ((parse (org-parser-parse-file filename))
        (b (open-hypertext-in-buffer path)))))


(comment
 (load-place-from-file "$HOME/notes/ws/ascii-adventures/house.org")

 (open-hypertext))

(provide 'pen-ascii-adventures)
