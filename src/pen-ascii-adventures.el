(require 'pen-hypertext)


;; Remember
;; Every slot that appears in each parent class is replicated in the new class.


;; Vision:
;; - This is meant to be an imagination, exploration game.
;;   - It's not meant to be difficult.
;;   - It should not require much tedium.
;;   - But it should have many areas to stretch the imagination.
;;   - It should just have a lot of switches.
;;     - And they don't need to be discovered.
;;       - Pretty much everything should be visible.
;; - It's like a super elaborate Magic School Bus exploration game.
;; - Just go from area to area.


;; Design decisions:
;; - Keep it simple
;; - Show everything on the map
;; - List the things you can take or look at
;;   - Prioritise an 'Escape from Monkey Island' interface
;;     - vs a text adventure interface (like magnetic scrolls)
;;     - Advance to using emacs transients, etc.
;;   - Click on options, item names, commands, etc.
;; - Inspect things closely


;; TODO Make it so:
;; - I can look at objects up close - this should be hypertext


;; TODO Find out if I can save eieio objects
;; [[info:(eieio) eieio-persistent]]


;; Example of using ebdb
;; j:ebdb-record


;; The 'place' has an animated, clickable

;; e:$EMACSD/pen.el/src/pen-hypertext.el


(defun aa/map ()
  "This should display the map.

A map should mainly simply connect places together.
"
  (interactive)
  (message "%s" "Go to the map"))


;; It would be cool if the game state is stored in a git repository and synchronized over the internet.
;; So many people can play together. But nah.


;; An inventory object should have a decal
;; Exploring the world, you may find objects that increase your stats


;; This could be a jump-gate like in Ray's Maze.
;; Or it could be a 'sign' or it could be an immovable object.
;; Or it could be 'writing' on the wall or something.
(defclass aa/static-object ()           ; No superclasses
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "A part of the landscape.")
   (weight :initarg :timer
           :initform 1
           :custom integer
           :type integer
           :documentation ".")
   (visible :initarg :timer
            :initform t
            :custom boolean
            :type boolean
            :documentation "."))
  "A class for describing an area.")


(comment
 (defset entrance
         (make-instance 'aa/area :name "House" :timer 1)))


;; Some objects may be generated by the program code,
;; like manna, for example.
;; Or, perhaps, 
(defclass aa/inventory-object ()        ; No superclasses
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "An object.")
   (weight :initarg :timer
           :initform 1
           :custom integer
           :type integer
           :documentation "."))
  "A class for describing an area.")


;; Can be drawn on the viewport.
;; Yeah, call it a 'place'.
;; [[info:(eieio) Slot Options]]
(defclass aa/area ()                    ; No superclasses
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "A place/area.")

   (animation-speed :initarg :timer
                    :initform 1
                    :custom integer
                    :type integer
                    :documentation "The animation speed.")

   (static-objects :initarg :timer
                   :initform 1
                   :type (list-of aa/static-object)
                   :documentation "An immovable object.")

   ;; Items you can take
   (inventory-objects :initarg :timer
                      :initform 1
                      :type (list-of aa/inventory-object)
                      :documentation "Objects which may be picked up.")
   ;; (frames :initarg :phone
   ;;         :initform ""
   ;;         :documentation "Phone number.")
   )
  "A class for describing an area.")


;; The game world can be saved because it inherits from eieio-persistent
(defclass aa/world (eieio-persistent)
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "A game world.")
   (areas :initarg :timer
          :initform 1
          :type (list-of aa/area)
          :documentation "The animation speed.")

   (entrance :initarg :timer
             :initform 1
             :type (or null aa/place)
             :documentation "The entry place to the world.")
   (exit :initarg :timer
         :initform 1
         :type (or null aa/inventory-object)
         :documentation "The animation speed."))
  "A class for describing the game world.")


;; TODO Open the house.org file in j:hypertext-mode
;; Hypertext mode will be renamed as ascii-adventures-mode
;; because it will be the major mode for playing the game.
;; j:open-hypertext
;; j:load-place-from-file

;; OK, so how do I store game state?
;; I should probably use an emacs buffer for the game state
;; That way, I can open the buffer to tweak variable as the game is running'

;; I guess that I will use objects to store game state.
;; However, it may be better to use org files to store the state.

;; Here, area is a variable
;; Make methods as I need them
(comment
 (cl-defmethod aa/goto-place ((area place) &optional scriptname)
   ""
   (message "Going to %s"  (slot-value area 'name))

   (slot-value pers 'animation-speed)))

;; I won't typically need to have many areas remain open in memory,
;; because I will be only at a single place at a time.
;; But, actually, I *do* want persistent world state.
;; How will I do that?

(defset entrance
        (aa/area :name "House" :timer 1))

;; Do I really want to maintain a separate state?
;; It *would* be useful for automating the game, of course:
;; - searching for things.
;; If it was filesystem-based-state then it would work nicely across hyperdrive, for example.
(comment
 (defset entrance
         (make-instance 'aa/area :name "House" :timer 1))
 ;; Rename the area
 (set-slot-value entrance 'name "Big house")

 (aa/area-p entrance)
 
 (slot-value entrance 'name)
 (oref entrance name)
 (oref-default entrance name)

 ;; Rename the house yet again
 (oset entrance name "Giant house")

 ;; Change the default name for new objects of type  aa/area
 (oset-default aa/area name "Unnamed place")

 (object-add-to-list entrance 'objects item &optional append))

;; OK, so I need to think about how I load this
(defun load-place-from-file (path)
  (setq path (umn path))

  ;; I guess this is parsing it twice
  (let ((parse (org-parser-parse-file filename))
        (b (open-hypertext-in-buffer path)))))

(comment
 (load-place-from-file "$HOME/notes/ws/ascii-adventures/house.org")

 (open-hypertext))

(provide 'pen-ascii-adventures)
