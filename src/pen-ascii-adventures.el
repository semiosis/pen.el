(require 'cl-lib)
(require 'eieio)
(require 'eieio-base)
(require 'eieio-opt)
(require 'org-sync)
(require 'org-sync-snippets)
(require 'universal-sidecar)

(require 'animate)

;; [[sh:sps braille-show-image $PEN/documents/rays-maze-techtrons.png]]

;; e:$PEN/documents/ascii-adventures/todo.org

(defsetdir aa/mapdir (umn "/volumes/home/shane/var/smulliga/source/git/ascii-adventures/"))
(defsetdir aa/bewilderness-dir (umn "/volumes/home/shane/var/smulliga/source/git/ascii-adventures/bewilderness/"))

;; org-parser is not actually that good compared to org-element-parse-buffer which is part of org
;; (require 'org-parser)

(require 'pen-hypertext)

;; e:$EMACSD/pen.el/src/pen-ascii-adventures.el
;; e:/volumes/home/shane/var/smulliga/source/git/ascii-adventures/bewilderness/house.org

;; The 'place' has an animated, clickable

;; e:$EMACSD/pen.el/src/pen-hypertext.el

;; TODO Eventually build a map.
;; But it might be better if I leave it for the user to try to remember the way.
(defun aa/map ()
  "This should display the map.

A map should mainly simply connect places together.
"
  (interactive)
  (message "%s" "Go to the map")
  (ascii-adventures-open-map (f-join aa/bewilderness-dir "map.org")))

(defun aa/house ()
  "This should display the map.

A map should mainly simply connect places together.
"
  (interactive)
  (message "%s" "Go to the map")
  (ascii-adventures-open-map (f-join aa/bewilderness-dir "house.org")))

;; This could be a jump-gate like in Ray's Maze.
;; Or it could be a 'sign' or it could be an immovable object.
;; Or it could be 'writing' on the wall or something.
(comment
 (defclass aa/static-object ()           ; No superclasses
   ((name :initarg :name
          ;; This gives the default name. It is empty.
          :initform ""
          :type string
          :custom string
          :documentation "A part of the landscape.")
    (weight :initarg :timer
            :initform 1
            :custom integer
            :type integer
            :documentation ".")
    (visible :initarg :timer
             :initform t
             :custom boolean
             :type boolean
             :documentation "."))
   "A class for describing an area."))


(comment
 (defset entrance
         (make-instance 'aa/area :name "House" :timer 1)))


;; Some objects may be generated by the program code,
;; like manna, for example.
;; Or, perhaps,
(comment
 (defclass aa/inventory-object ()        ; No superclasses
   ((name :initarg :name
          ;; This gives the default name. It is empty.
          :initform ""
          :type string
          :custom string
          :documentation "An object.")
    (weight :initarg :timer
            :initform 1
            :custom integer
            :type integer
            :documentation "."))
   "A class for describing an area."))


;; Can be drawn on the viewport.
;; Yeah, call it a 'place'.
;; [[info:(eieio) Slot Options]]
(defclass aa/area ()                    ; No superclasses
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "A place/area.")

   (name :initarg :name
         :initform ""
         :type string
         :custom string
         :documentation "A description of the area.")

   (animation-speed :initarg :timer
                    :initform 1
                    :custom integer
                    :type integer
                    :documentation "The animation speed.")

   ;; (static-objects :initarg :timer
   ;;                 :initform 1
   ;;                 :type (list-of aa/static-object)
   ;;                 :documentation "An immovable object.")

   ;; Items you can take
   ;; (inventory-objects :initarg :timer
   ;;                    :initform 1
   ;;                    :type (list-of aa/inventory-object)
   ;;                    :documentation "Objects which may be picked up.")

   ;; Yes, load these frames from the file
   (frames :initarg :frames
           :initform '()
           :type (list-of string)
           :documentation "Hypertext frames."))
  "A class for describing an area.")


;; The game world can be saved because it inherits from eieio-persistent
(defclass aa/world ()
  ((name :initarg :name
         ;; This gives the default name. It is empty.
         :initform ""
         :type string
         :custom string
         :documentation "A game world.")

   (areas :initarg :areas
          :type (list-of aa/area)
          :documentation "The areas in the world.")

   (entrance :initarg :entrance
             :type (or null aa/area)
             :documentation "The entry/exit area to the world."))
  "A class for describing the game world.")


(defclass aa/gamestate (eieio-persistent)
  ((world :initarg :world
          ;; This gives the default name. It is empty.
          :type (or null aa/world)
          :documentation "The current world.")

   (area :initarg :area
         :type (or null aa/area)
         :documentation "The current area."))
  "A class for describing the game state.")


;; I should really load this from a database
(defset aa/current-gamestate (aa/gamestate))


(cl-defmethod aa/enter-world ((world aa/world))
  "Start a new game"

  (let ((worldname (slot-value world 'name)))
    (message "Entering world %s"  worldname)
    (set-slot-value aa/current-gamestate 'world world)))


;; The world is inside of
;; I should actually load/initialize this the way ebdb does.
(defset world (aa/world :name "Imagiverse" :entrance))


(comment
 (let ((entrance (aa/area :name "Big House"))
       (world (aa/world :name "Big World")))
   (aa/enter-world world)))


;; TODO Open the house.org file in j:hypertext-mode
;; Hypertext mode will be renamed as ascii-adventures-mode
;; because it will be the major mode for playing the game.
;; j:open-hypertext
;; j:load-place-from-file

;; OK, so how do I store game state?
;; I should probably use an emacs buffer for the game state
;; That way, I can open the buffer to tweak variable as the game is running'

;; I guess that I will use objects to store game state.
;; However, it may be better to use org files to store the state.

;; Here, area is a variable
;; Make methods as I need them
(comment
 (cl-defmethod aa/goto-place ((place aa/area) &optional scriptname)
   ""
   (message "Going to %s"  (slot-value area 'name))

   (slot-value pers 'animation-speed)))


;; I won't typically need to have many areas remain open in memory,
;; because I will be only at a single place at a time.
;; But, actually, I *do* want persistent world state.
;; How will I do that?

(defset entrance
        (aa/area :name "House" :timer 1))


;; j:ebdb-save
;; j:ebdb-save-on-emacs-exit
;; There's a bunch of these initialize-instance methods.
;; That's because it's a defgeneric
;; j:initialize-instance
;; v +/"^(cl-defmethod initialize-instance ((field ebdb-field-labeled)" "$HOME/repos/ebdb/ebdb.el"

(cl-defmethod initialize-instance ((db aa/world) &optional slots)
  "Make sure DB has a uuid.
Also switch old :object-name slot name to :label."
  (let ((obj-name (plist-get slots :object-name))
        p)
    (unless (and (slot-boundp db 'uuid)
                 (slot-value db 'uuid))
      (setf (slot-value db 'uuid)
            (make-instance 'aa/field-uuid
                           :uuid (aa/make-uuid
                                  (slot-value db 'uuid-prefix)))))
    (while slots
      (when (not (eq :object-name (car slots)))
        (setq p (plist-put p (car slots) (nth 1 slots))))
      (setq slots (cddr slots)))
    (when obj-name
      (setq p (plist-put p :label obj-name)))
    (cl-call-next-method db p)))


(defun aa/reload-database (db)
  "Reload all records from database DB."
  (interactive (list (aa/prompt-for-db nil t)))
  (let ((db-str (aa/string db))
        (rec-uuids (mapcar #'aa/record-uuid (slot-value db 'records))))
    ;; I don't actually know if keeping pointers to DB's records would
    ;; interfere with the reloading of the database.  I suspect it
    ;; wouldn't, but safer to use the uuids.
    (message "Reloading %s..." db-str)
    (aa/redisplay-records rec-uuids 'unload)
    (aa/db-reload db)
    (aa/redisplay-records rec-uuids 'reformat)
    (message "Reloading %s... done" db-str)))


;; Do I really want to maintain a separate state?
;; It *would* be useful for automating the game, of course:
;; - searching for things.
;; If it was filesystem-based-state then it would work nicely across hyperdrive, for example.
(comment
 (defset entrance
         (make-instance 'aa/area :name "House" :timer 1))
 ;; Rename the area
 (set-slot-value entrance 'name "Big house")

 (aa/area-p entrance)

 (slot-value entrance 'name)
 (oref entrance name)
 (oref-default entrance name)

 ;; Rename the house yet again
 (oset entrance name "Giant house")

 ;; Change the default name for new objects of type  aa/area
 (oset-default aa/area name "Unnamed place")

 (object-add-to-list entrance 'objects item &optional append))

;; OK, so I need to think about how I load this
(defun load-place-from-file (path)
  (setq path (umn path))

  ;; I guess this is parsing it twice
  (let ((parse (org-parser-parse-file path))
        (b (open-hypertext-in-buffer path)))))

(comment
 (load-place-from-file "$HOME/notes/ws/ascii-adventures/house.org")

 (open-hypertext-in-buffer))

;; parent: special-mode, fundamental-mode or text-mode
(define-derived-mode ascii-adventures-mode hypertext-mode "ASCII Adventures"
  "ASCII Adventures major mode.
\\{ascii-adventures-mode-map}"
  (defvar-local area-file nil))


(defun pen-org-parse-file (filepath)
  "Parse FILENAME into a list of structure items."
  (with-temp-buffer
    (insert-file-contents filepath)
    (org-element-parse-buffer)))

(comment
 (defun org-sync-snippets--iterate-org-src (org-file)
   "Iterate over source blocks of ORG-FILE.
Return list of cons '((destination content)"
   (with-temp-buffer
     (insert-file-contents org-file)
     (org-element-map (org-element-parse-buffer) 'src-block
       (lambda (el)
         (cons
          (org-sync-snippets--decode-snippets-dir
           org-sync-snippets-snippets-dir
           (replace-regexp-in-string "^:tangle " "" (org-element-property :parameters el)))
          (org-element-property :value el)))))))

;; j:animate-birthday-present
;; mx:animate-birthday-present

(comment
 (add-hook 'kill-buffer-hook
           (lambda ()
             (when (timerp my-local-timer)
               (cancel-timer my-local-timer)))))

;; TODO Make it so
;; - I can easily add new areas
;;   - Edit the current area by opening the current area file
;;   - Make an org link which when clicked opens a new area file and expands the template

;; mx:list-timers

;; TODO Make it so if I open an org file and it is an area file, it should load it
;; (add-to-list 'auto-mode-alist '("\\.jq$" . jq-mode))

;; This should open the game, I guess? Nah. I still want to be able to easily edit.
;; But I should be able to easily open the org file from the game
;; e:/volumes/home/shane/var/smulliga/source/git/ascii-adventures/bewilderness/house.org
;; e:/volumes/home/shane/var/smulliga/source/git/ascii-adventures/bewilderness/map.org

(defset aa/animation-timer nil)
(defset aa/filepath nil)

(defun ascii-adventures-open-map (filepath)
  "Create a new untitled buffer from a string."
  (interactive (list (read-file-name "ASCII Adventures area: "
                                     aa/mapdir)))

  (setq filepath (or filepath (f-join aa/bewilderness-dir "house.org")))

  ;; [[el:(open-hypertext-in-buffer "/volumes/home/shane/var/smulliga/source/git/ascii-adventures/bewilderness/house.org")]]

  ;; [[el:(etv (pps (org-parser-parse-file (umn "/volumes/home/shane/var/smulliga/source/git/ascii-adventures/bewilderness/house.org"))))]]

  (let ((buf
         (let ((nodisplay nil)
               ;; (parse (org-parser-parse-file filepath))
               (parse (pen-org-parse-file filepath)))
           (let (;; (buffer (generate-new-buffer "ascii adventures"))
                 (buffer (switch-to-buffer "ascii adventures")))
             ;; (set-buffer-major-mode buffer)

             (if (not nodisplay)
                 (display-buffer buffer '(display-buffer-same-window . nil)))

             (when (timerp aa/animation-timer)
               (cancel-timer aa/animation-timer))

             (with-current-buffer buffer
               (setq buffer-read-only nil)
               (beginning-of-buffer)

               (defset aa/parse parse)
               (defset aa/frames (mapcar 'cdr (org-sync-snippets--iterate-org-src filepath)))
               ;; (tv (second aa/frames))

               (comment
                (with-temp-buffer
                  (ignore-errors (insert-file-contents filepath))
                  (org-element-map (org-element-parse-buffer 'headline) 'headline
                    (lambda (headline)
                      (when-let ((id (org-element-property :ID headline)))
                        (unless (org-brain-id-exclude-taggedp id)
                          (org-brain-entry-from-id id))))
                    nil nil 'headline)))

               ;; (defvar-local aa/parse2 parse2)

               ;; There's  a better way of doing this

               ;; (defvar-local aa/settings (ht-get aa/parse :in-buffer-settings))
               ;; (defvar-local aa/content (ht-get aa/parse :in-buffer-content))

               ;; Search for heading Frames
               ;; enumerate all the babel source blocks

               (comment
                (insert (pps aa/parse)))

               (comment
                (let ((first-frame (car aa/frames)))
                  (comment (insert (car aa/frames)))

                  (animate-string (car aa/frames) 0 0)))

               ;; This seems to clear the local variables
               (ascii-adventures-mode)
               ;; (picture-mode-exit)

               ;; Don't use local vars.
               ;; Instead, just have only one ascii-adventures mode buffer at a time

               (let* ((frameproperties (org-element-map parse 'node-property (lambda (el) (org-element-property :value el))) ))
                 ;; Therefore I need to set them again
                 (defset aa/parse parse)
                 (defset aa/filepath filepath)
                 (defset aa/frames (mapcar 'cdr (org-sync-snippets--iterate-org-src aa/filepath)))
                 ;; (tv parse)
                 (defset aa/delay (string-to-int (first frameproperties)))
                 ;; (defset aa/enddelay (string-to-int (second frameproperties)))
                 (defset aa/animation-timer nil)
                 (defset aa/buf (current-buffer)))

               (setq aa/animation-timer
                     (run-with-timer 0 aa/delay
                                     ;; Animation
                                     (lambda (buf)
                                       (if (not (buffer-live-p buf))
                                           (when (timerp aa/animation-timer)
                                             (cancel-timer aa/animation-timer)))

                                       (ignore-errors
                                         (when (and (buffer-live-p buf)
                                                    (not avy--overlays-back)
                                                    org-descriptive-links
                                                    (not (pen-selected-p)))
                                           (with-current-buffer buf
                                             ;; (set-window-start nil 1)
                                             ;; (ignore-errors (picture-mode-exit))
                                             (with-writable-buffer
                                              (comment
                                               (cl-loop for f in aa/frames
                                                        do
                                                        (save-excursion-reliably
                                                         (erase-buffer)
                                                         (insert f))
                                                        (redraw-frame)
                                                        (sit-for aa/delay)))

                                              ;; Saving the window point hasn't really worked
                                              (let* ((win (get-buffer-window buf))
                                                     (wp (window-point win)))
                                                (save-excursion-reliably
                                                 (erase-buffer)
                                                 (insert (-select-mod-element aa/frames (truncate (time-to-seconds)))))
                                                (set-window-point win wp))

                                              ;; (redraw-frame)
                                              ;; (sit-for aa/delay)
                                              )))))
                                     (current-buffer)))

               (comment
                (etv (pps aa/parse) 'emacs-lisp-mode)))
             buffer))))))

(defun aa/edit-area ()
  (interactive)
  (let* ((b (buffer-live-p "ascii adventures"))
         (fp aa/filepath))

    (if (f-file-p aa/filepath)
        (find-file aa/filepath)

        ;; (ascii-adventures-open-map aa/filepath)
      )))

(define-key ascii-adventures-mode-map (kbd "o") 'aa/edit-area)

(defun ascii-adventures ()
  (interactive)
  (when (timerp aa/animation-timer)
    (cancel-timer aa/animation-timer))
  (ascii-adventures-open-map (f-join aa/bewilderness-dir "house.org")))

(universal-sidecar-define-section ascii-adventures-section (file title)
                                  (
                                   :major-modes ascii-adventures-mode
                                                ;; :predicate (not (buffer-modified-p))
                                                )
  (ignore-errors (let* ((mm-string (with-current-buffer buffer (str major-mode)))
                        (parse (with-current-buffer buffer (org-element-parse-buffer)))
                        (title mm-string))
                   
                   (universal-sidecar-insert-section ascii-adventures-section title
                     (insert
                      (universal-sidecar-fontify-as org-mode ((org-fold-core-style 'overlays))
                        ;; This is inserted
                        ;; "[[el:(sps)][Split screen]]"
                        (pps (org-element-map parse 'link
                               (lambda (link)
                                 (when (string= (org-element-property :type link) "el")
                                   (org-element-property :path link)))))
                        ;; This runs after the above
                        (comment (some-post-processing-of-org-text))))))))

(add-to-list 'universal-sidecar-sections '(ascii-adventures-section :title "ASCII Adventures!"))

(provide 'pen-ascii-adventures)
